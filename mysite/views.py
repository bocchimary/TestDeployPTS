from datetime import datetime, timezone as dt_timezone, timedelta
from django.shortcuts import render, redirect, get_object_or_404
from django.http import JsonResponse, HttpResponse
from django.views.decorators.http import require_http_methods, require_POST
from django.views.decorators.csrf import csrf_exempt
from django.contrib import messages
from django.contrib.auth import get_user_model, authenticate, login as auth_login, logout, update_session_auth_hash
from django.db import IntegrityError, transaction
from django.contrib.auth.decorators import login_required
from landing.models import StudentProfile, AlumniProfile, DocumentRequest, ClearanceForm, ClearanceSignatory, EnrollmentForm, GraduationForm, GraduationSignatory, EnrollmentSignatory, AuditLog, SignatoryProfile, SignatoryActivityLog, BusinessManagerActivityLog, AutoGeneratedReport, GeneratedReport, BusinessManagerProfile
from django.core.files.storage import default_storage
import uuid
from datetime import date, timedelta
import json
from django.db.models import Q
from django.utils import timezone
import time
from django.core.cache import cache
from django.views.decorators.cache import cache_page
import pytz
from django.template.loader import render_to_string
from django.core.files.base import ContentFile
import os
from django.conf import settings
from django.core.files.images import get_image_dimensions



User = get_user_model()

# --------------------
# UTILITY FUNCTIONS FOR DUPLICATE-SAFE RECORD HANDLING
# --------------------

def get_or_update_signatory_record(clearance_id, signatory, status, comment=None, ip_address=None):
    """
    Safely get or create/update a signatory record, handling duplicates gracefully.
    This function is transaction-safe and prevents race conditions.
    """
    from django.db import transaction
    from django.db.utils import IntegrityError
    
    with transaction.atomic():
        try:
            # Try to get existing records
            existing_records = ClearanceSignatory.objects.select_for_update().filter(
                clearance_id=clearance_id,
                signatory=signatory
            )
            
            if existing_records.exists():
                # Update the first record
                signatory_record = existing_records.first()
                signatory_record.status = status
                signatory_record.comment = comment or signatory_record.comment
                signatory_record.ip_address = ip_address or signatory_record.ip_address
                signatory_record.seen_by_signatory = True
                signatory_record.save()
                
                # Clean up any duplicates
                duplicate_count = existing_records.count() - 1
                if duplicate_count > 0:
                    duplicate_ids = list(existing_records.values_list('id', flat=True))[1:]
                    ClearanceSignatory.objects.filter(id__in=duplicate_ids).delete()
                    print(f"[CLEANUP] Deleted {duplicate_count} duplicate ClearanceSignatory records for clearance {clearance_id}")
                    
                return signatory_record
            else:
                # Create new record
                try:
                    return ClearanceSignatory.objects.create(
                        clearance_id=clearance_id,
                        signatory=signatory,
                        status=status,
                        comment=comment,
                        ip_address=ip_address,
                        seen_by_signatory=True
                    )
                except IntegrityError:
                    # Handle race condition - record was created by another request
                    print(f"[RACE CONDITION] Record created by another request, fetching existing record for clearance {clearance_id}")
                    return ClearanceSignatory.objects.get(clearance_id=clearance_id, signatory=signatory)
                    
        except Exception as e:
            print(f"[ERROR] Exception in get_or_update_signatory_record: {e}")
            # Fallback: try to get any existing record
            existing = ClearanceSignatory.objects.filter(clearance_id=clearance_id, signatory=signatory).first()
            if existing:
                return existing
            raise

def cleanup_duplicate_signatory_records():
    """
    Utility function to clean up existing duplicate records in the database.
    This can be run as a management command or migration.
    """
    from django.db.models import Count
    
    # Find clearance-signatory combinations that have duplicates
    duplicates = (ClearanceSignatory.objects
                 .values('clearance_id', 'signatory_id')
                 .annotate(count=Count('id'))
                 .filter(count__gt=1))
    
    total_deleted = 0
    for duplicate in duplicates:
        records = ClearanceSignatory.objects.filter(
            clearance_id=duplicate['clearance_id'],
            signatory_id=duplicate['signatory_id']
        ).order_by('updated_at')  # Keep the most recent one
        
        # Delete all but the first (most recent) record
        records_to_delete = records[1:]
        count = len(records_to_delete)
        for record in records_to_delete:
            record.delete()
        
        total_deleted += count
        print(f"[CLEANUP] Cleaned up {count} duplicates for clearance {duplicate['clearance_id']} and signatory {duplicate['signatory_id']}")
    
    print(f"[CLEANUP] Total duplicate records cleaned up: {total_deleted}")
    return total_deleted

def convert_html_to_pdf(html_content):
    """Convert HTML content to PDF using multiple fallback options, preserving styling"""
    import io
    from datetime import datetime, timezone as dt_timezone
    import logging
    logger = logging.getLogger(__name__)
    
    # Try xhtml2pdf FIRST - Works reliably on Windows and preserves styling
    try:
        from xhtml2pdf import pisa
        
        logger.info("Using xhtml2pdf for PDF generation (preserves styling)")
        
        # Create a PDF buffer
        pdf_buffer = io.BytesIO()
        
        # Convert HTML to PDF
        pisa_status = pisa.CreatePDF(html_content, dest=pdf_buffer)
        
        # Check if conversion was successful
        if not pisa_status.err:
            pdf_buffer.seek(0)
            return pdf_buffer.getvalue()
        else:
            logger.warning(f"xhtml2pdf conversion had errors: {pisa_status.err}")
            raise Exception(f"xhtml2pdf conversion failed with {pisa_status.err} errors")
            
    except (ImportError, Exception) as e:
        logger.warning(f"xhtml2pdf failed: {e}, trying ReportLab fallback")
        # ReportLab fallback - try to preserve some basic styling
        try:
            from reportlab.lib.pagesizes import A4
            from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
            from reportlab.lib.styles import getSampleStyleSheet, ParagraphStyle
            from reportlab.lib import colors
            from reportlab.lib.units import inch
            from html import unescape
            import re
            
            logger.info("Using ReportLab for PDF generation (limited styling)")
            
            buffer = io.BytesIO()
            doc = SimpleDocTemplate(buffer, pagesize=A4, topMargin=20*72/25.4, bottomMargin=25*72/25.4, leftMargin=20*72/25.4, rightMargin=20*72/25.4)
            styles = getSampleStyleSheet()
            story = []
            
            # Professional academic styles
            letterhead_style = ParagraphStyle(
                'LetterheadTitle',
                parent=styles['Title'],
                fontSize=18,
                spaceAfter=8,
                alignment=1,  # Center
                textColor=colors.HexColor('#1a365d'),
                fontName='Times-Bold',
                letterSpacing=1
            )
            
            institution_subtitle_style = ParagraphStyle(
                'InstitutionSubtitle',
                parent=styles['Normal'],
                fontSize=12,
                spaceAfter=6,
                alignment=1,  # Center
                textColor=colors.HexColor('#2c5aa0'),
                fontName='Times-Italic'
            )
            
            office_style = ParagraphStyle(
                'OfficeStyle',
                parent=styles['Normal'],
                fontSize=11,
                spaceAfter=20,
                alignment=1,  # Center
                textColor=colors.HexColor('#666666'),
                fontName='Times-Roman'
            )
            
            title_style = ParagraphStyle(
                'DocumentTitle',
                parent=styles['Title'],
                fontSize=16,
                spaceAfter=12,
                alignment=1,  # Center
                textColor=colors.HexColor('#1a365d'),
                fontName='Times-Bold',
                letterSpacing=0.5
            )
            
            metadata_label_style = ParagraphStyle(
                'MetadataLabel',
                parent=styles['Normal'],
                fontSize=11,
                spaceAfter=4,
                textColor=colors.HexColor('#1a365d'),
                fontName='Times-Bold'
            )
            
            metadata_value_style = ParagraphStyle(
                'MetadataValue',
                parent=styles['Normal'],
                fontSize=11,
                spaceAfter=4,
                textColor=colors.HexColor('#1a1a1a'),
                fontName='Times-Roman'
            )
            
            # Add institutional letterhead
            story.append(Paragraph("PHILIPPINE THEOLOGICAL SEMINARY", letterhead_style))
            story.append(Paragraph("Academic Excellence in Christian Education", institution_subtitle_style))
            story.append(Paragraph("Office of the Registrar - Student Records Management", office_style))
            
            # Add separator line
            from reportlab.platypus import HRFlowable
            story.append(HRFlowable(width="100%", thickness=2, color=colors.HexColor('#1a365d')))
            story.append(Spacer(1, 20))
            
            # Extract and add document title
            title_match = re.search(r'<div[^>]*class="document-title"[^>]*>([^<]+)</div>', html_content, re.IGNORECASE)
            if title_match:
                story.append(Paragraph(title_match.group(1).strip().upper(), title_style))
            else:
                story.append(Paragraph("STUDENT RECORDS ACTIVITY REPORT", title_style))
            
            story.append(Paragraph("Official Academic Document", metadata_value_style))
            story.append(Spacer(1, 20))
            
            # Extract and add metadata in professional format
            gen_date_match = re.search(r'Generated On:</div>.*?<div[^>]*class="metadata-value"[^>]*>([^<]+)</div>', html_content, re.DOTALL | re.IGNORECASE)
            gen_by_match = re.search(r'Generated By:</div>.*?<div[^>]*class="metadata-value"[^>]*>([^<]+)</div>', html_content, re.DOTALL | re.IGNORECASE)
            period_match = re.search(r'Report Period:</div>.*?<div[^>]*class="metadata-value"[^>]*>([^<]+)</div>', html_content, re.DOTALL | re.IGNORECASE)
            total_match = re.search(r'Total Records:</div>.*?<div[^>]*class="metadata-value"[^>]*>([^<]+)</div>', html_content, re.DOTALL | re.IGNORECASE)
            
            # Create metadata table
            metadata = []
            if gen_date_match:
                metadata.append(["Generated On:", gen_date_match.group(1).strip()])
            if gen_by_match:
                metadata.append(["Generated By:", gen_by_match.group(1).strip()])
            if period_match:
                metadata.append(["Report Period:", period_match.group(1).strip()])
            if total_match:
                metadata.append(["Total Records:", total_match.group(1).strip()])
            
            if metadata:
                metadata_table = Table(metadata, colWidths=[2*inch, 4*inch])
                metadata_table.setStyle(TableStyle([
                    ('FONTNAME', (0, 0), (0, -1), 'Times-Bold'),
                    ('FONTNAME', (1, 0), (1, -1), 'Times-Roman'),
                    ('FONTSIZE', (0, 0), (-1, -1), 11),
                    ('TEXTCOLOR', (0, 0), (0, -1), colors.HexColor('#1a365d')),
                    ('TEXTCOLOR', (1, 0), (1, -1), colors.HexColor('#1a1a1a')),
                    ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                    ('LEFTPADDING', (0, 0), (-1, -1), 0),
                    ('RIGHTPADDING', (0, 0), (-1, -1), 12),
                    ('TOPPADDING', (0, 0), (-1, -1), 3),
                    ('BOTTOMPADDING', (0, 0), (-1, -1), 3),
                ]))
                story.append(metadata_table)
            
            story.append(Spacer(1, 25))
            
            # Extract table data
            table_match = re.search(r'<table[^>]*class="data-table"[^>]*>(.*?)</table>', html_content, re.DOTALL | re.IGNORECASE)
            if table_match:
                table_html = table_match.group(1)
                
                # Extract headers
                header_match = re.search(r'<thead[^>]*>(.*?)</thead>', table_html, re.DOTALL | re.IGNORECASE)
                if header_match:
                    header_html = header_match.group(1)
                    headers = re.findall(r'<th[^>]*>([^<]+)</th>', header_html, re.IGNORECASE)
                    headers = [unescape(h.strip()) for h in headers]
                else:
                    headers = ['Date & Time', 'Reference/ID', 'Requester/Student', 'Program/Dept', 'Status', 'Signatory']
                
                # Extract rows
                tbody_match = re.search(r'<tbody[^>]*>(.*?)</tbody>', table_html, re.DOTALL | re.IGNORECASE)
                if tbody_match:
                    tbody_html = tbody_match.group(1)
                    rows = re.findall(r'<tr[^>]*>(.*?)</tr>', tbody_html, re.DOTALL | re.IGNORECASE)
                    
                    table_data = [headers]
                    for row_html in rows:
                        cells = re.findall(r'<td[^>]*>(.*?)</td>', row_html, re.DOTALL | re.IGNORECASE)
                        clean_cells = []
                        for cell in cells:
                            # Clean cell content
                            clean_cell = re.sub(r'<span[^>]*class="status-pill[^>]*>([^<]+)</span>', r'\1', cell)
                            clean_cell = re.sub(r'<[^>]+>', ' ', clean_cell)
                            clean_cell = unescape(clean_cell).strip()
                            clean_cells.append(clean_cell)
                        
                        if clean_cells:
                            table_data.append(clean_cells)
                    
                    if len(table_data) > 1:  # Has data beyond headers
                        # Add table title
                        table_title_style = ParagraphStyle(
                            'TableTitle',
                            parent=styles['Normal'],
                            fontSize=12,
                            fontName='Times-Bold',
                            textColor=colors.HexColor('#1a365d'),
                            alignment=1,
                            spaceAfter=10
                        )
                        story.append(Paragraph("Student Activity Records", table_title_style))
                        
                        # Create professional academic table with fixed column widths
                        col_widths = [1.3*inch, 0.9*inch, 1.8*inch, 1.1*inch, 0.9*inch, 1.3*inch]
                        table = Table(table_data, colWidths=col_widths, repeatRows=1)
                        table.setStyle(TableStyle([
                            # Header styling - Academic blue
                            ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#1a365d')),
                            ('TEXTCOLOR', (0, 0), (-1, 0), colors.white),
                            ('FONTNAME', (0, 0), (-1, 0), 'Times-Bold'),
                            ('FONTSIZE', (0, 0), (-1, 0), 9),
                            ('ALIGN', (0, 0), (-1, 0), 'LEFT'),
                            ('VALIGN', (0, 0), (-1, -1), 'TOP'),
                            
                            # Data styling
                            ('FONTNAME', (0, 1), (-1, -1), 'Times-Roman'),
                            ('FONTSIZE', (0, 1), (-1, -1), 9),
                            
                            # Grid lines
                            ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#d0d7de')),
                            ('LINEBELOW', (0, 0), (-1, 0), 2, colors.HexColor('#1a365d')),
                            
                            # Alternating row colors
                            ('ROWBACKGROUNDS', (0, 1), (-1, -1), [colors.white, colors.HexColor('#f6f8fa')]),
                            
                            # Professional padding
                            ('TOPPADDING', (0, 0), (-1, -1), 8),
                            ('BOTTOMPADDING', (0, 0), (-1, -1), 8),
                            ('LEFTPADDING', (0, 0), (-1, -1), 6),
                            ('RIGHTPADDING', (0, 0), (-1, -1), 6),
                            
                            # Center alignment for specific columns
                            ('ALIGN', (1, 1), (1, -1), 'CENTER'),  # Reference ID
                            ('ALIGN', (4, 1), (4, -1), 'CENTER'),  # Status
                        ]))
                        story.append(table)
                    else:
                        # No data message
                        no_data_style = ParagraphStyle(
                            'NoData',
                            parent=styles['Normal'],
                            fontSize=14,
                            alignment=1,
                            textColor=colors.HexColor('#4a5568'),
                            spaceAfter=10
                        )
                        story.append(Paragraph("No records found", no_data_style))
                        story.append(Paragraph("No data was found for the specified criteria and date range.", styles['Normal']))
            
            # Add signature section
            story.append(Spacer(1, 40))
            signature_line = HRFlowable(width=3.5*inch, thickness=1, color=colors.HexColor('#1a365d'))
            signature_line.hAlign = 'RIGHT'
            story.append(signature_line)
            
            signature_style = ParagraphStyle(
                'Signature',
                parent=styles['Normal'],
                fontSize=10,
                textColor=colors.HexColor('#666666'),
                alignment=2,  # Right align
                topSpace=5
            )
            story.append(Paragraph("Registrar / Authorized Official", signature_style))
            
            doc.build(story)
            logger.info("PDF generated using ReportLab with enhanced styling")
            return buffer.getvalue()
            
        except Exception as fallback_error:
            logger.error(f"ReportLab fallback failed: {fallback_error}")
            # Final fallback - return HTML as bytes
            logger.warning("All PDF engines failed, returning HTML content as bytes")
            return html_content.encode('utf-8')

def get_client_ip(request):
    """Get the client's IP address"""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip

def extract_ip_from_description(description):
    """Extract IP address from AuditLog description if present"""
    import re
    if not description:
        return None
    
    # Look for [IP: xxx.xxx.xxx.xxx] pattern
    match = re.search(r'\[IP:\s*([^\]]+)\]', description)
    if match:
        return match.group(1).strip()
    return None

# LANDING PAGE
def landing(request):
    return render(request, 'home.html')

# OTP PAGE
def otp(request):
    return render(request, 'otp.html')

# Trial page
def trial(request):
    return render(request, 'trial.html')


# Main login/signup page
def login(request):
    return render(request, 'login.html')

def logout_view(request):
    logout(request)
    return redirect('login')  # Replace 'login' with your login URL name


# Login functionality
def login_view(request):
    if request.method == 'POST':
        email = request.POST.get('login-email', '').strip()
        password = request.POST.get('login-password', '')
        
        # Check if this is an AJAX request
        is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest'

        print(f"POST login received - Email: {email}, AJAX: {is_ajax}")
        
        # Validate input fields
        errors = {}
        field_errors = {}
        
        if not email:
            field_errors['email'] = 'Email is required'
        elif email != 'admin' and (not email.count('@') == 1 or not '.' in email.split('@')[1]):
            field_errors['email'] = 'Please enter a valid email address'
            
        if not password:
            field_errors['password'] = 'Password is required'
        elif len(password) < 8:
            field_errors['password'] = 'Password must be at least 8 characters long'
        
        if field_errors:
            if is_ajax:
                return JsonResponse({
                    'success': False,
                    'error': 'Please correct the errors below',
                    'field_errors': field_errors
                })
            else:
                for field, error in field_errors.items():
                    messages.error(request, error)
                return redirect('login')

        # Check if user exists
        try:
            if email == 'admin':
                existing_user = User.objects.get(username=email)
            else:
                existing_user = User.objects.get(email=email)
        except User.DoesNotExist:
            if email == 'admin':
                error_msg = 'Admin account not found'
                if is_ajax:
                    return JsonResponse({
                        'success': False,
                        'error': error_msg,
                        'field_errors': {'email': error_msg}
                    })
                else:
                    messages.error(request, error_msg)
                    return redirect('login')
            else:
                # Check if user is in pending approval
                from landing.models import PendingUser
                try:
                    pending_user = PendingUser.objects.get(email=email)
                    if pending_user.approval_status == 'pending':
                        error_msg = 'Your account is still pending approval. You will receive an email notification once approved.'
                    elif pending_user.approval_status == 'declined':
                        error_msg = 'Your account application was declined. Please contact the registrar for more information.'
                    else:
                        error_msg = 'Account status unclear. Please contact the registrar.'
                    
                    if is_ajax:
                        return JsonResponse({
                            'success': False,
                            'error': error_msg,
                            'redirect_url': '/waiting-approval/' if pending_user.approval_status == 'pending' else None
                        })
                    else:
                        messages.warning(request, error_msg)
                        if pending_user.approval_status == 'pending':
                            return redirect('waiting_approval')
                        else:
                            return redirect('login')
                            
                except PendingUser.DoesNotExist:
                    error_msg = 'No account found with this email address'
                    if is_ajax:
                        return JsonResponse({
                            'success': False,
                            'error': error_msg,
                            'field_errors': {'email': error_msg}
                        })
                    else:
                        messages.error(request, error_msg)
                        return redirect('login')

        # Attempt authentication
        if email == 'admin':
            user = authenticate(request, username='admin', password=password)
        else:
            user = authenticate(request, username=email, password=password)
        print("Authenticated:", user)

        if user is not None:
            auth_login(request, user)

            # Determine redirect URL based on role
            redirect_url = '/'
            if user.user_type == 'student':
                redirect_url = '/dashboard/'
            elif user.user_type == 'alumni':
                redirect_url = '/dashboard/'
            elif user.user_type == 'signatory':
                # Check if this is a Business Manager
                signatory_type = None
                if hasattr(user, 'signatory_profile'):
                    signatory_type = user.signatory_profile.signatory_type
                    print(f"DEBUG: Signatory type found: '{signatory_type}'")
                else:
                    print(f"DEBUG: No signatory_profile found for user {user.username}")
                
                if signatory_type == 'business_manager':
                    print(f"DEBUG: Redirecting {user.username} to business_manager_dashboard")
                    redirect_url = '/business-manager/dashboard/'
                else:
                    print(f"DEBUG: Redirecting {user.username} to signatory_dashboard")
                    redirect_url = '/signatory/dashboard/'
            elif user.user_type == 'admin':
                redirect_url = '/registrar/dashboard/'
            elif user.user_type == 'business_manager':
                redirect_url = '/business-manager/dashboard/'
            
            if is_ajax:
                return JsonResponse({
                    'success': True,
                    'message': 'Login successful!',
                    'redirect_url': redirect_url
                })
            else:
                # Traditional redirect for non-AJAX requests
                return redirect(redirect_url)
        else:
            error_msg = 'Incorrect password. Please try again.'
            if is_ajax:
                return JsonResponse({
                    'success': False,
                    'error': error_msg,
                    'field_errors': {'password': error_msg}
                })
            else:
                messages.error(request, error_msg)
                return redirect('login')

    return render(request, 'login.html')

# Student Signup
def student_signup(request):
    print("✅ student_signup view called")
    if request.method == 'POST':
        try:
            email = request.POST['signup-student-email']

            # ✅ Check if user already exists
            if User.objects.filter(username=email).exists():
                messages.error(request, "An account with this email already exists.")
                return redirect('login')

            # Store all signup data
            signup_data = {
                'first_name': request.POST['signup-student-first-name'],
                'middle_name': request.POST['signup-student-middle-name'],
                'last_name': request.POST['signup-student-last-name'],
                'suffix': request.POST.get('signup-student-suffix', ''),
                'contact': request.POST['signup-student-contact'],
                'address': request.POST['signup-student-address'],
                'gender': request.POST['signup-student-gender'],
                'birthdate': request.POST['signup-student-birthdate'],
                'student_id': request.POST['signup-student-id'],
                'course': request.POST['signup-student-course'],
                'password': request.POST['signup-student-password'],
            }

            # Handle profile picture
            profile_pic = request.FILES.get('signup-student-profilepic', None)
            if profile_pic:
                # Store file temporarily - this will be processed after OTP verification
                import uuid
                temp_path = f"temp_profile_pics/{uuid.uuid4()}_{profile_pic.name}"
                saved_path = default_storage.save(temp_path, profile_pic)
                signup_data['profile_pic_path'] = saved_path

            # Generate and send OTP
            from landing.models import OTPVerification
            import random
            from datetime import timedelta
            from django.core.mail import send_mail
            from django.conf import settings

            # Generate 4-digit OTP
            otp_code = str(random.randint(1000, 9999))
            expires_at = timezone.now() + timedelta(minutes=10)  # 10 minutes expiry

            # Delete any existing OTP for this email
            OTPVerification.objects.filter(email=email).delete()

            # Create new OTP record
            otp_record = OTPVerification.objects.create(
                email=email,
                otp_code=otp_code,
                user_type='student',
                signup_data=signup_data,
                expires_at=expires_at
            )

            # Send OTP email
            subject = "🔐 Account Verification Code - PTS College and Advanced Studies"
            full_name = f"{signup_data['first_name']} {signup_data['middle_name']} {signup_data['last_name']}".strip()
            message = f"""
Dear {full_name},

Welcome to PTS College and Advanced Studies Clearance System!

To complete your student account registration, please use the verification code below:

═══════════════════════════════════════
    VERIFICATION CODE: {otp_code}
═══════════════════════════════════════

⏰ This code will expire in 10 minutes for security purposes.

IMPORTANT REMINDERS:
• Do not share this code with anyone
• Complete your registration within 10 minutes
• Contact our IT support if you need assistance

If you did not request this account, please ignore this email.

Best regards,
IT Department
PTS College and Advanced Studies
Clearance Management System

---
This is an automated message. Please do not reply to this email.
For support, contact: admin@ptscollege.edu.ph
            """

            send_mail(
                subject=subject,
                message=message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[email],
                fail_silently=False
            )

            print(f"✅ OTP sent to {email}: {otp_code}")
            request.session['otp_email'] = email
            request.session['user_type'] = 'student'
            messages.success(request, f"📧 Verification code sent to {email}! Please check your inbox and enter the 4-digit code to complete your registration.")
            return redirect('verify_otp')

        except Exception as e:
            import traceback
            traceback.print_exc()
            print("❌ Error in signup:", e)
            messages.error(request, f"Signup failed: {e}")
            return redirect('login')

    return redirect('/')

# Alumni Signup
def alumni_signup(request):
    if request.method == 'POST':
        try:
            email = request.POST['signup-alumni-email']
            
            # ✅ Check if user already exists
            if User.objects.filter(username=email).exists():
                messages.error(request, "An account with this email already exists.")
                return redirect('login')

            # Store all signup data
            signup_data = {
                'first_name': request.POST['signup-alumni-first-name'],
                'middle_name': request.POST['signup-alumni-middle-name'],
                'last_name': request.POST['signup-alumni-last-name'],
                'suffix': request.POST.get('signup-alumni-suffix', ''),
                'contact': request.POST['signup-alumni-contact'],
                'address': request.POST['signup-alumni-address'],
                'gender': request.POST['signup-alumni-gender'],
                'birthdate': request.POST['signup-alumni-birthdate'],
                'alumni_id': request.POST['signup-alumni-id'],
                'course': request.POST['signup-alumni-course'],
                'year_graduated': request.POST['signup-alumni-year-graduated'],
                'password': request.POST['signup-alumni-password'],
            }

            # Handle profile picture
            profile_pic = request.FILES.get('signup-alumni-profilepic', None)
            if profile_pic:
                # Store file temporarily - this will be processed after OTP verification
                import uuid
                temp_path = f"temp_profile_pics/{uuid.uuid4()}_{profile_pic.name}"
                saved_path = default_storage.save(temp_path, profile_pic)
                signup_data['profile_pic_path'] = saved_path

            # Generate and send OTP
            from landing.models import OTPVerification
            import random
            from datetime import timedelta
            from django.core.mail import send_mail
            from django.conf import settings

            # Generate 4-digit OTP
            otp_code = str(random.randint(1000, 9999))
            expires_at = timezone.now() + timedelta(minutes=10)  # 10 minutes expiry

            # Delete any existing OTP for this email
            OTPVerification.objects.filter(email=email).delete()

            # Create new OTP record
            otp_record = OTPVerification.objects.create(
                email=email,
                otp_code=otp_code,
                user_type='alumni',
                signup_data=signup_data,
                expires_at=expires_at
            )

            # Send OTP email
            subject = "🔐 Account Verification Code - PTS College and Advanced Studies"
            full_name = f"{signup_data['first_name']} {signup_data['middle_name']} {signup_data['last_name']}".strip()
            message = f"""
Dear {full_name},

Welcome back to PTS College and Advanced Studies!

To complete your alumni account registration, please use the verification code below:

═══════════════════════════════════════
    VERIFICATION CODE: {otp_code}
═══════════════════════════════════════

⏰ This code will expire in 10 minutes for security purposes.

IMPORTANT REMINDERS:
• Do not share this code with anyone
• Complete your registration within 10 minutes
• Contact our Alumni Relations office if you need assistance

If you did not request this account, please ignore this email.

Best regards,
Alumni Relations Office
PTS College and Advanced Studies
Clearance Management System

---
This is an automated message. Please do not reply to this email.
For support, contact: alumni@ptscollege.edu.ph
            """

            send_mail(
                subject=subject,
                message=message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[email],
                fail_silently=False
            )

            print(f"✅ OTP sent to {email}: {otp_code}")
            request.session['otp_email'] = email
            request.session['user_type'] = 'alumni'
            messages.success(request, f"📧 Verification code sent to {email}! Please check your inbox and enter the 4-digit code to complete your registration.")
            return redirect('verify_otp')

        except Exception as e:
            import traceback
            traceback.print_exc()
            print("❌ Error in signup:", e)
            messages.error(request, f"Signup failed: {e}")
            return redirect('login')

    return redirect('/')

@login_required
def students(request):
    user = request.user
    profile = None
    
    # Handle both student and alumni users
    if user.user_type == 'alumni':
        try:
            profile = AlumniProfile.objects.get(user=user)
        except AlumniProfile.DoesNotExist:
            profile = None
    else:
        try:
            profile = StudentProfile.objects.get(user=user)
        except StudentProfile.DoesNotExist:
            profile = None

    tab_context = request.GET.get('tab', 'dashboard')
    edit_mode = request.GET.get('edit', 'false')

    # Prepare name parts for template
    name_parts = user.full_name.split()
    first_name = name_parts[0] if len(name_parts) > 0 else ''
    last_name = name_parts[-2] if len(name_parts) > 2 else (name_parts[-1] if len(name_parts) > 1 else '')
    suffix = name_parts[-1] if len(name_parts) > 2 else ''
    middle_name = ' '.join(name_parts[1:-2]) if len(name_parts) > 3 else (' '.join(name_parts[1:-1]) if len(name_parts) > 2 else '')

    # Handle profile info update
    if request.method == 'POST' and 'saveProfile' in request.POST:
        first_name = request.POST.get('firstName', '')
        middle_name = request.POST.get('middleName', '')
        last_name = request.POST.get('lastName', '')
        suffix = request.POST.get('suffix', '')
        full_name = f"{first_name} {middle_name} {last_name} {suffix}".strip()
        email = request.POST.get('email', user.email)
        contact = request.POST.get('contactNumber', user.contact_number)
        address = request.POST.get('address')
        
        birthday = request.POST.get('birthday')
        gender = request.POST.get('sex')
        position = request.POST.get('position')
        department = request.POST.get('department')

        user.full_name = full_name
        user.email = email
        user.contact_number = contact
        user.save()

        if profile:
            if birthday: profile.birthdate = birthday
            if gender: profile.gender = gender
            if position: profile.position = position
            if department: profile.department = department
            if address is not None: profile.address = address
            if 'profile_picture' in request.FILES:
                profile.profile_picture = request.FILES['profile_picture']
            profile.save()

        messages.success(request, "Profile updated successfully.")
        return redirect('/dashboard/?tab=profile')

    # Handle password change
    if request.method == 'POST' and 'changePassword' in request.POST:
        old_password = request.POST.get('oldPassword')
        new_password = request.POST.get('newPassword')

        errors = {}

        if not user.check_password(old_password):
            errors['old_password_error'] = "Incorrect old password."
        if len(new_password) < 8:
            errors['new_password_error'] = "New password must be at least 8 characters long."

        if errors:
            return render(request, 'students.html', {
                'profile': profile,
                'errors': errors,
                'tab': 'profile',
                'edit': 'true',
            })

        user.set_password(new_password)
        user.save()
        logout(request)
        messages.success(request, "Password changed successfully. Please log in again.")
        return redirect('login')

    # Document Request History
    history_requests = (
        DocumentRequest.objects
        .filter(requester=user)
        .order_by('-created_at')
    )
    has_requests = history_requests.exists()

    # Clearance History Check
    clearance_forms = ClearanceForm.objects.filter(student=user).order_by('-submitted_at')
    has_clearances = clearance_forms.exists()

    # Allow new clearance form if no forms exist or latest one is 'done'
    latest_clearance = clearance_forms.first()
    can_submit_new_clearance = (
        latest_clearance is None or latest_clearance.status.lower() == 'done'
    )

    # ENROLLMENT: Add these lines
    enrollment_history = EnrollmentForm.objects.filter(user=user).order_by('-created_at')
    has_enrollments = enrollment_history.exists()
    print("Enrollment count for user:", EnrollmentForm.objects.filter(user=user).count())
    print("Has enrollments:", has_enrollments)

    # Find the latest enrollment for the user
    latest_enrollment = EnrollmentForm.objects.filter(user=user).order_by('-created_at').first()
    can_submit_new_enrollment = (
        latest_enrollment is None or latest_enrollment.status.lower() not in ['pending', 'processing']
    )

    # Get appropriate ID field based on user type
    if profile:
        if user.user_type == 'alumni':
            id_number = profile.alumni_id if hasattr(profile, 'alumni_id') else ''
            program = profile.course_graduated if hasattr(profile, 'course_graduated') else ''
            year_level = profile.year_graduated if hasattr(profile, 'year_graduated') else ''
        else:
            id_number = profile.student_number if hasattr(profile, 'student_number') else ''
            program = profile.program if hasattr(profile, 'program') else ''
            year_level = profile.year_level if hasattr(profile, 'year_level') else ''
    else:
        id_number = ''
        program = ''
        year_level = ''

    enrollment_prefill = {
        'full_name': user.full_name,
        'student_number': id_number,
        'program': program,
        'year_level': year_level,
        'gender': profile.gender if profile else '',
        'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile and profile.birthdate else '',
        'contact_number': user.contact_number or '',
        'email': user.email or '',
        'address': profile.address if profile else '',
    }

    # Graduation History
    graduation_history = GraduationForm.objects.filter(user=user).order_by('-created_at')
    has_graduations = graduation_history.exists()
    latest_graduation = graduation_history.first()
    can_submit_new_graduation = (
        latest_graduation is None or latest_graduation.status.lower() not in ['pending', 'processing']
    )
    
    # Generate application number for prefill
    import random
    while True:
        app_number = f"GF-{random.randint(100000, 999999)}"
        if not GraduationForm.objects.filter(grad_appno=app_number).exists():
            break
    
    graduation_prefill = {
        'full_name': user.full_name,
        'gender': profile.gender if profile else '',
        'phone': user.contact_number or '',
        'email': user.email or '',
        'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile and profile.birthdate else '',
        'present_address': profile.address if profile else '',
        'permanent_address': profile.address if profile else '',
        'place_of_birth': '',  # This should come from user input
        'course': program,
        'grad_appno': app_number,
    }

    dashboard_forms = []

    # Document Requests
    for r in DocumentRequest.objects.filter(requester=request.user):
        dashboard_forms.append({
            'id': r.id,
            'form_type': 'Request Form',
            'purpose': r.purpose or 'Document Request',
            'status': r.status.title(),
            'created_at': r.created_at,
        })

    # Clearance Forms
    for c in ClearanceForm.objects.filter(student=request.user):
        dashboard_forms.append({
            'id': c.id,
            'form_type': 'Clearance Form',
            'purpose': c.get_clearance_type_display() if c.clearance_type else 'Clearance',
            'status': c.status.title(),
            'created_at': c.submitted_at or c.finalized_at,
        })

    # Enrollment Forms
    for e in EnrollmentForm.objects.filter(user=request.user):
        dashboard_forms.append({
            'id': e.id,
            'form_type': 'Enrollment Form',
            'purpose': 'Enrollment',
            'status': e.status.title(),
            'created_at': e.created_at,
        })

    # Graduation Forms
    for g in GraduationForm.objects.filter(user=request.user):
        dashboard_forms.append({
            'id': g.id,
            'form_type': 'Graduation Form',
            'purpose': 'Application for Graduation',
            'status': g.status.title(),
            'created_at': g.created_at,
        })

    # Sort by newest first, handling None values
    dashboard_forms.sort(key=lambda f: f['created_at'] or timezone.now().min, reverse=True)

    return render(request, 'students.html', {
        'profile': profile,
        'tab': tab_context,
        'edit': edit_mode,
        'first_name': first_name,
        'middle_name': middle_name,
        'last_name': last_name,
        'suffix': suffix,
        'has_requests':              has_requests,
        'history_requests':          history_requests,
        'has_clearances':            has_clearances,
        'clearance_forms':           clearance_forms,
        'can_submit_new_clearance':  can_submit_new_clearance,
        'today':                     date.today().isoformat(),
        # ENROLLMENT context:
        'has_enrollments':           has_enrollments,
        'enrollment_history':        enrollment_history,
        'enrollment_prefill': enrollment_prefill,
        'can_submit_new_enrollment': can_submit_new_enrollment,
        'graduation_history':        graduation_history,
        'has_graduations':           has_graduations,
        'can_submit_new_graduation': can_submit_new_graduation,
        'graduation_prefill':       graduation_prefill,
        'dashboard_forms': dashboard_forms,
    })

def profile_view(request):
    mode = request.GET.get('mode', 'display')
    context = {
        'mode': mode,
        # ...other context data...
    }
    return render(request, 'students.html', context)

@login_required
@require_http_methods(["POST"])
def handle_request(request):
    try:
        # Get form data
        document_types = []
        
        # Get regular credentials
        credentials = request.POST.getlist('request-student-credentials')
        if credentials:
            document_types.extend(credentials)
        
        # Get certification if checked
        certification = request.POST.get('request-student-certification')
        if certification:
            document_types.append(certification)
            
        # Get others if specified
        others_input = request.POST.get('request-student-other_credentials')
        if others_input and 'Others' in credentials:
            document_types.append(f"Others: {others_input}")

        if not document_types:
            return JsonResponse({
                'status': 'error',
                'message': 'Please select at least one document type'
            }, status=400)
        
        semester = request.POST.get('request-student-semester', '0')  # Default to 'None'

        # Check if this is editing an existing draft
        request_id = request.POST.get('request_id')
        is_draft_mode = request.POST.get('is_draft') == 'true'
        
        if request_id:
            # Update existing request (edit mode)
            try:
                existing_request = DocumentRequest.objects.get(id=request_id, requester=request.user)
                was_draft = existing_request.status == 'draft'
                existing_request.document_type = ','.join(document_types)
                existing_request.purpose = request.POST.get('request-student-purpose')
                existing_request.semester = semester
                existing_request.status = 'draft' if is_draft_mode else 'pending'
                existing_request.is_draft = is_draft_mode
                existing_request.save()
                new_request = existing_request
                
                # Send notification if draft is being submitted as pending
                if was_draft and not is_draft_mode and new_request.status == 'pending':
                    try:
                        from landing.notification_service import NotificationService
                        NotificationService.notify_form_submission(new_request, 'document_request')
                    except Exception as notification_error:
                        print(f"Notification error for document request: {notification_error}")
            except DocumentRequest.DoesNotExist:
                # Fallback to creating new if ID doesn't exist
                new_request = DocumentRequest.objects.create(
                    requester=request.user,
                    document_type=','.join(document_types),
                    purpose=request.POST.get('request-student-purpose'),
                    semester=semester,
                    status='draft' if is_draft_mode else 'pending',
                    is_draft=is_draft_mode
                )
        else:
            # Create new request
            new_request = DocumentRequest.objects.create(
                requester=request.user,
                document_type=','.join(document_types),
                purpose=request.POST.get('request-student-purpose'),
                semester=semester,
                status='draft' if is_draft_mode else 'pending',
                is_draft=is_draft_mode
            )

        # Send notification for newly submitted document requests (not drafts)
        if not is_draft_mode and new_request.status == 'pending':
            try:
                from landing.notification_service import NotificationService
                NotificationService.notify_form_submission(new_request, 'document_request')
            except Exception as notification_error:
                print(f"Notification error for document request: {notification_error}")

        return JsonResponse({
            'status': 'success',
            'message': 'Request saved successfully',
            'request_id': str(new_request.id),
            'created_at': new_request.created_at.strftime('%Y-%m-%d %H:%M:%S'),
            'document_type': new_request.document_type,
            'status': new_request.status
        })

    except Exception as e:
        return JsonResponse({
            'status': 'error',
            'message': str(e)
        }, status=500)

@require_POST
@login_required
def delete_request(request, request_id):
    try:
        doc_request = DocumentRequest.objects.get(id=request_id, requester=request.user)
        doc_request.delete()
        return JsonResponse({'status': 'success', 'message': 'Request deleted successfully'})
    except DocumentRequest.DoesNotExist:
        return JsonResponse({'status': 'error', 'message': 'Request not found'}, status=404)

@login_required
def view_request(request, request_id):
    request_obj = get_object_or_404(DocumentRequest, id=request_id)
    requester = request_obj.requester

    # Extract document types and check for "Others"
    document_types = request_obj.document_type.split(',')
    other_val = next((t for t in document_types if t.strip().startswith("Others:")), "")

    context = {
        'first_name': requester.first_name if hasattr(requester, 'first_name') else requester.full_name.split()[0],
        'middle_name': getattr(requester, 'middle_name', ''),
        'last_name': requester.last_name if hasattr(requester, 'last_name') else requester.full_name.split()[-1],
        'suffix': getattr(requester, 'suffix', ''),

        'course': getattr(requester, 'course', ''),
        'birthdate': getattr(requester, 'birthdate', ''),
        'address': getattr(requester, 'address', ''),
        'contact_number': getattr(requester, 'contact_number', ''),

        'credentials': document_types,
        'other': other_val.replace("Others:", "").strip(),
        'purpose': request_obj.purpose,
        'semester': request_obj.semester,
    }

    return render(request, 'includes/view-request.html', context)

@login_required
def check_request_history(request):
    requests = DocumentRequest.objects.filter(requester=request.user).order_by('-created_at')
    has_requests = requests.exists()
    
    if has_requests:
        requests_data = [{
            'id': str(req.id),
            'created_at': req.created_at.strftime('%Y-%m-%d %H:%M'),
            'document_type': req.document_type,
            'status': req.status,
            'is_draft': req.is_draft,
            'purpose': req.purpose,
            'semester': req.semester,
        } for req in requests]
        
        return JsonResponse({
            'has_requests': True,
            'requests': requests_data
        })
    
    print("No requests found")  # Debug print
    return JsonResponse({
        'has_requests': False,
        'requests': []
    })

@login_required
def handle_profile(request):
    context = {
        'profile': request.user,
        'tab': 'profile',
        'edit': request.GET.get('mode') == 'edit'
    }
    return render(request, 'students.html', context)

@login_required
def edit_profile(request):
    if request.method == 'POST':
        # Handle profile update logic here
        return redirect('profile')
    
    context = {
        'profile': request.user,
        'tab': 'profile',
        'edit': True
    }
    return render(request, 'students.html', context)

@login_required
def student_graduation_current(request):
    """Get current student's graduation ID for printing"""
    if request.user.user_type not in ['student', 'alumni']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get the student's graduation form
        graduation = GraduationForm.objects.get(user=request.user)
        
        return JsonResponse({
            'graduation_id': str(graduation.id),
            'user': graduation.user.full_name
        })
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'No graduation form found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def student_enrollment_current(request):
    """Get current student's enrollment ID for printing"""
    if request.user.user_type not in ['student', 'alumni']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get the student's most recent enrollment form
        enrollment = EnrollmentForm.objects.filter(user=request.user).order_by('-created_at').first()
        
        if not enrollment:
            return JsonResponse({'error': 'No enrollment form found'}, status=404)
        
        return JsonResponse({
            'enrollment_id': str(enrollment.id),
            'user': enrollment.user.full_name
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def get_request_data(request, request_id):
    request_obj = get_object_or_404(DocumentRequest, id=request_id)
    user = request_obj.requester
    profile = getattr(user, 'profile', None) or getattr(user, 'alumni_profile', None)

    # Get appropriate fields based on user type
    if profile:
        if user.user_type == 'alumni':
            course = profile.course_graduated if hasattr(profile, 'course_graduated') else ''
        else:
            course = profile.program if hasattr(profile, 'program') else ''
    else:
        course = ''

    name_parts = user.full_name.split()
    first_name = name_parts[0] if len(name_parts) > 0 else ''
    last_name = name_parts[-1] if len(name_parts) > 1 else ''
    middle_name = ' '.join(name_parts[1:-1]) if len(name_parts) > 2 else ''

    context = {
        'first_name': first_name,
        'middle_name': middle_name,
        'last_name': last_name,
        'suffix': '',  # No suffix field in your User or StudentProfile

        'course': course,
        'birthdate': profile.birthdate if profile else '',
        'address': profile.address if profile else '',
        'contact': user.contact_number,

        'document_type': request_obj.document_type.split(','),
        'purpose': request_obj.purpose,
    }

    return JsonResponse(context)

SIGNATORY_ROLES = [
    "Dorm Supervisor",
    "Canteen Concessionaire",
    "Library Director",
    "Scholarship Director",
    "IT Director",
    "Student Affairs",
    "Cashier",
    "Business Manager",
    "Registrar",
    "Academic Dean",
]

@require_POST
@login_required
def submit_clearance_form(request):
    user = request.user
    clearance_type = request.POST.get('clearance-purpose')
    year = request.POST.get('clearance-year')
    academic_year = request.POST.get('clearance-acad-year')
    semester = request.POST.get('clearance-student-semester')
    section = request.POST.get('clearance-section')
    is_draft = request.POST.get('submit') == 'false'

    try:
        form = ClearanceForm.objects.create(
            student=user,
            clearance_type='enrollment' if 'enroll' in clearance_type else 'graduation',
            academic_year=academic_year,
            semester=semester,
            section=section,
            status='pending' if not is_draft else 'draft',
        )

        # Create signatory records for all signatory types
        signatory_types = [
            'dorm_supervisor', 'canteen_concessionaire', 'library_director', 'scholarship_director',
            'it_director', 'student_affairs', 'cashier', 'business_manager', 'registrar', 'academic_dean'
        ]
        
        for signatory_type in signatory_types:
            # Find a signatory of this type (either signatory user or admin)
            signatory_user = User.objects.filter(
                user_type='signatory',
                signatory_profile__signatory_type=signatory_type
            ).first()
            
            if signatory_user:
                role_name = {
                    'dorm_supervisor': 'Dorm Supervisor',
                    'canteen_concessionaire': 'Canteen Concessionaire',
                    'library_director': 'Library Director',
                    'scholarship_director': 'Scholarship Director',
                    'it_director': 'IT Director',
                    'student_affairs': 'Student Affairs',
                    'cashier': 'Cashier',
                    'business_manager': 'Business Manager',
                    'registrar': 'Registrar',
                    'academic_dean': 'Academic Dean'
                }.get(signatory_type, signatory_type.replace('_', ' ').title())
                
                ClearanceSignatory.objects.create(
                    clearance=form,
                    signatory=signatory_user,
                    status='pending',
                    role=role_name,
                    seen_by_signatory=False
                )

        # Also create records for admin users (registrars)
        admin_users = User.objects.filter(user_type='admin')
        for admin_user in admin_users:
            ClearanceSignatory.objects.create(
                clearance=form,
                signatory=admin_user,
                status='pending',
                role='Registrar',
                seen_by_signatory=False
            )

        # Send notifications to all signatories about new form submission (only if not draft)
        if not is_draft:
            try:
                from landing.notification_service import NotificationService
                NotificationService.notify_form_submission(form, 'clearance')
            except Exception as e:
                logger.error(f"Error sending form submission notifications: {str(e)}")

        return JsonResponse({'success': True, 'message': 'Clearance form submitted successfully.'})

    except Exception as e:
        return JsonResponse({'success': False, 'message': f'Error: {str(e)}'})
    
@login_required
def check_clearance_history(request):
    has_clearance = ClearanceForm.objects.filter(student=request.user).exists()
    return JsonResponse({'has_clearance': has_clearance})

@login_required
def view_clearance(request, id):
    user = request.user
    clearance = get_object_or_404(ClearanceForm, id=id, student=user)

    try:
        profile = StudentProfile.objects.get(user=user)
    except StudentProfile.DoesNotExist:
        profile = None

    signatory_roles = {
        'Dorm Supervisor': 'dorm',
        'Canteen Concessionaire': 'canteen',
        'Library Director': 'library',
        'Scholarship Director': 'scholarship',
        'IT Director': 'it',
        'Student Affairs': 'dean',
        'Cashier': 'cashier',
        'Business Manager': 'bm',
        'Registrar': 'registrar',
        'Academic Dean': 'acad',
    }

    context = {
        'user': user,
        'profile': profile,
        'clearance': clearance,
    }

    for prefix in signatory_roles.values():
        context[f"{prefix}_label"] = "Pending"
        context[f"{prefix}_status"] = "bg-warning text-dark"

    signatories = ClearanceSignatory.objects.filter(clearance=clearance)
    for s in signatories:
        role_key = signatory_roles.get(s.role)  # Use s.role instead of s.signatory.role
        if role_key:
            context[f"{role_key}_label"] = s.get_status_display()
            context[f"{role_key}_status"] = {
                'approved': 'bg-success text-white',
                'pending': 'bg-warning text-dark',
                'disapproved': 'bg-danger text-white',
            }.get(s.status, 'bg-secondary')

    return render(request, 'includes/view-clearance.html', context)

@login_required
def get_clearance_data(request, clearance_id):
    try:
        # Ensure students can only view their own clearance forms
        clearance = ClearanceForm.objects.get(id=clearance_id, student=request.user)
        user = clearance.student
        profile = getattr(user, 'profile', None)

        # Map known signatory titles to ID-safe keys used in template
        role_map = {
            "Dorm Supervisor": "dorm_supervisor",
            "Canteen Concessionaire": "canteen_concessionaire",
            "Library Director": "library_director",
            "Scholarship Director": "scholarship_director",
            "IT Director": "it_director",
            "Student Affairs": "student_affairs",
            "Cashier": "cashier",
            "Business Manager": "business_manager",
            "Registrar": "registrar",
            "Academic Dean": "academic_dean",
        }

        # Default all to Pending
        status_map = {
            key: {
                'label': 'Pending',
                'class': 'bg-warning text-dark',
                'date': '',
                'comment': ''
            } for key in role_map.values()
        }

        # Replace statuses based on actual DB data using role field
        signatories = ClearanceSignatory.objects.select_related('signatory').filter(clearance=clearance)
        
        for s in signatories:
            role_key = None
            
            # Map the role field to our template keys with more flexible matching
            if s.role:
                role_lower = s.role.lower().replace('_', ' ').replace('-', ' ').replace('&', 'and')
                for label, key in role_map.items():
                    label_lower = label.lower().replace('_', ' ').replace('-', ' ').replace('&', 'and')
                    if role_lower == label_lower or role_lower in label_lower or label_lower in role_lower:
                        role_key = key
                        break
            
            if role_key:
                # Get the comment - use remarks if available, otherwise comment field
                comment_text = s.remarks or s.comment or ''
                # Format the date
                date_text = s.updated_at.strftime("%m/%d/%Y") if s.updated_at and s.status != 'pending' else ''
                
                # Check if this role already has a status and prioritize non-pending statuses
                current_status = status_map[role_key]['label'].lower()
                new_status = s.status.lower()
                
                # Priority: disapproved > approved > pending
                should_update = False
                if current_status == 'pending':
                    should_update = True  # Always update from pending
                elif current_status == 'approved' and new_status == 'disapproved':
                    should_update = True  # Disapproved overrides approved
                elif current_status == 'disapproved' and new_status != 'pending':
                    should_update = False  # Keep disapproved status unless it's being updated to non-pending
                
                if should_update:
                    status_map[role_key] = {
                        'label': s.get_status_display(),
                        'class': {
                            'approved': 'bg-success text-white',
                            'pending': 'bg-warning text-dark',
                            'disapproved': 'bg-danger text-white',
                        }.get(s.status, 'bg-secondary'),
                        'date': date_text,
                        'comment': comment_text
                    }
         # Get semester display text
        semester_display = dict([
            ('1-2425', 'First Semester'),
            ('2-2425', 'Second Semester'),
            ('', 'None')
        ]).get(clearance.semester, clearance.semester)
        
        # Get appropriate fields based on user type
        if profile:
            if user.user_type == 'alumni':
                id_number = profile.alumni_id if hasattr(profile, 'alumni_id') else ''
                program = profile.course_graduated if hasattr(profile, 'course_graduated') else ''
                year_level = profile.year_graduated if hasattr(profile, 'year_graduated') else ''
            else:
                id_number = profile.student_number if hasattr(profile, 'student_number') else ''
                program = profile.program if hasattr(profile, 'program') else ''
                year_level = profile.year_level if hasattr(profile, 'year_level') else ''
        else:
            id_number = ''
            program = ''
            year_level = ''
        
        # Compose the response
        data = {
            "full_name": user.full_name,
            "student_number": id_number,
            "program": program,
            "year_level": str(year_level) if year_level else '',
            "semester": clearance.semester or '',
            "submitted_at": clearance.submitted_at.strftime("%Y-%m-%d") if clearance.submitted_at else 'Not submitted',
            "purpose": clearance.get_clearance_type_display() if clearance.clearance_type else 'Clearance',
            "academic_year": clearance.academic_year or '',
        }

        for key, val in status_map.items():
            data[f"{key}_label"] = val['label']
            data[f"{key}_class"] = val['class']
            data[f"{key}_date"] = val.get('date', '')
            data[f"{key}_comment"] = val.get('comment', '')

        return JsonResponse(data)

    except ClearanceForm.DoesNotExist:
        return JsonResponse({"error": "Clearance not found"}, status=404)

@login_required
def enrollment_history(request):
    forms = EnrollmentForm.objects.filter(user=request.user).order_by('-created_at')
    return render(request, 'includes/enrollmentformhistory.html', {'enrollment_history': forms})

@require_POST
@login_required
def submit_enrollment_form(request):
    try:
        # Process subjects data
        subjects_data = []
        subject_codes = request.POST.getlist('subject_code[]')
        subject_names = request.POST.getlist('subject_name[]')
        subject_professors = request.POST.getlist('subject_professor[]')
        subject_units = request.POST.getlist('subject_units[]')
        
        # Combine subject data, filtering out empty entries
        # Use the maximum length to ensure all arrays are properly aligned
        max_length = max(len(subject_codes), len(subject_names), len(subject_professors), len(subject_units)) if any([subject_codes, subject_names, subject_professors, subject_units]) else 0
        
        for i in range(max_length):
            code = subject_codes[i].strip() if i < len(subject_codes) else ''
            name = subject_names[i].strip() if i < len(subject_names) else ''
            professor = subject_professors[i].strip() if i < len(subject_professors) else ''
            units = subject_units[i].strip() if i < len(subject_units) else ''
            
            # Only add subjects that have at least a name or code
            if name or code:
                subjects_data.append({
                    'code': code if code else '',
                    'name': name if name else '',
                    'professor': professor if professor else 'TBA',
                    'units': units if units else '0'
                })
        
        # Process semester data - convert "1-2425" to "First Semester"
        # Note: The form field name is still 'request-student-semester' even though ID was changed
        semester_value = request.POST.get('request-student-semester', '')
        semester_display = ''
        if semester_value:
            if semester_value.startswith('1'):
                semester_display = 'First Semester'
            elif semester_value.startswith('2'):
                semester_display = 'Second Semester'
            elif semester_value.startswith('3'):
                semester_display = 'Third Semester'
            elif semester_value.startswith('4'):
                semester_display = 'Fourth Semester'
            else:
                semester_display = semester_value  # fallback to original value
        
        enrollment_form = EnrollmentForm.objects.create(
            user=request.user,
            enrollment_date=request.POST.get('enrollment-date'),
            academic_year=request.POST.get('enrollment-appno'),
            course=request.POST.get('enrollment-course'),
            year=request.POST.get('enrollment-year'),
            section=request.POST.get('enrollment-section', ''),  # Save section from new field
            semester=semester_display,  # Save semester in dedicated field
            subjects=subjects_data,  # Save subjects as JSON
            # status and is_draft will use defaults
        )
        
        # Create signatory records for the enrollment form
        from landing.models import EnrollmentSignatory, User, SignatoryProfile
        from django.db import models
        try:
            # Get all signatory users and create signatory records
            signatory_types = [
                ('academic_dean', 'dean'),  # (signatory_type, role)
                ('business_manager', 'business_manager'),
                ('admin', 'registrar')
            ]
            
            for sig_type, role in signatory_types:
                # Get users of this signatory type
                if sig_type == 'admin':
                    users = User.objects.filter(user_type='admin')
                elif sig_type == 'business_manager':
                    # Get only the first business manager to avoid duplicates
                    user = User.objects.filter(
                        models.Q(user_type='business_manager') |
                        (models.Q(user_type='signatory') & 
                         models.Q(signatory_profile__signatory_type='business_manager'))
                    ).first()
                    users = [user] if user else []
                else:
                    users = User.objects.filter(
                        user_type='signatory',
                        signatory_profile__signatory_type=sig_type
                    )
                
                for signatory_user in users:
                    EnrollmentSignatory.objects.get_or_create(
                        enrollment=enrollment_form,
                        signatory=signatory_user,
                        defaults={'role': role, 'status': 'pending'}
                    )
        except Exception as signatory_error:
            print(f"Signatory creation error: {signatory_error}")
        
        # Notify relevant users about the new enrollment form submission
        try:
            from landing.notification_service import NotificationService
            NotificationService.notify_form_submission(enrollment_form, 'enrollment')
        except Exception as notification_error:
            print(f"Notification error: {notification_error}")  # Log error but don't fail the submission
        
        return JsonResponse({'status': 'success'})
    except Exception as e:
        return JsonResponse({'status': 'error', 'message': str(e)}, status=500)

@require_POST
@login_required
def delete_enrollment(request, form_id):
    try:
        form = EnrollmentForm.objects.get(id=form_id, user=request.user)
        form.delete()
        return JsonResponse({'status': 'success'})
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'status': 'error', 'message': 'Not found'}, status=404)

@login_required
def view_enrollment(request, form_id):
    try:
        # Allow the original user, signatories, and admin users to view the form
        if request.user.user_type in ['admin', 'business_manager'] or (
            request.user.user_type == 'signatory' and 
            hasattr(request.user, 'signatory_profile')
        ):
            # Admin, business managers, and signatories can view any enrollment form
            form = EnrollmentForm.objects.get(id=form_id)
        else:
            # Regular users can only view their own forms
            form = EnrollmentForm.objects.get(id=form_id, user=request.user)
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment form not found or you do not have permission to view it'}, status=404)
    user = form.user
    profile = getattr(user, 'profile', None) or getattr(user, 'alumni_profile', None)
    
    # Get appropriate fields based on user type
    if profile:
        if user.user_type == 'alumni':
            id_number = profile.alumni_id if hasattr(profile, 'alumni_id') else ''
            program = profile.course_graduated if hasattr(profile, 'course_graduated') else ''
            year_level = profile.year_graduated if hasattr(profile, 'year_graduated') else ''
        else:
            id_number = profile.student_number if hasattr(profile, 'student_number') else ''
            program = profile.program if hasattr(profile, 'program') else ''
            year_level = profile.year_level if hasattr(profile, 'year_level') else ''
    else:
        id_number = ''
        program = ''
        year_level = ''
    
    data = {
        'enrollment_date': form.enrollment_date,
        'academic_year': form.academic_year,
        'course': form.course,
        'year': form.year,
        'section': form.section or '',  # Student's section (A, B, C, etc.)
        'semester': form.semester or '',  # Semester (First Semester, Second Semester)
        'status': form.status,
        'created_at': form.created_at.strftime('%Y-%m-%d %H:%M'),
        'full_name': user.full_name,
        'student_number': id_number,
        'program': program,
        'year_level': year_level,
        'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile and profile.birthdate else '',
        'contact_number': user.contact_number or '',
        'email': user.email or '',
        'address': profile.address if profile else '',
    }
    
    # Add signatory statuses
    signatory_roles = ['dean', 'business_manager', 'registrar']
    signatory_statuses = {}
    
    signatories = EnrollmentSignatory.objects.select_related('signatory').filter(enrollment=form)
    for signatory in signatories:
        if signatory.role in signatory_roles:
            signatory_statuses[signatory.role] = {
                'status': signatory.status,
                'signatory_name': signatory.signatory.full_name,
                'updated_at': signatory.updated_at.strftime('%Y-%m-%d %H:%M') if signatory.updated_at else '',
                'remarks': signatory.remarks or signatory.comment or ''
            }
    
    # Ensure all expected roles are present with default values
    for role in signatory_roles:
        if role not in signatory_statuses:
            signatory_statuses[role] = {
                'status': 'pending',
                'signatory_name': '',
                'updated_at': '',
                'remarks': ''
            }
    
    data['signatories'] = signatory_statuses
    
    # Add subjects data
    subjects_data = []
    if form.subjects:
        try:
            subjects = form.subjects if isinstance(form.subjects, list) else []
            for subject in subjects:
                if isinstance(subject, dict):
                    subjects_data.append({
                        'code': subject.get('code', ''),
                        'name': subject.get('name', ''),
                        'professor': subject.get('professor', 'TBA'),
                        'units': subject.get('units', '0')
                    })
                else:
                    # Handle legacy data that might not be in dict format
                    print(f"Warning: Unexpected subject data format: {subject}")
        except (TypeError, AttributeError) as e:
            print(f"Error parsing subjects data: {e}")
            subjects_data = []
    
    data['subjects'] = subjects_data
    return JsonResponse(data)

@require_POST
@login_required
def submit_graduation_form(request):
    subjects = []
    course_nos = request.POST.getlist('subject_course_no[]')
    titles = request.POST.getlist('subject_title[]')
    units = request.POST.getlist('subject_units[]')
    remarks = request.POST.getlist('subject_remarks[]')
    for i in range(len(course_nos)):
        if course_nos[i] or titles[i] or units[i] or remarks[i]:
            subjects.append({
                'course_no': course_nos[i],
                'title': titles[i],
                'units': units[i],
                'remarks': remarks[i],
            })
    confirmed = request.POST.get('confirmed') == '1'
    present_address = request.POST.get('grad-present-address', '')
    permanent_address = request.POST.get('grad-permanent-address', '')
    place_of_birth = request.POST.get('grad-placeofbirth', '')
    
    # Generate unique application number in format GF-XXXXXX
    import random
    while True:
        app_number = f"GF-{random.randint(100000, 999999)}"
        if not GraduationForm.objects.filter(grad_appno=app_number).exists():
            break
    
    graduation_form = GraduationForm.objects.create(
        user=request.user,
        first_name=request.POST.get('grad-firstname', ''),
        middle_name=request.POST.get('grad-middlename', ''),
        last_name=request.POST.get('grad-lastname', ''),
        grad_date=request.POST.get('grad-date'),
        grad_appno=app_number,
        place_of_birth=place_of_birth,
        major=request.POST.get('grad-major'),
        thesis_title=request.POST.get('grad-thesis-title'),
        subjects=subjects,
        confirmed=confirmed,
        present_address=present_address,
        permanent_address=permanent_address,
    )
    
    # Create signatory records for the graduation form
    from landing.models import GraduationSignatory, User, SignatoryProfile
    from django.db import models
    try:
        # Get all signatory users and create signatory records
        signatory_types = [
            ('academic_dean', 'dean'),  # (signatory_type, role)
            ('business_manager', 'business_manager'),
            ('admin', 'registrar'),
            ('president', 'president')
        ]
        
        for sig_type, role in signatory_types:
            # Get users of this signatory type
            if sig_type == 'admin':
                users = User.objects.filter(user_type='admin')
            elif sig_type == 'business_manager':
                # Get only the first business manager to avoid duplicates
                user = User.objects.filter(
                    models.Q(user_type='business_manager') |
                    (models.Q(user_type='signatory') & 
                     models.Q(signatory_profile__signatory_type='business_manager'))
                ).first()
                users = [user] if user else []
            elif sig_type == 'president':
                # Get president users
                users = User.objects.filter(
                    models.Q(user_type='president') |
                    (models.Q(user_type='signatory') & 
                     models.Q(signatory_profile__signatory_type='president'))
                )
            else:
                users = User.objects.filter(
                    user_type='signatory',
                    signatory_profile__signatory_type=sig_type
                )
            
            for signatory_user in users:
                GraduationSignatory.objects.get_or_create(
                    graduation=graduation_form,
                    signatory=signatory_user,
                    defaults={'role': role, 'status': 'pending'}
                )
    except Exception as signatory_error:
        print(f"Signatory creation error: {signatory_error}")
    
    # Notify relevant users about the new graduation form submission
    try:
        from landing.notification_service import NotificationService
        NotificationService.notify_form_submission(graduation_form, 'graduation')
    except Exception as notification_error:
        print(f"Notification error: {notification_error}")  # Log error but don't fail the submission
    
    return JsonResponse({'status': 'success'})

@login_required
def view_graduation(request, form_id):
    try:
        # Allow the original user, signatories, and admin users to view the form
        if request.user.user_type in ['admin', 'business_manager'] or (
            request.user.user_type == 'signatory' and 
            hasattr(request.user, 'signatory_profile')
        ):
            # Admin, business managers, and signatories can view any graduation form
            form = GraduationForm.objects.get(id=form_id)
        else:
            # Regular users can only view their own forms
            form = GraduationForm.objects.get(id=form_id, user=request.user)
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found or you do not have permission to view it'}, status=404)
    user = form.user
    profile = getattr(user, 'profile', None) or getattr(user, 'alumni_profile', None)
    
    # Get appropriate course field based on user type
    if profile:
        if user.user_type == 'alumni':
            course = profile.course_graduated if hasattr(profile, 'course_graduated') else ''
        else:
            course = profile.program if hasattr(profile, 'program') else ''
    else:
        course = ''
    
    data = {
        'grad_date': form.grad_date.strftime('%Y-%m-%d'),
        'grad_appno': form.grad_appno,
        'full_name': user.full_name,
        'gender': profile.gender if profile else '',
        'phone': user.contact_number or '',
        'email': user.email or '',
        'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile and profile.birthdate else '',
        'place_of_birth': form.place_of_birth,
        'course': course,
        'major': form.major,
        'confirmation_checked': form.confirmed,  # Use the correct field name
        'thesis_title': form.thesis_title,
        'status': form.status,
        'created_at': form.created_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p'),
        'subjects': form.subjects or [],
        'present_address': form.present_address,
        'permanent_address': form.permanent_address,
        'graduation_year': form.grad_date.year if form.grad_date else '',
    }
    
    # Add signatory statuses
    signatory_roles = ['dean', 'business_manager', 'registrar', 'president']
    signatory_statuses = {}
    
    signatories = GraduationSignatory.objects.select_related('signatory').filter(graduation=form)
    for signatory in signatories:
        if signatory.role in signatory_roles:
            signatory_statuses[signatory.role] = {
                'status': signatory.status,
                'signatory_name': signatory.signatory.full_name,
                'updated_at': signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if signatory.updated_at else '',
                'remarks': signatory.remarks or signatory.comment or ''
            }
    
    # Ensure all expected roles are present with default values
    for role in signatory_roles:
        if role not in signatory_statuses:
            signatory_statuses[role] = {
                'status': 'pending',
                'signatory_name': '',
                'updated_at': '',
                'remarks': ''
            }
    
    data['signatories'] = signatory_statuses
    return JsonResponse(data)

# ========================================
# REGISTRAR VIEWS
# ========================================

@login_required
def registrar_dashboard(request):
    """Render the registrar dashboard page"""
    # Check if user is admin or registrar
    if request.user.user_type not in ['admin', 'registrar']:
        messages.error(request, "Access denied. You don't have permission to view this page.")
        return redirect('login')
    
    from datetime import datetime, timezone as dt_timezone, timedelta
    import json
    
    # Get current date and calculate date ranges
    today = timezone.now().date()
    yesterday = today - timedelta(days=1)
    last_week = today - timedelta(days=7)
    last_month = today - timedelta(days=30)
    
    # Basic statistics - Fixed logic for accurate counts
    total_clearance_requests = ClearanceForm.objects.count()
    
    # For clearance forms, check system-wide status (requires all 10 signatory types)
    pending_clearance_count = 0
    for clearance in ClearanceForm.objects.all():
        # Get all signatory records for this clearance
        all_signatories = clearance.signatories.all()
        
        # Count how many have approved
        approved_count = all_signatories.filter(status='approved').count()
        
        # A clearance is pending if it doesn't have all 10 signatory types approved
        # (The system requires 10 different signatory types to fully approve a clearance)
        if approved_count < 10:
            pending_clearance_count += 1
    
    pending_clearance_requests = pending_clearance_count
    
    total_enrollment_requests = EnrollmentForm.objects.count()
    
    # For enrollment forms, check system-wide status
    pending_enrollment_count = 0
    for enrollment in EnrollmentForm.objects.all():
        # Get signatory statuses
        dean_status = 'pending'
        business_status = 'pending'
        registrar_status = 'pending'
        
        signatories = enrollment.signatories.all()
        for signatory in signatories:
            if signatory.role == 'dean':
                dean_status = signatory.status
            elif signatory.role == 'business_manager':
                business_status = signatory.status
            elif signatory.role == 'registrar':
                registrar_status = signatory.status
        
        # Form is pending if ANY required signatory hasn't approved
        if not all(status == 'approved' for status in [dean_status, business_status, registrar_status]):
            pending_enrollment_count += 1
    
    pending_enrollment_requests = pending_enrollment_count
    
    # For graduation forms, check system-wide status
    total_graduation_requests = GraduationForm.objects.count()
    
    # Count graduation forms that are actually pending (not all system signatories approved)
    pending_graduation_count = 0
    for graduation in GraduationForm.objects.all():
        # Get signatory statuses
        dean_status = 'pending'
        business_status = 'pending'
        registrar_status = 'pending'
        president_status = 'pending'
        
        signatories = graduation.signatories.all()
        for signatory in signatories:
            if signatory.role == 'dean':
                dean_status = signatory.status
            elif signatory.role == 'business_manager':
                business_status = signatory.status
            elif signatory.role == 'registrar':
                registrar_status = signatory.status
            elif signatory.role == 'president':
                president_status = signatory.status
        
        # Form is pending if ANY required signatory hasn't approved
        if not all(status == 'approved' for status in [dean_status, business_status, registrar_status, president_status]):
            pending_graduation_count += 1
    
    pending_graduation_requests = pending_graduation_count
    
    total_document_requests = DocumentRequest.objects.count()
    pending_document_requests = DocumentRequest.objects.filter(status='pending').count()
    
    # Pending signatures - Only count signatories that are actually pending for approval
    # This should be signatories assigned to clearance forms that are still pending
    pending_signatures_count = ClearanceSignatory.objects.filter(
        status='pending',
        clearance__status='pending'  # Only count if the clearance form is still pending
    ).count()
    
    new_signatures_today = ClearanceSignatory.objects.filter(
        updated_at__date=today
    ).count()
    
    # Disapproved forms
    disapproved_clearance = ClearanceForm.objects.filter(status='disapproved').count()
    disapproved_enrollment = EnrollmentForm.objects.filter(status='rejected').count()
    disapproved_graduation = GraduationForm.objects.filter(status='rejected').count()
    disapproved_documents = DocumentRequest.objects.filter(status='rejected').count()
    disapproved_forms_count = disapproved_clearance + disapproved_enrollment + disapproved_graduation + disapproved_documents
    
    recently_disapproved = ClearanceForm.objects.filter(
        status='disapproved', 
        submitted_at__date__gte=last_week
    ).count() + EnrollmentForm.objects.filter(
        status='rejected', 
        created_at__date__gte=last_week
    ).count() + GraduationForm.objects.filter(
        status='rejected', 
        created_at__date__gte=last_week
    ).count()
    
    # Generate chart data for the last 7 days
    chart_dates = []
    accomplishment_data = []
    visitors_data = []
    documents_data = []
    
    for i in range(7):
        date = today - timedelta(days=6-i)
        chart_dates.append(date.strftime('%b %d'))
        
        # Accomplishment data (completed forms)
        daily_clearance = ClearanceForm.objects.filter(
            status='approved', 
            submitted_at__date=date
        ).count()
        daily_enrollment = EnrollmentForm.objects.filter(
            status='approved', 
            created_at__date=date
        ).count()
        daily_graduation = GraduationForm.objects.filter(
            status='approved', 
            created_at__date=date
        ).count()
        daily_documents = DocumentRequest.objects.filter(
            status='released', 
            created_at__date=date
        ).count()
        
        accomplishment_data.append(daily_clearance + daily_enrollment + daily_graduation + daily_documents)
        
        # Visitors data (new form submissions)
        daily_visitors = (
            ClearanceForm.objects.filter(submitted_at__date=date).count() +
            EnrollmentForm.objects.filter(created_at__date=date).count() +
            GraduationForm.objects.filter(created_at__date=date).count() +
            DocumentRequest.objects.filter(created_at__date=date).count()
        )
        visitors_data.append(daily_visitors)
        
        # Documents released
        documents_data.append(daily_documents)
    
    # Prepare chart data for JavaScript
    accomplishment_chart_data = json.dumps({
        'categories': chart_dates,
        'series': [{'name': 'Accomplishment', 'data': accomplishment_data}]
    })
    
    visitors_chart_data = json.dumps({
        'categories': chart_dates,
        'series': [{'name': 'Visitors', 'data': visitors_data}]
    })
    
    documents_chart_data = json.dumps({
        'categories': chart_dates,
        'series': [{'name': 'Documents Released', 'data': documents_data}]
    })
    
    # Recent activity data
    recent_clearance = ClearanceForm.objects.order_by('-submitted_at')[:5]
    recent_enrollment = EnrollmentForm.objects.order_by('-created_at')[:5]
    recent_graduation = GraduationForm.objects.order_by('-created_at')[:5]
    recent_documents = DocumentRequest.objects.order_by('-created_at')[:5]
    
    recent_activity = []
    
    for clearance in recent_clearance:
        recent_activity.append({
            'type': 'Clearance',
            'user': clearance.student.full_name,
            'status': clearance.status,
            'date': clearance.submitted_at.strftime('%Y-%m-%d %H:%M'),
            'color': 'success' if clearance.status == 'approved' else 'warning' if clearance.status == 'pending' else 'danger'
        })
    
    for enrollment in recent_enrollment:
        recent_activity.append({
            'type': 'Enrollment',
            'user': enrollment.user.full_name,
            'status': enrollment.status,
            'date': enrollment.created_at.strftime('%Y-%m-%d %H:%M'),
            'color': 'success' if enrollment.status == 'approved' else 'warning' if enrollment.status == 'pending' else 'danger'
        })
    
    for graduation in recent_graduation:
        recent_activity.append({
            'type': 'Graduation',
            'user': graduation.user.full_name,
            'status': graduation.status,
            'date': graduation.created_at.strftime('%Y-%m-%d %H:%M'),
            'color': 'success' if graduation.status == 'approved' else 'warning' if graduation.status == 'pending' else 'danger'
        })
    
    for document in recent_documents:
        recent_activity.append({
            'type': 'Document Request',
            'user': document.requester.full_name,
            'status': document.status,
            'date': document.created_at.strftime('%Y-%m-%d %H:%M'),
            'color': 'success' if document.status == 'released' else 'warning' if document.status == 'pending' else 'danger'
        })
    
    # Sort by date and take top 10
    recent_activity.sort(key=lambda x: x['date'], reverse=True)
    recent_activity = recent_activity[:10]
    
    # Get upcoming calendar events (next 7 days)
    from landing.models import CalendarEvent
    
    upcoming_events = []
    
    # Get events from the next 7 days
    next_week = today + timedelta(days=7)
    calendar_events = CalendarEvent.objects.filter(
        start_date__gte=today,
        start_date__lte=next_week
    ).order_by('start_date', 'start_time')[:10]
    
    for event in calendar_events:
        upcoming_events.append({
            'time': event.display_time,
            'title': event.title,
            'color': event.color,
            'date': event.start_date.strftime('%Y-%m-%d'),
            'is_holiday': event.is_holiday
        })
    
    # If no upcoming events found, upcoming_events will remain empty list
    # This allows the template to show "No upcoming events" message
    
    context = {
        'total_clearance_requests': total_clearance_requests,
        'pending_clearance_requests': pending_clearance_requests,
        'total_enrollment_requests': total_enrollment_requests,
        'pending_enrollment_requests': pending_enrollment_requests,
        'total_graduation_requests': total_graduation_requests,
        'pending_graduation_requests': pending_graduation_requests,
        'total_document_requests': total_document_requests,
        'pending_document_requests': pending_document_requests,
        'pending_signatures_count': pending_signatures_count,
        'new_signatures_today': new_signatures_today,
        'disapproved_forms_count': disapproved_forms_count,
        'recently_disapproved': recently_disapproved,
        'accomplishment_chart_data': accomplishment_chart_data,
        'visitors_chart_data': visitors_chart_data,
        'documents_chart_data': documents_chart_data,
        'upcoming_events': upcoming_events,
        'recent_activity': json.dumps(recent_activity),
        'user': request.user, # Pass the user object for full_name
    }
    return render(request, 'REGISTRARDASHBOARD.html', context)

@login_required
def registrar_clearance(request):
    """Registrar clearance management view"""
    if request.user.user_type not in ['admin', 'registrar']:
        return redirect('login')
    
    # Get clearance forms with related data
    clearance_forms = ClearanceForm.objects.select_related('student', 'student__profile').prefetch_related('signatories').all()
    
    # Initialize signatories for forms that don't have them
    for form in clearance_forms:
        if not form.signatories.exists():
            # Create default signatories for this form
            from landing.models import ClearanceSignatory
            # You might want to get actual signatory users from the database
            # For now, we'll create placeholder signatories
            signatory_roles = ['dorm_supervisor', 'canteen_concessionaire', 'library_director', 
                             'scholarship_director', 'it_director', 'student_affairs', 
                             'cashier', 'business_manager', 'registrar', 'academic_dean']
            
            for role in signatory_roles:
                # For registrar role, use the current user (who should be admin/registrar)
                if role == 'registrar':
                    signatory_user = request.user
                else:
                    # For other roles, use the current user as placeholder
                    signatory_user = request.user
                
                ClearanceSignatory.objects.create(
                    clearance=form,
                    signatory=signatory_user,
                    role=role,
                    status='pending'
                )
    
    # Get unique values for filters from StudentProfile
    courses = clearance_forms.values_list('student__profile__program', flat=True).distinct()
    years = clearance_forms.values_list('student__profile__year_level', flat=True).distinct()
    # Get sections from EnrollmentForm model
    sections = EnrollmentForm.objects.values_list('section', flat=True).distinct()
    
    context = {
        'clearance_forms': clearance_forms,
        'courses': courses,
        'years': years,
        'sections': sections,
    }
    
    return render(request, 'REGISTRARCLEARANCE.html', context)

@login_required
def clearance_data_api(request):
    """API endpoint to get clearance data for AJAX requests"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get filter parameters
        course_filter = request.GET.get('course')
        year_filter = request.GET.get('year')
        section_filter = request.GET.get('section')
        status_filter = request.GET.get('status')
        search_query = request.GET.get('search')
        
        # Build query
        clearance_forms = ClearanceForm.objects.select_related('student', 'student__profile')
        
        if course_filter:
            clearance_forms = clearance_forms.filter(student__profile__program=course_filter)
        if year_filter:
            clearance_forms = clearance_forms.filter(student__profile__year_level=year_filter)
        if section_filter:
            # Filter by section from EnrollmentForm
            clearance_forms = clearance_forms.filter(student__enrollment_forms__section=section_filter).distinct()
        if status_filter:
            # Handle the new status logic using ClearanceSignatory model
            from landing.models import ClearanceSignatory
            if status_filter == 'completed':
                # Filter for forms where all 10 signatory types are approved
                completed_forms = []
                required_signatory_types = {
                    'dorm_supervisor', 'canteen_concessionaire', 'library_director',
                    'scholarship_director', 'it_director', 'student_affairs',
                    'cashier', 'business_manager', 'registrar', 'academic_dean'
                }
                
                for form in clearance_forms:
                    all_signatories = ClearanceSignatory.objects.filter(clearance=form)
                    approved_signatory_types = set()
                    
                    for sig in all_signatories:
                        if sig.status == 'approved':
                            sig_profile = getattr(sig.signatory, 'signatory_profile', None)
                            if sig_profile:
                                approved_signatory_types.add(sig_profile.signatory_type)
                    
                    if required_signatory_types.issubset(approved_signatory_types):
                        completed_forms.append(form.id)
                clearance_forms = clearance_forms.filter(id__in=completed_forms)
            elif status_filter == 'pending':
                # Filter for forms where not all signatories are approved
                pending_forms = []
                for form in clearance_forms:
                    all_signatories = ClearanceSignatory.objects.filter(clearance=form)
                    if not all_signatories.exists() or not all(s.status == 'approved' for s in all_signatories):
                        pending_forms.append(form.id)
                clearance_forms = clearance_forms.filter(id__in=pending_forms)
        if search_query:
            clearance_forms = clearance_forms.filter(
                Q(student__full_name__icontains=search_query) |
                Q(student__profile__student_number__icontains=search_query)
            )
        
        # Order by submission date (most recent first)
        clearance_forms = clearance_forms.order_by('-submitted_at')
        
        # Prepare data for frontend
        clearance_data = []
        for form in clearance_forms:
            # Get signatory statuses using ClearanceSignatory model
            from landing.models import ClearanceSignatory
            signatories = {}
            clearance_signatories = ClearanceSignatory.objects.filter(clearance=form).select_related('signatory', 'signatory__signatory_profile')
            
            print(f"Processing clearance {form.id} with {clearance_signatories.count()} signatories")
            
            # Group signatories by type to handle duplicates
            signatory_groups = {}
            for clearance_signatory in clearance_signatories:
                # Get signatory type from profile
                try:
                    signatory_type = clearance_signatory.signatory.signatory_profile.signatory_type
                    print(f"  User {clearance_signatory.signatory.username} has signatory_type: {signatory_type}")
                except:
                    # Fallback for users without profile
                    if clearance_signatory.signatory.user_type == 'admin':
                        signatory_type = 'registrar'
                        print(f"  User {clearance_signatory.signatory.username} is admin, using signatory_type: {signatory_type}")
                    else:
                        signatory_type = 'unknown'
                        print(f"  User {clearance_signatory.signatory.username} has unknown type")
                
                # Group by signatory type
                if signatory_type not in signatory_groups:
                    signatory_groups[signatory_type] = []
                signatory_groups[signatory_type].append(clearance_signatory)
            
            # Process each group to select the best signatory
            for signatory_type, signatory_list in signatory_groups.items():
                if len(signatory_list) == 1:
                    # Only one signatory of this type
                    clearance_signatory = signatory_list[0]
                    signatories[signatory_type] = {
                        'status': clearance_signatory.status,
                        'timestamp': clearance_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if clearance_signatory.updated_at else None,
                        'comment': clearance_signatory.remarks or clearance_signatory.comment
                    }
                    print(f"  Added single signatory data for {signatory_type}: {clearance_signatory.status}")
                else:
                    # Multiple signatories of the same type - choose the best one
                    print(f"  Multiple signatories for {signatory_type}: {len(signatory_list)}")
                    
                    # Priority: approved > disapproved > pending
                    # Also prefer the current user if they're admin/registrar
                    best_signatory = None
                    current_user = request.user
                    
                    # First, try to find the current user's signatory
                    for signatory in signatory_list:
                        if signatory.signatory == current_user:
                            best_signatory = signatory
                            print(f"    Found current user's signatory: {signatory.status}")
                            break
                    
                    # If not found, choose by status priority
                    if not best_signatory:
                        for signatory in signatory_list:
                            if signatory.status == 'approved':
                                best_signatory = signatory
                                print(f"    Found approved signatory: {signatory.signatory.username}")
                                break
                            elif signatory.status == 'disapproved' and (not best_signatory or best_signatory.status == 'pending'):
                                best_signatory = signatory
                                print(f"    Found disapproved signatory: {signatory.signatory.username}")
                    
                    # If still not found, use the first one
                    if not best_signatory:
                        best_signatory = signatory_list[0]
                        print(f"    Using first signatory: {best_signatory.signatory.username} ({best_signatory.status})")
                    
                    signatories[signatory_type] = {
                        'status': best_signatory.status,
                        'timestamp': best_signatory.updated_at.strftime('%Y-%m-%d %H:%M') if best_signatory.updated_at else None,
                        'comment': best_signatory.remarks or best_signatory.comment
                    }
                    print(f"  Added best signatory data for {signatory_type}: {best_signatory.status}")
            
            print(f"  Final signatories for clearance {form.id}: {signatories}")
            
            # Get section from EnrollmentForm
            enrollment_form = form.student.enrollment_forms.first()
            section = enrollment_form.section if enrollment_form else ''
            
            # Determine overall status based on all 10 signatory types being approved
            required_signatory_types = {
                'dorm_supervisor', 'canteen_concessionaire', 'library_director',
                'scholarship_director', 'it_director', 'student_affairs',
                'cashier', 'business_manager', 'registrar', 'academic_dean'
            }
            
            approved_signatory_types = set()
            for signatory_type, signatory_data in signatories.items():
                if signatory_data.get('status') == 'approved':
                    approved_signatory_types.add(signatory_type)
            
            if required_signatory_types.issubset(approved_signatory_types):
                overall_status = 'completed'
            else:
                overall_status = 'pending'
            
            clearance_data.append({
                'id': str(form.id),
                'student_id': str(form.student.id),
                'student_name': form.student.full_name,
                'course': form.student.profile.program if hasattr(form.student, 'profile') and form.student.profile else '',
                'year': form.student.profile.year_level if hasattr(form.student, 'profile') and form.student.profile else '',
                'section': section,
                'id_number': form.student.profile.student_number if hasattr(form.student, 'profile') and form.student.profile else '',
                'date_submitted': form.submitted_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if form.submitted_at else None,
                'status': overall_status,
                'signatories': signatories
            })
        
        return JsonResponse({'clearance_data': clearance_data})
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def approve_clearance(request):
    """Approve clearance form"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            clearance_id = data.get('clearance_id')
            pin = data.get('pin')
            comment = data.get('comment', '')
            
            # Verify PIN against RegistrarProfile
            from landing.models import RegistrarProfile
            reg_profile = getattr(request.user, 'registrar_profile', None)
            if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            # Get clearance form
            clearance_form = ClearanceForm.objects.get(id=clearance_id)
            
            # Update registrar signatory using the new system
            from landing.models import ClearanceSignatory
            
            print(f"Registrar approval: User {request.user.username}, User type: {request.user.user_type}")
            
            # Get user's signatory type and role
            try:
                signatory_profile = request.user.signatory_profile
                signatory_type = signatory_profile.signatory_type
                role_name = {
                    'dorm_supervisor': 'Dorm Supervisor',
                    'canteen_concessionaire': 'Canteen Concessionaire',
                    'library_director': 'Library Director',
                    'scholarship_director': 'Scholarship Director',
                    'it_director': 'IT Director',
                    'student_affairs': 'Student Affairs',
                    'cashier': 'Cashier',
                    'business_manager': 'Business Manager',
                    'registrar': 'Registrar',
                    'academic_dean': 'Academic Dean'
                }.get(signatory_type, 'Registrar')
                print(f"User signatory type: {signatory_type}, Role: {role_name}")
            except:
                print("User has no signatory profile, defaulting to registrar")
                signatory_type = 'registrar'
                role_name = 'Registrar'
            
            # Get or create the clearance signatory record
            registrar_signatory, created = ClearanceSignatory.objects.get_or_create(
                clearance=clearance_form,
                signatory=request.user,
                defaults={
                    'status': 'pending',
                    'role': role_name,
                    'seen_by_signatory': True
                }
            )
            
            # Update role if it was created with wrong role
            if not created and registrar_signatory.role != role_name:
                registrar_signatory.role = role_name
            
            print(f"Signatory record: {'Created' if created else 'Found existing'} - ID: {registrar_signatory.id}")
            
            # Check if this specific signatory has already approved
            if registrar_signatory.status == 'approved':
                return JsonResponse({'error': 'You have already approved this clearance'}, status=400)
            
            # Update the status
            registrar_signatory.status = 'approved'
            registrar_signatory.remarks = comment
            registrar_signatory.ip_address = get_client_ip(request)
            registrar_signatory.save()
            
            print(f"Updated signatory record status to: {registrar_signatory.status}")
            print(f"Signatory record details: ID={registrar_signatory.id}, User={registrar_signatory.signatory.username}, Role={registrar_signatory.role}")
            
            # Send approval notification to student
            try:
                from landing.notification_service import NotificationService
                NotificationService.notify_form_approval(
                    form_instance=clearance_form,
                    form_type='clearance',
                    signatory_user=request.user,
                    remarks=comment or ''
                )
            except Exception as e:
                print(f"Error sending approval notification: {e}")
            
            # Check if all signatories approved
            all_signatories = ClearanceSignatory.objects.filter(clearance=clearance_form)
            all_approved = all_signatories.exists() and all(s.status == 'approved' for s in all_signatories)
            if all_approved:
                clearance_form.status = 'approved'
                clearance_form.save()
            
            return JsonResponse({
                'success': True, 
                'message': 'Clearance approved successfully',
                'clearance_id': clearance_id,
                'registrar_updated': registrar_signatory is not None
            })
            
        except ClearanceForm.DoesNotExist:
            return JsonResponse({'error': 'Clearance form not found'}, status=404)
        except Exception as e:
            print(f"Error in approve_clearance: {e}")
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def disapprove_clearance(request):
    """Disapprove clearance form"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            clearance_id = data.get('clearance_id')
            pin = data.get('pin')
            reasons = data.get('reasons', [])
            comment = data.get('comment', '')
            appointment_date = data.get('appointment_date')
            
            # Verify PIN against RegistrarProfile
            from landing.models import RegistrarProfile
            reg_profile = getattr(request.user, 'registrar_profile', None)
            if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            if not reasons:
                return JsonResponse({'error': 'Please select at least one reason'}, status=400)
            
            # Get clearance form
            clearance_form = ClearanceForm.objects.get(id=clearance_id)
            
            # Update registrar signatory using the new system
            from landing.models import ClearanceSignatory
            
            # Get user's signatory type and role
            try:
                signatory_profile = request.user.signatory_profile
                signatory_type = signatory_profile.signatory_type
                role_name = {
                    'dorm_supervisor': 'Dorm Supervisor',
                    'canteen_concessionaire': 'Canteen Concessionaire',
                    'library_director': 'Library Director',
                    'scholarship_director': 'Scholarship Director',
                    'it_director': 'IT Director',
                    'student_affairs': 'Student Affairs',
                    'cashier': 'Cashier',
                    'business_manager': 'Business Manager',
                    'registrar': 'Registrar',
                    'academic_dean': 'Academic Dean'
                }.get(signatory_type, 'Registrar')
            except:
                signatory_type = 'registrar'
                role_name = 'Registrar'
            
            # Get or create the clearance signatory record
            registrar_signatory, created = ClearanceSignatory.objects.get_or_create(
                clearance=clearance_form,
                signatory=request.user,
                defaults={
                    'status': 'pending',
                    'role': role_name,
                    'seen_by_signatory': True
                }
            )
            
            # Update role if it was created with wrong role
            if not created and registrar_signatory.role != role_name:
                registrar_signatory.role = role_name
            
            print(f"Registrar disapproval: {'Created' if created else 'Found existing'} record - ID: {registrar_signatory.id}")
            
            # Check if this specific signatory has already disapproved
            if registrar_signatory.status == 'disapproved':
                return JsonResponse({'error': 'You have already disapproved this clearance'}, status=400)
            
            # Update the status
            registrar_signatory.status = 'disapproved'
            registrar_signatory.remarks = f"Reasons: {', '.join(reasons)}. {comment}"
            registrar_signatory.ip_address = get_client_ip(request)
            registrar_signatory.save()
            
            print(f"Updated signatory record status to: {registrar_signatory.status}")
            print(f"Signatory record details: ID={registrar_signatory.id}, User={registrar_signatory.signatory.username}, Role={registrar_signatory.role}")
            
            # Update clearance form status to pending (since it's disapproved but can be edited)
            clearance_form.status = 'pending'
            clearance_form.save()
            
            # Send notification to student
            try:
                from landing.notification_service import NotificationService
                notification_service = NotificationService()
                notification_service.handle_form_disapproval(
                    form=clearance_form,
                    form_type='clearance',
                    disapproval_reasons=reasons,
                    settlement_instructions=comment,
                    appointment_date=appointment_date
                )
            except Exception as e:
                print(f"Error sending disapproval notification: {e}")
                import traceback
                print(f"Full traceback: {traceback.format_exc()}")
            
            # Create appointment if date provided
            if appointment_date:
                # You can create an appointment record here
                pass
            
            return JsonResponse({'success': True, 'message': 'Clearance disapproved successfully'})
            
        except ClearanceForm.DoesNotExist:
            return JsonResponse({'error': 'Clearance form not found'}, status=404)
        except Exception as e:
            print(f"Error in disapprove_clearance: {e}")
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def print_clearance(request, clearance_id):
    """Print single clearance form"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        clearance_form = ClearanceForm.objects.select_related('student', 'student__profile').prefetch_related('signatories').get(id=clearance_id)
        
        # Log the print action
        AuditLog.objects.create(
            user=request.user,
            action_type='clearance_print',
            description=f'Printed clearance form {clearance_id} for {clearance_form.student.full_name} [IP: {get_client_ip(request)}]'
        )
        
        # Get enrollment form for section
        enrollment_form = clearance_form.student.enrollment_forms.first()
        
        context = {
            'clearance': clearance_form,
            'student': clearance_form.student,
            'profile': clearance_form.student.profile,
            'enrollment': enrollment_form,
            'signatories': clearance_form.signatories.all(),
        }
        
        return render(request, 'pdf/pdf-clearance.html', context)
        
    except ClearanceForm.DoesNotExist:
        return JsonResponse({'error': 'Clearance form not found'}, status=404)

@login_required
def bulk_print_clearance(request):
    """Print multiple clearance forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    clearance_ids = request.GET.get('ids', '').split(',')
    clearance_forms = []
    
    for clearance_id in clearance_ids:
        try:
            clearance_form = ClearanceForm.objects.select_related('student', 'student__profile').prefetch_related('signatories').get(id=clearance_id)
            enrollment_form = clearance_form.student.enrollment_forms.first()
            
            # Log each bulk print action
            AuditLog.objects.create(
                user=request.user,
                action_type='clearance_bulk_print',
                description=f'Bulk printed clearance form {clearance_id} for {clearance_form.student.full_name} [IP: {get_client_ip(request)}]'
            )
            
            clearance_forms.append({
                'clearance': clearance_form,
                'student': clearance_form.student,
                'profile': clearance_form.student.profile,
                'enrollment': enrollment_form,
                'signatories': clearance_form.signatories.all(),
            })
        except ClearanceForm.DoesNotExist:
            continue
    
    context = {
        'clearance_forms': clearance_forms,
    }
    
    return render(request, 'pdf/pdf-clearance-bulk.html', context)

@login_required
def preview_print_clearance(request):
    """Return printable HTML fragment for preview modal"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    clearance_ids = request.GET.get('ids', '').split(',')
    if not clearance_ids or clearance_ids == ['']:
        return JsonResponse({'error': 'No clearance IDs provided'}, status=400)
    
    # Filter out empty IDs
    clearance_ids = [id.strip() for id in clearance_ids if id.strip()]
    if not clearance_ids:
        return JsonResponse({'error': 'No valid clearance IDs provided'}, status=400)
    
    clearance_forms = []
    
    # Efficiently fetch all clearances with their signatories
    clearances = ClearanceForm.objects.select_related(
        'student', 'student__profile'
    ).prefetch_related(
        'signatories__signatory__signatory_profile',
        'student__enrollment_forms'
    ).filter(id__in=clearance_ids)
    
    for clearance_form in clearances:
        try:
            # Get enrollment form for section
            enrollment_form = clearance_form.student.enrollment_forms.first()
            
            # Process signatory statuses with live data
            signatories = {}
            clearance_signatories = clearance_form.signatories.all()
            
            # Group signatories by type to handle duplicates
            signatory_groups = {}
            for clearance_signatory in clearance_signatories:
                # Get signatory type from profile
                try:
                    signatory_type = clearance_signatory.signatory.signatory_profile.signatory_type
                except:
                    # Fallback for users without profile
                    if clearance_signatory.signatory.user_type == 'admin':
                        signatory_type = 'registrar'
                    else:
                        signatory_type = 'unknown'
                
                # Group by signatory type
                if signatory_type not in signatory_groups:
                    signatory_groups[signatory_type] = []
                signatory_groups[signatory_type].append(clearance_signatory)
            
            # Process each signatory group
            for signatory_type, signatory_list in signatory_groups.items():
                if len(signatory_list) == 1:
                    # Single signatory of this type
                    clearance_signatory = signatory_list[0]
                    signatories[signatory_type] = {
                        'name': clearance_signatory.signatory.full_name,
                        'status': clearance_signatory.status,
                        'timestamp': clearance_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if clearance_signatory.updated_at else None,
                        'comment': clearance_signatory.remarks or clearance_signatory.comment
                    }
                else:
                    # Multiple signatories of the same type - choose the best one
                    approved_signatories = [s for s in signatory_list if s.status == 'approved']
                    if approved_signatories:
                        # Use the first approved one
                        best_signatory = approved_signatories[0]
                    else:
                        # Use the most recently updated one
                        best_signatory = max(signatory_list, key=lambda s: s.updated_at or clearance_signatory.clearance.created_at)
                    
                    signatories[signatory_type] = {
                        'name': best_signatory.signatory.full_name,
                        'status': best_signatory.status,
                        'timestamp': best_signatory.updated_at.strftime('%Y-%m-%d %H:%M') if best_signatory.updated_at else None,
                        'comment': best_signatory.remarks or best_signatory.comment
                    }
            
            clearance_forms.append({
                'clearance': clearance_form,
                'student': clearance_form.student,
                'profile': clearance_form.student.profile,
                'enrollment': enrollment_form,
                'signatories': clearance_signatories,  # Use the actual queryset
            })
        except Exception as e:
            continue  # Skip problematic clearances
    
    # Check if any clearances were found
    if not clearance_forms:
        return JsonResponse({'error': 'No valid clearance forms found for the provided IDs'}, status=400)
    
    context = {
        'clearance_forms': clearance_forms,
        'is_preview': True,  # Flag to indicate this is for preview
    }
    
    return render(request, 'pdf/pdf-clearance-preview.html', context)

@login_required
def print_enrollment(request, enrollment_id):
    """Print single enrollment form"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        enrollment_form = EnrollmentForm.objects.select_related('user', 'user__profile').get(id=enrollment_id)
        
        # Log the print action
        AuditLog.objects.create(
            user=request.user,
            action_type='enrollment_print',
            description=f'Printed enrollment form {enrollment_id} for {enrollment_form.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        context = {
            'enrollment_forms': [{
                'enrollment': enrollment_form,
                'student': enrollment_form.user,
                'profile': enrollment_form.user.profile,
            }]
        }
        
        return render(request, 'pdf/pdf-enrollment.html', context)
        
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment form not found'}, status=404)

@login_required
def bulk_print_enrollment(request):
    """Print multiple enrollment forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    enrollment_ids = request.GET.get('ids', '').split(',')
    enrollment_forms = []
    
    for enrollment_id in enrollment_ids:
        try:
            enrollment_form = EnrollmentForm.objects.select_related('user', 'user__profile').get(id=enrollment_id)
            
            # Log each bulk print action
            AuditLog.objects.create(
                user=request.user,
                action_type='enrollment_bulk_print',
                description=f'Bulk printed enrollment form {enrollment_id} for {enrollment_form.user.full_name} [IP: {get_client_ip(request)}]'
            )
            
            enrollment_forms.append({
                'enrollment': enrollment_form,
                'student': enrollment_form.user,
                'profile': enrollment_form.user.profile,
            })
        except EnrollmentForm.DoesNotExist:
            continue
    
    context = {
        'enrollment_forms': enrollment_forms,
    }
    
    return render(request, 'pdf/pdf-enrollment-bulk.html', context)

@login_required
def preview_print_enrollment(request):
    """Return printable HTML fragment for enrollment preview modal"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    enrollment_ids = request.GET.get('ids', '').split(',')
    if not enrollment_ids or enrollment_ids == ['']:
        return JsonResponse({'error': 'No enrollment IDs provided'}, status=400)
    
    # Filter out empty IDs
    enrollment_ids = [id.strip() for id in enrollment_ids if id.strip()]
    if not enrollment_ids:
        return JsonResponse({'error': 'No valid enrollment IDs provided'}, status=400)
    
    enrollment_forms = []
    
    # Efficiently fetch all enrollments
    enrollments = EnrollmentForm.objects.select_related(
        'user', 'user__profile'
    ).filter(id__in=enrollment_ids)
    
    for enrollment_form in enrollments:
        try:
            enrollment_forms.append({
                'enrollment': enrollment_form,
                'student': enrollment_form.user,
                'profile': enrollment_form.user.profile,
            })
        except Exception as e:
            continue  # Skip problematic enrollments
    
    # Check if any enrollments were found
    if not enrollment_forms:
        return JsonResponse({'error': 'No valid enrollment forms found for the provided IDs'}, status=400)
    
    context = {
        'enrollment_forms': enrollment_forms,
        'is_preview': True,  # Flag to indicate this is for preview
    }
    
    return render(request, 'pdf/pdf-enrollment.html', context)

@login_required
def print_graduation(request, graduation_id):
    """Print single graduation form"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        graduation_form = GraduationForm.objects.select_related('user', 'user__profile').get(id=graduation_id)
        
        # Log the print action
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_print',
            description=f'Printed graduation form {graduation_id} for {graduation_form.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        context = {
            'graduation': graduation_form,
            'student': graduation_form.user,
            'profile': graduation_form.user.profile,
        }
        
        return render(request, 'pdf/pdf-graduation.html', context)
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)

@login_required
def bulk_print_graduation(request):
    """Print multiple graduation forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    graduation_ids = request.GET.get('ids', '').split(',')
    graduation_forms = []
    
    for graduation_id in graduation_ids:
        try:
            graduation_form = GraduationForm.objects.select_related('user', 'user__profile').get(id=graduation_id)
            
            # Log each bulk print action
            AuditLog.objects.create(
                user=request.user,
                action_type='graduation_bulk_print',
                description=f'Bulk printed graduation form {graduation_id} for {graduation_form.user.full_name} [IP: {get_client_ip(request)}]'
            )
            
            graduation_forms.append({
                'graduation': graduation_form,
                'student': graduation_form.user,
                'profile': graduation_form.user.profile,
            })
        except GraduationForm.DoesNotExist:
            continue
    
    context = {
        'graduation_forms': graduation_forms,
    }
    
    return render(request, 'pdf/pdf-graduation-bulk.html', context)

@login_required
def preview_print_graduation(request):
    """Return printable HTML fragment for graduation preview modal"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    graduation_ids = request.GET.get('ids', '').split(',')
    if not graduation_ids or graduation_ids == ['']:
        return JsonResponse({'error': 'No graduation IDs provided'}, status=400)
    
    # Filter out empty IDs
    graduation_ids = [id.strip() for id in graduation_ids if id.strip()]
    if not graduation_ids:
        return JsonResponse({'error': 'No valid graduation IDs provided'}, status=400)
    
    graduation_forms = []
    
    # Efficiently fetch all graduations
    graduations = GraduationForm.objects.select_related(
        'user', 'user__profile'
    ).filter(id__in=graduation_ids)
    
    for graduation_form in graduations:
        try:
            graduation_forms.append({
                'graduation': graduation_form,
                'student': graduation_form.user,
                'profile': graduation_form.user.profile,
            })
        except Exception as e:
            continue  # Skip problematic graduations
    
    # Check if any graduations were found
    if not graduation_forms:
        return JsonResponse({'error': 'No valid graduation forms found for the provided IDs'}, status=400)
    
    context = {
        'graduation_forms': graduation_forms,
        'is_preview': True,  # Flag to indicate this is for preview
    }
    
    return render(request, 'pdf/pdf-graduation.html', context)

@login_required
def delete_clearance(request, clearance_id):
    """Delete single clearance form"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            clearance_form = ClearanceForm.objects.get(id=clearance_id)
            student_name = clearance_form.student.full_name
            
            # Log the deletion action before deleting
            AuditLog.objects.create(
                user=request.user,
                action_type='clearance_deletion',
                description=f'Deleted clearance form {clearance_id} for {student_name} [IP: {get_client_ip(request)}]'
            )
            
            clearance_form.delete()
            return JsonResponse({'success': True, 'message': 'Clearance deleted successfully'})
        except ClearanceForm.DoesNotExist:
            return JsonResponse({'error': 'Clearance form not found'}, status=404)
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def bulk_delete_clearance(request):
    """Delete multiple clearance forms and all related data"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            clearance_ids = data.get('clearance_ids', [])
            
            if not clearance_ids:
                return JsonResponse({'error': 'No clearance IDs provided'}, status=400)
            
            # Get student names for audit logging before deletion
            clearance_forms = ClearanceForm.objects.filter(id__in=clearance_ids).select_related('student')
            student_names = [form.student.full_name for form in clearance_forms]
            
            # Use bulk delete for efficiency and proper CASCADE deletion of all related data
            # This will automatically delete all related ClearanceSignatory records and other related data
            deleted_count = ClearanceForm.objects.filter(id__in=clearance_ids).delete()[0]
            
            # Log the bulk deletion action after successful deletion
            if deleted_count > 0:
                AuditLog.objects.create(
                    user=request.user,
                    action_type='clearance_bulk_deletion',
                    description=f'Registrar bulk deleted {deleted_count} clearance forms for: {", ".join(student_names)} [IP: {get_client_ip(request)}]'
                )
            
            return JsonResponse({
                'success': True, 
                'message': f'Successfully deleted {deleted_count} clearance(s) and all related data',
                'deleted_count': deleted_count
            })
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def bulk_approve_clearance(request):
    """Bulk approve multiple clearance forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            clearance_ids = data.get('clearance_ids', [])
            pin = data.get('pin')
            comment = data.get('comment', '')  # Optional comment
            
            if not clearance_ids:
                return JsonResponse({'error': 'No clearance IDs provided'}, status=400)
                
            # Verify PIN against RegistrarProfile
            from landing.models import RegistrarProfile
            reg_profile = getattr(request.user, 'registrar_profile', None)
            if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            # Get clearance forms
            clearance_forms = ClearanceForm.objects.filter(id__in=clearance_ids).select_related('student')
            
            if not clearance_forms.exists():
                return JsonResponse({'error': 'No clearance forms found'}, status=404)
            
            # Get user's signatory type and role
            try:
                signatory_profile = request.user.signatory_profile
                signatory_type = signatory_profile.signatory_type
                role_name = {
                    'dorm_supervisor': 'Dorm Supervisor',
                    'canteen_concessionaire': 'Canteen Concessionaire',
                    'library_director': 'Library Director',
                    'scholarship_director': 'Scholarship Director',
                    'it_director': 'IT Director',
                    'student_affairs': 'Student Affairs',
                    'cashier': 'Cashier',
                    'business_manager': 'Business Manager',
                    'registrar': 'Registrar',
                    'academic_dean': 'Academic Dean'
                }.get(signatory_type, 'Registrar')
            except:
                signatory_type = 'registrar'
                role_name = 'Registrar'
            
            # Process bulk approval
            approved_count = 0
            student_names = []
            
            for clearance_form in clearance_forms:
                from landing.models import ClearanceSignatory
                
                # Get or create the clearance signatory record (same pattern as individual approve)
                registrar_signatory, created = ClearanceSignatory.objects.get_or_create(
                    clearance=clearance_form,
                    signatory=request.user,
                    defaults={
                        'status': 'pending',
                        'role': role_name,
                        'seen_by_signatory': True
                    }
                )
                
                # Update role if it was created with wrong role
                registrar_signatory.role = role_name
                
                # Update status to approved
                registrar_signatory.status = 'approved'
                registrar_signatory.comment = comment if comment else ''
                registrar_signatory.ip_address = get_client_ip(request)
                registrar_signatory.seen_by_signatory = True
                registrar_signatory.save()
                
                approved_count += 1
                student_names.append(clearance_form.student.full_name)
                
                # Send individual approval notification to student
                try:
                    from landing.notification_service import NotificationService
                    NotificationService.notify_form_approval(
                        form_instance=clearance_form,
                        form_type='clearance',
                        signatory_user=request.user,
                        remarks=comment or ''
                    )
                except Exception as e:
                    print(f"Error sending approval notification for clearance {clearance_form.id}: {e}")
            
            # Log the bulk approval action
            if approved_count > 0:
                AuditLog.objects.create(
                    user=request.user,
                    action_type='clearance_bulk_approval',
                    description=f'Registrar bulk approved {approved_count} clearance forms for: {", ".join(student_names)} [IP: {get_client_ip(request)}]'
                )
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully approved {approved_count} clearance form(s)',
                'approved_count': approved_count
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def bulk_disapprove_clearance(request):
    """Bulk disapprove multiple clearance forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            clearance_ids = data.get('clearance_ids', [])
            pin = data.get('pin')
            reason = data.get('reason', 'Bulk disapproval')
            
            if not clearance_ids:
                return JsonResponse({'error': 'No clearance IDs provided'}, status=400)
                
            # Verify PIN against RegistrarProfile
            from landing.models import RegistrarProfile
            reg_profile = getattr(request.user, 'registrar_profile', None)
            if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            # Get clearance forms
            clearance_forms = ClearanceForm.objects.filter(id__in=clearance_ids).select_related('student')
            
            if not clearance_forms.exists():
                return JsonResponse({'error': 'No clearance forms found'}, status=404)
            
            # Get user's signatory type and role
            try:
                signatory_profile = request.user.signatory_profile
                signatory_type = signatory_profile.signatory_type
                role_name = {
                    'dorm_supervisor': 'Dorm Supervisor',
                    'canteen_concessionaire': 'Canteen Concessionaire',
                    'library_director': 'Library Director',
                    'scholarship_director': 'Scholarship Director',
                    'it_director': 'IT Director',
                    'student_affairs': 'Student Affairs',
                    'cashier': 'Cashier',
                    'business_manager': 'Business Manager',
                    'registrar': 'Registrar',
                    'academic_dean': 'Academic Dean'
                }.get(signatory_type, 'Registrar')
            except:
                signatory_type = 'registrar'
                role_name = 'Registrar'
            
            # Process bulk disapproval
            disapproved_count = 0
            student_names = []
            
            for clearance_form in clearance_forms:
                from landing.models import ClearanceSignatory
                
                # Get or create the clearance signatory record (same pattern as individual disapprove)
                registrar_signatory, created = ClearanceSignatory.objects.get_or_create(
                    clearance=clearance_form,
                    signatory=request.user,
                    defaults={
                        'status': 'pending',
                        'role': role_name,
                        'seen_by_signatory': True
                    }
                )
                
                # Update role if it was created with wrong role
                registrar_signatory.role = role_name
                
                # Update status to disapproved
                registrar_signatory.status = 'disapproved'
                registrar_signatory.comment = reason if reason else 'Bulk disapproval'
                registrar_signatory.ip_address = get_client_ip(request)
                registrar_signatory.seen_by_signatory = True
                registrar_signatory.save()
                
                disapproved_count += 1
                student_names.append(clearance_form.student.full_name)
            
            # Log the bulk disapproval action
            if disapproved_count > 0:
                AuditLog.objects.create(
                    user=request.user,
                    action_type='clearance_bulk_disapproval',
                    description=f'Registrar bulk disapproved {disapproved_count} clearance forms for: {", ".join(student_names)} with reason: {reason} [IP: {get_client_ip(request)}]'
                )
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully disapproved {disapproved_count} clearance form(s)',
                'disapproved_count': disapproved_count
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def registrar_enrollment(request):
    """Render the registrar enrollment page"""
    if request.user.user_type not in ['admin', 'registrar']:
        messages.error(request, "Access denied. You don't have permission to view this page.")
        return redirect('login')
    
    # Get all enrollment forms
    enrollment_forms = EnrollmentForm.objects.all().order_by('-created_at')
    
    context = {
        'enrollment_forms': enrollment_forms,
    }
    
    return render(request, 'REGISTRARENROLLMENT.html', context)

@login_required
def enrollment_data_api(request):
    """API endpoint to get enrollment data for the registrar"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get all enrollment forms with related data
        enrollment_forms = EnrollmentForm.objects.select_related('user').all().order_by('-created_at')
        
        data = []
        for form in enrollment_forms:
            # Get signatory statuses
            dean_signatory = form.signatories.filter(role='dean').first()
            business_signatory = form.signatories.filter(role='business_manager').first()
            registrar_signatory = form.signatories.filter(role='registrar').first()
            
            # Determine overall status based on all required signatories
            all_signatories = form.signatories.all()
            roles_required = {'dean', 'business_manager', 'registrar'}
            statuses = {s.role: s.status for s in all_signatories}
            
            if roles_required.issubset(statuses.keys()) and all(statuses[role] == 'approved' for role in roles_required):
                status = 'approved'
            elif any(status == 'disapproved' for status in statuses.values()):
                status = 'disapproved'
            else:
                status = 'pending'
            
            enrollment_data = {
                'id': str(form.id),
                'student_name': form.user.full_name,
                'course': form.course,
                'year': form.year,
                'section': form.section,
                'id_number': form.user.profile.student_number if hasattr(form.user, 'profile') else 'N/A',
                'date_submitted': form.created_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p'),
                'pdf_file': 'Enrollment_Form.pdf',  # Placeholder
                'dean_status': dean_signatory.status if dean_signatory else 'pending',
                'dean_timestamp': dean_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if dean_signatory and dean_signatory.status != 'pending' else '',
                'business_status': business_signatory.status if business_signatory else 'pending',
                'business_timestamp': business_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if business_signatory and business_signatory.status != 'pending' else '',
                'registrar_status': registrar_signatory.status if registrar_signatory else 'pending',
                'registrar_timestamp': registrar_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if registrar_signatory and registrar_signatory.status != 'pending' else '',
                'overall_status': status,
                'dean_remarks': dean_signatory.remarks if dean_signatory else '',
                'business_remarks': business_signatory.remarks if business_signatory else '',
                'registrar_remarks': registrar_signatory.remarks if registrar_signatory else '',
            }
            data.append(enrollment_data)
        
        return JsonResponse({'data': data})
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def approve_enrollment(request):
    """Approve an enrollment form"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        enrollment_id = data.get('enrollment_id')
        pin = data.get('pin')
        comment = data.get('comment', '')
        
        # Verify PIN against RegistrarProfile
        from landing.models import RegistrarProfile
        reg_profile = getattr(request.user, 'registrar_profile', None)
        if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get the enrollment form
        enrollment = EnrollmentForm.objects.get(id=enrollment_id)
        
        # Create or update registrar signatory
        signatory, created = EnrollmentSignatory.objects.get_or_create(
            enrollment=enrollment,
            signatory=request.user,
            role='registrar',
            defaults={
                'status': 'approved',
                'remarks': comment,
                'ip_address': get_client_ip(request)
            }
        )
        
        if not created:
            # Allow editing disapproved enrollments (changing from disapproved to approved)
            if signatory.status == 'approved':
                return JsonResponse({'error': 'Enrollment already approved'}, status=400)
            
            signatory.status = 'approved'
            signatory.remarks = comment
            signatory.ip_address = get_client_ip(request)
            signatory.save()
        
        # Send individual approval notification to student
        try:
            from landing.notification_service import NotificationService
            NotificationService.notify_form_approval(
                form_instance=enrollment,
                form_type='enrollment',
                signatory_user=request.user,
                remarks=comment
            )
        except Exception as e:
            print(f"Error sending approval notification: {e}")
        
        # Check if all required signatories approved and update enrollment status
        required_roles = ['business_manager', 'registrar', 'dean']
        all_signatories = EnrollmentSignatory.objects.filter(enrollment=enrollment)
        
        print(f"DEBUG: Checking enrollment {enrollment.id} status update")
        print(f"DEBUG: Found {all_signatories.count()} signatory records")
        for sig in all_signatories:
            print(f"DEBUG: Signatory {sig.signatory.full_name} ({sig.role}): {sig.status}")
        
        # Check if we have all required roles and all are approved
        signatory_roles = set(sig.role for sig in all_signatories)
        required_roles_set = set(required_roles)
        
        if (signatory_roles >= required_roles_set and 
            all_signatories.count() >= 4 and 
            all(s.status == 'approved' for s in all_signatories)):
            enrollment.status = 'approved'
            enrollment.save()
            print(f"DEBUG: Updated enrollment {enrollment.id} status to approved")
            
            # Send notifications for completed enrollment
            try:
                from landing.notification_service import NotificationService
                NotificationService.notify_enrollment_completed(enrollment.user, enrollment)
                NotificationService.notify_admin_form_completed('enrollment', enrollment.user.full_name)
            except Exception as e:
                print(f"Error sending enrollment completion notifications: {e}")
        else:
            missing_roles = required_roles_set - signatory_roles
            print(f"DEBUG: Not all required signatories approved yet. Missing roles: {missing_roles}")
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='enrollment_approval',
            description=f'Approved enrollment form {enrollment_id} for {enrollment.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Enrollment approved successfully',
            'timestamp': signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p')
        })
        
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def disapprove_enrollment(request):
    """Disapprove an enrollment form"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        enrollment_id = data.get('enrollment_id')
        pin = data.get('pin')
        reasons = data.get('reasons', [])
        appointment_date = data.get('appointment_date')
        comment = data.get('comment', '')
        
        # Verify PIN against RegistrarProfile
        from landing.models import RegistrarProfile
        reg_profile = getattr(request.user, 'registrar_profile', None)
        if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Validate reasons
        if not reasons:
            return JsonResponse({'error': 'Please select at least one reason'}, status=400)
        
        # Get the enrollment form
        enrollment = EnrollmentForm.objects.get(id=enrollment_id)
        
        # Create or update registrar signatory
        signatory, created = EnrollmentSignatory.objects.get_or_create(
            enrollment=enrollment,
            signatory=request.user,
            role='registrar',
            defaults={
                'status': 'disapproved',
                'remarks': f"Reasons: {', '.join(reasons)}. Appointment: {appointment_date}. {comment}",
                'ip_address': get_client_ip(request)
            }
        )
        
        if not created:
            signatory.status = 'disapproved'
            signatory.remarks = f"Reasons: {', '.join(reasons)}. Appointment: {appointment_date}. {comment}"
            signatory.ip_address = get_client_ip(request)
            signatory.save()
        
        # Update enrollment form status to pending (since it's disapproved but can be edited)
        enrollment.status = 'pending'
        enrollment.save()
        
        # Send notification to student
        try:
            from landing.notification_service import NotificationService
            notification_service = NotificationService()
            notification_service.handle_form_disapproval(
                form=enrollment,
                form_type='enrollment',
                disapproval_reasons=reasons,
                settlement_instructions=comment,
                appointment_date=appointment_date
            )
        except Exception as e:
            print(f"Error sending enrollment disapproval notification: {e}")
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='enrollment_disapproval',
            description=f'Disapproved enrollment form {enrollment_id} for {enrollment.user.full_name}. Reasons: {", ".join(reasons)} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Enrollment disapproved successfully',
            'timestamp': signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p'),
            'reasons': reasons,
            'appointment_date': appointment_date
        })
        
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def bulk_approve_enrollment(request):
    """Bulk approve multiple enrollment forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            enrollment_ids = data.get('enrollment_ids', [])
            pin = data.get('pin')
            comment = data.get('comment', '')
            
            if not enrollment_ids:
                return JsonResponse({'error': 'No enrollment IDs provided'}, status=400)
                
            # Verify PIN against RegistrarProfile
            from landing.models import RegistrarProfile
            reg_profile = getattr(request.user, 'registrar_profile', None)
            if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            # Get enrollment forms
            enrollment_forms = EnrollmentForm.objects.filter(id__in=enrollment_ids).select_related('user')
            
            if not enrollment_forms.exists():
                return JsonResponse({'error': 'No enrollment forms found'}, status=404)
            
            # Process bulk approval
            approved_count = 0
            student_names = []
            
            for enrollment in enrollment_forms:
                try:
                    # Create or update registrar signatory
                    signatory, created = EnrollmentSignatory.objects.get_or_create(
                        enrollment=enrollment,
                        signatory=request.user,
                        role='registrar',
                        defaults={
                            'status': 'approved',
                            'remarks': comment,
                            'ip_address': get_client_ip(request)
                        }
                    )
                    
                    if not created:
                        # Allow editing disapproved enrollments (changing from disapproved to approved)
                        if signatory.status == 'approved':
                            continue  # Skip already approved
                        
                        signatory.status = 'approved'
                        signatory.remarks = comment
                        signatory.ip_address = get_client_ip(request)
                        signatory.save()
                    
                    approved_count += 1
                    student_names.append(enrollment.user.full_name)
                    
                    # Send individual approval notification to student
                    try:
                        from landing.notification_service import NotificationService
                        NotificationService.notify_form_approval(
                            form_instance=enrollment,
                            form_type='enrollment',
                            signatory=request.user,
                            signatory_role='registrar'
                        )
                    except Exception as e:
                        print(f"Failed to send approval notification for enrollment {enrollment.id}: {str(e)}")
                    
                    # Log individual action
                    AuditLog.objects.create(
                        user=request.user,
                        action_type='enrollment_bulk_approval',
                        description=f'Bulk approved enrollment form {enrollment.id} for {enrollment.user.full_name} [IP: {get_client_ip(request)}]'
                    )
                    
                except Exception as e:
                    print(f"Error processing enrollment {enrollment.id}: {str(e)}")
                    continue
            
            if approved_count == 0:
                return JsonResponse({'error': 'No enrollments were approved'}, status=400)
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully approved {approved_count} enrollment(s)',
                'approved_count': approved_count,
                'student_names': student_names
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def bulk_disapprove_enrollment(request):
    """Bulk disapprove multiple enrollment forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            enrollment_ids = data.get('enrollment_ids', [])
            pin = data.get('pin')
            reason = data.get('reason', 'Bulk disapproval')
            comment = data.get('comment', '')
            appointment_date = data.get('appointment_date', '')
            
            if not enrollment_ids:
                return JsonResponse({'error': 'No enrollment IDs provided'}, status=400)
                
            # Verify PIN against RegistrarProfile
            from landing.models import RegistrarProfile
            reg_profile = getattr(request.user, 'registrar_profile', None)
            if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            # Get enrollment forms
            enrollment_forms = EnrollmentForm.objects.filter(id__in=enrollment_ids).select_related('user')
            
            if not enrollment_forms.exists():
                return JsonResponse({'error': 'No enrollment forms found'}, status=404)
            
            # Process bulk disapproval
            disapproved_count = 0
            student_names = []
            
            for enrollment in enrollment_forms:
                try:
                    # Create remarks with reasons and appointment
                    remarks_parts = [f"Reasons: {reason}"]
                    if comment:
                        remarks_parts.append(f"Comment: {comment}")
                    if appointment_date:
                        remarks_parts.append(f"Appointment: {appointment_date}")
                    
                    final_remarks = " | ".join(remarks_parts)
                    
                    # Create or update registrar signatory
                    signatory, created = EnrollmentSignatory.objects.get_or_create(
                        enrollment=enrollment,
                        signatory=request.user,
                        role='registrar',
                        defaults={
                            'status': 'disapproved',
                            'remarks': final_remarks,
                            'ip_address': get_client_ip(request)
                        }
                    )
                    
                    if not created:
                        if signatory.status == 'disapproved':
                            continue  # Skip already disapproved
                        
                        signatory.status = 'disapproved'
                        signatory.remarks = final_remarks
                        signatory.ip_address = get_client_ip(request)
                        signatory.save()
                    
                    disapproved_count += 1
                    student_names.append(enrollment.user.full_name)
                    
                    # Send individual disapproval notification to student
                    try:
                        from landing.notification_service import NotificationService
                        NotificationService.notify_form_disapproval(
                            form_instance=enrollment,
                            form_type='enrollment',
                            signatory=request.user,
                            signatory_role='registrar',
                            reason=reason,
                            appointment_date=appointment_date
                        )
                    except Exception as e:
                        print(f"Failed to send disapproval notification for enrollment {enrollment.id}: {str(e)}")
                    
                    # Log individual action
                    AuditLog.objects.create(
                        user=request.user,
                        action_type='enrollment_bulk_disapproval',
                        description=f'Bulk disapproved enrollment form {enrollment.id} for {enrollment.user.full_name}. Reason: {reason} [IP: {get_client_ip(request)}]'
                    )
                    
                except Exception as e:
                    print(f"Error processing enrollment {enrollment.id}: {str(e)}")
                    continue
            
            if disapproved_count == 0:
                return JsonResponse({'error': 'No enrollments were disapproved'}, status=400)
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully disapproved {disapproved_count} enrollment(s)',
                'disapproved_count': disapproved_count,
                'student_names': student_names
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def delete_enrollment_registrar(request, enrollment_id):
    """Delete an enrollment form (registrar function)"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        enrollment = EnrollmentForm.objects.get(id=enrollment_id)
        
        # Log the action before deletion
        AuditLog.objects.create(
            user=request.user,
            action_type='enrollment_deletion',
            description=f'Deleted enrollment form {enrollment_id} for {enrollment.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        enrollment.delete()
        
        return JsonResponse({
            'success': True,
            'message': 'Enrollment form deleted successfully'
        })
        
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def bulk_delete_enrollment(request):
    """Bulk delete enrollment forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        enrollment_ids = data.get('enrollment_ids', [])
        
        if not enrollment_ids:
            return JsonResponse({'error': 'No enrollment forms selected'}, status=400)
        
        deleted_count = 0
        for enrollment_id in enrollment_ids:
            try:
                enrollment = EnrollmentForm.objects.get(id=enrollment_id)
                
                # Log the action before deletion
                AuditLog.objects.create(
                    user=request.user,
                    action_type='enrollment_bulk_deletion',
                    description=f'Deleted enrollment form {enrollment_id} for {enrollment.user.full_name} [IP: {get_client_ip(request)}]'
                )
                
                enrollment.delete()
                deleted_count += 1
                
            except EnrollmentForm.DoesNotExist:
                continue
        
        return JsonResponse({
            'success': True,
            'message': f'Successfully deleted {deleted_count} enrollment form(s)',
            'deleted_count': deleted_count
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def bulk_print_enrollment(request):
    """Bulk print enrollment forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        enrollment_ids = request.GET.get('ids', '').split(',')
        enrollment_ids = [id.strip() for id in enrollment_ids if id.strip()]
        
        if not enrollment_ids:
            return JsonResponse({'error': 'No enrollment forms selected'}, status=400)
        
        enrollment_forms = []
        for enrollment_id in enrollment_ids:
            try:
                enrollment = EnrollmentForm.objects.get(id=enrollment_id)
                enrollment_forms.append(enrollment)
            except EnrollmentForm.DoesNotExist:
                continue
        
        if not enrollment_forms:
            return JsonResponse({'error': 'No valid enrollment forms found'}, status=404)
        
        # Create context for bulk printing
        context = {
            'enrollment_forms': enrollment_forms,
            'today': date.today().strftime('%Y-%m-%d')
        }
        
        return render(request, 'pdf/pdf-enrollment-bulk.html', context)
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def registrar_graduation(request):
    """Render the registrar graduation page"""
    if request.user.user_type not in ['admin', 'registrar']:
        messages.error(request, "Access denied. You don't have permission to view this page.")
        return redirect('login')
    
    # Get all graduation forms
    graduation_forms = GraduationForm.objects.all().order_by('-created_at')
    
    context = {
        'graduation_forms': graduation_forms,
    }
    
    return render(request, 'REGISTRARGRADUATION.html', context)

@login_required
def graduation_data_api(request):
    """API endpoint to get graduation data for the registrar"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        graduation_forms = GraduationForm.objects.select_related('user').all().order_by('-created_at')
        
        data = []
        for form in graduation_forms:
            business_signatory = form.signatories.filter(role='business_manager').first()
            registrar_signatory = form.signatories.filter(role='registrar').first()
            dean_signatory = form.signatories.filter(role='dean').first()
            president_signatory = form.signatories.filter(role='president').first()
            
            # Determine overall status based on all required signatories (including president)
            all_signatories = form.signatories.all()
            roles_required = {'dean', 'business_manager', 'registrar', 'president'}
            statuses = {s.role: s.status for s in all_signatories}
            
            # Overall status logic: only "pending" or "completed"
            if roles_required.issubset(statuses.keys()) and all(statuses.get(role, 'pending') == 'approved' for role in roles_required):
                status = 'completed'
                # Use the latest timestamp among all approvals for completed status
                timestamps = []
                for signatory in [dean_signatory, business_signatory, registrar_signatory, president_signatory]:
                    if signatory and signatory.status == 'approved':
                        timestamps.append(signatory.updated_at)
                overall_timestamp = max(timestamps).astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if timestamps else None
            else:
                status = 'pending'
                overall_timestamp = None
            
            # Get section from enrollment forms
            enrollment_form = EnrollmentForm.objects.filter(user=form.user).first()
            section = enrollment_form.section if enrollment_form else 'N/A'
            
            graduation_data = {
                'id': str(form.id),
                'student_name': form.user.full_name,
                'course': form.user.profile.program if hasattr(form.user, 'profile') else 'N/A',
                'year': form.user.profile.year_level if hasattr(form.user, 'profile') else 'N/A',
                'section': section,
                'id_number': form.user.profile.student_number if hasattr(form.user, 'profile') else 'N/A',
                'grad_appno': form.grad_appno or 'N/A',
                'date_submitted': form.created_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p'),
                'pdf_file': 'Graduation_Form.pdf',
                'dean_status': dean_signatory.status if dean_signatory else 'pending',
                'dean_timestamp': dean_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if dean_signatory and dean_signatory.status != 'pending' else '',
                'business_status': business_signatory.status if business_signatory else 'pending',
                'business_timestamp': business_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if business_signatory and business_signatory.status != 'pending' else '',
                'registrar_status': registrar_signatory.status if registrar_signatory else 'pending',
                'registrar_timestamp': registrar_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if registrar_signatory and registrar_signatory.status != 'pending' else '',
                'president_status': president_signatory.status if president_signatory else 'pending',
                'president_timestamp': president_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if president_signatory and president_signatory.status != 'pending' else '',
                'overall_status': status,
                'overall_timestamp': overall_timestamp,
                'dean_remarks': dean_signatory.remarks if dean_signatory else '',
                'business_remarks': business_signatory.remarks if business_signatory else '',
                'registrar_remarks': registrar_signatory.remarks if registrar_signatory else '',
                'president_remarks': president_signatory.remarks if president_signatory else '',
            }
            data.append(graduation_data)
        
        return JsonResponse({'data': data})
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def approve_graduation(request):
    """Approve a graduation form"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        graduation_id = data.get('graduation_id')
        pin = data.get('pin')
        comment = data.get('comment', '')
        
        if not graduation_id or not pin:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Verify PIN against RegistrarProfile
        from landing.models import RegistrarProfile
        reg_profile = getattr(request.user, 'registrar_profile', None)
        if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get graduation form
        graduation = GraduationForm.objects.get(id=graduation_id)
        
        # Create or update registrar signatory
        registrar_signatory, created = GraduationSignatory.objects.get_or_create(
            graduation=graduation,
            signatory=request.user,
            role='registrar',
            defaults={'status': 'pending'}
        )
        
        if registrar_signatory.status == 'approved':
            return JsonResponse({'error': 'Graduation form has already been approved'}, status=400)
        
        # Update status
        registrar_signatory.status = 'approved'
        registrar_signatory.remarks = comment
        registrar_signatory.ip_address = get_client_ip(request)
        registrar_signatory.save()
        
        # Send individual approval notification to student
        try:
            from landing.notification_service import NotificationService
            NotificationService.notify_form_approval(
                form_instance=graduation,
                form_type='graduation',
                signatory_user=request.user,
                remarks=comment
            )
        except Exception as e:
            print(f"Error sending approval notification: {e}")
        
        # Check if all required signatories approved and update graduation status
        required_roles = ['dean', 'business_manager', 'registrar', 'president']
        all_signatories = GraduationSignatory.objects.filter(graduation=graduation)
        
        # Check if we have all required roles and all are approved
        signatory_roles = set(sig.role for sig in all_signatories)
        required_roles_set = set(required_roles)
        
        if (signatory_roles >= required_roles_set and 
            all_signatories.count() >= 4 and 
            all(s.status == 'approved' for s in all_signatories)):
            graduation.status = 'approved'
            graduation.save()
            
            # Send notifications for completed graduation
            try:
                from landing.notification_service import NotificationService
                NotificationService.notify_graduation_completed(graduation.user, graduation)
                NotificationService.notify_admin_form_completed('graduation', graduation.user.full_name)
            except Exception as e:
                print(f"Error sending graduation completion notifications: {e}")
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_approval',
            description=f'Approved graduation form {graduation_id} for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Graduation form approved successfully'
        })
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def disapprove_graduation(request):
    """Disapprove a graduation form"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        graduation_id = data.get('graduation_id')
        pin = data.get('pin')
        reasons = data.get('reasons', [])
        appointment_date = data.get('appointment_date')
        comment = data.get('comment', '')
        
        if not graduation_id or not pin:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Verify PIN against RegistrarProfile
        from landing.models import RegistrarProfile
        reg_profile = getattr(request.user, 'registrar_profile', None)
        if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get graduation form
        graduation = GraduationForm.objects.get(id=graduation_id)
        
        # Create or update registrar signatory
        registrar_signatory, created = GraduationSignatory.objects.get_or_create(
            graduation=graduation,
            signatory=request.user,
            role='registrar',
            defaults={'status': 'pending'}
        )
        
        if registrar_signatory.status == 'disapproved':
            return JsonResponse({'error': 'Graduation form has already been disapproved'}, status=400)
        
        # Update status
        registrar_signatory.status = 'disapproved'
        registrar_signatory.remarks = f"Reasons: {', '.join(reasons)}. Appointment: {appointment_date}. {comment}"
        registrar_signatory.ip_address = get_client_ip(request)
        registrar_signatory.save()
        
        # Send notification to student
        try:
            from landing.notification_service import NotificationService
            notification_service = NotificationService()
            notification_service.handle_form_disapproval(
                form=graduation,
                form_type='graduation',
                disapproval_reasons=reasons,
                settlement_instructions=comment,
                appointment_date=appointment_date
            )
        except Exception as e:
            print(f"Error sending graduation disapproval notification: {e}")
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_disapproval',
            description=f'Disapproved graduation form {graduation_id} for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Graduation form disapproved successfully'
        })
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def bulk_approve_graduation(request):
    """Bulk approve multiple graduation forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            graduation_ids = data.get('graduation_ids', [])
            pin = data.get('pin')
            comment = data.get('comment', '')
            
            if not graduation_ids:
                return JsonResponse({'error': 'No graduation IDs provided'}, status=400)
                
            # Verify PIN against RegistrarProfile
            from landing.models import RegistrarProfile
            reg_profile = getattr(request.user, 'registrar_profile', None)
            if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            # Get graduation forms
            graduation_forms = GraduationForm.objects.filter(id__in=graduation_ids).select_related('user')
            
            if not graduation_forms.exists():
                return JsonResponse({'error': 'No graduation forms found'}, status=404)
            
            # Process bulk approval
            approved_count = 0
            student_names = []
            
            for graduation in graduation_forms:
                try:
                    # Create or update registrar signatory
                    signatory, created = GraduationSignatory.objects.get_or_create(
                        graduation=graduation,
                        signatory=request.user,
                        role='registrar',
                        defaults={
                            'status': 'approved',
                            'remarks': comment,
                            'ip_address': get_client_ip(request)
                        }
                    )
                    
                    if not created:
                        # Allow editing disapproved graduations (changing from disapproved to approved)
                        if signatory.status == 'approved':
                            continue  # Skip already approved
                        
                        signatory.status = 'approved'
                        signatory.remarks = comment
                        signatory.ip_address = get_client_ip(request)
                        signatory.save()
                    
                    approved_count += 1
                    student_names.append(graduation.user.full_name)
                    
                    # Send individual approval notification to student
                    try:
                        from landing.notification_service import NotificationService
                        NotificationService.notify_form_approval(
                            form_instance=graduation,
                            form_type='graduation',
                            signatory=request.user,
                            signatory_role='registrar'
                        )
                    except Exception as e:
                        print(f"Failed to send approval notification for graduation {graduation.id}: {str(e)}")
                    
                    # Log individual action
                    AuditLog.objects.create(
                        user=request.user,
                        action_type='graduation_bulk_approval',
                        description=f'Bulk approved graduation form {graduation.id} for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
                    )
                    
                except Exception as e:
                    print(f"Error processing graduation {graduation.id}: {str(e)}")
                    continue
            
            if approved_count == 0:
                return JsonResponse({'error': 'No graduations were approved'}, status=400)
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully approved {approved_count} graduation(s)',
                'approved_count': approved_count,
                'student_names': student_names
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def bulk_disapprove_graduation(request):
    """Bulk disapprove multiple graduation forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            graduation_ids = data.get('graduation_ids', [])
            pin = data.get('pin')
            reason = data.get('reason', 'Bulk disapproval')
            comment = data.get('comment', '')
            appointment_date = data.get('appointment_date', '')
            
            if not graduation_ids:
                return JsonResponse({'error': 'No graduation IDs provided'}, status=400)
                
            # Verify PIN against RegistrarProfile
            from landing.models import RegistrarProfile
            reg_profile = getattr(request.user, 'registrar_profile', None)
            if not reg_profile or not reg_profile.pin_set or pin != reg_profile.pin:
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            # Get graduation forms
            graduation_forms = GraduationForm.objects.filter(id__in=graduation_ids).select_related('user')
            
            if not graduation_forms.exists():
                return JsonResponse({'error': 'No graduation forms found'}, status=404)
            
            # Process bulk disapproval
            disapproved_count = 0
            student_names = []
            
            for graduation in graduation_forms:
                try:
                    # Create remarks with reasons and appointment
                    remarks_parts = [f"Reasons: {reason}"]
                    if comment:
                        remarks_parts.append(f"Comment: {comment}")
                    if appointment_date:
                        remarks_parts.append(f"Appointment: {appointment_date}")
                    
                    final_remarks = " | ".join(remarks_parts)
                    
                    # Create or update registrar signatory
                    signatory, created = GraduationSignatory.objects.get_or_create(
                        graduation=graduation,
                        signatory=request.user,
                        role='registrar',
                        defaults={
                            'status': 'disapproved',
                            'remarks': final_remarks,
                            'ip_address': get_client_ip(request)
                        }
                    )
                    
                    if not created:
                        if signatory.status == 'disapproved':
                            continue  # Skip already disapproved
                        
                        signatory.status = 'disapproved'
                        signatory.remarks = final_remarks
                        signatory.ip_address = get_client_ip(request)
                        signatory.save()
                    
                    disapproved_count += 1
                    student_names.append(graduation.user.full_name)
                    
                    # Send individual disapproval notification to student
                    try:
                        from landing.notification_service import NotificationService
                        NotificationService.notify_form_disapproval(
                            form_instance=graduation,
                            form_type='graduation',
                            signatory=request.user,
                            signatory_role='registrar',
                            reason=reason,
                            appointment_date=appointment_date
                        )
                    except Exception as e:
                        print(f"Failed to send disapproval notification for graduation {graduation.id}: {str(e)}")
                    
                    # Log individual action
                    AuditLog.objects.create(
                        user=request.user,
                        action_type='graduation_bulk_disapproval',
                        description=f'Bulk disapproved graduation form {graduation.id} for {graduation.user.full_name}. Reason: {reason} [IP: {get_client_ip(request)}]'
                    )
                    
                except Exception as e:
                    print(f"Error processing graduation {graduation.id}: {str(e)}")
                    continue
            
            if disapproved_count == 0:
                return JsonResponse({'error': 'No graduations were disapproved'}, status=400)
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully disapproved {disapproved_count} graduation(s)',
                'disapproved_count': disapproved_count,
                'student_names': student_names
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def delete_graduation_registrar(request, graduation_id):
    """Delete a graduation form (registrar)"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'DELETE':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        graduation = GraduationForm.objects.get(id=graduation_id)
        
        # Log the action before deletion
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_deletion',
            description=f'Deleted graduation form {graduation_id} for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        graduation.delete()
        
        return JsonResponse({
            'success': True,
            'message': 'Graduation form deleted successfully'
        })
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def bulk_delete_graduation(request):
    """Bulk delete graduation forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        graduation_ids = data.get('graduation_ids', [])
        
        if not graduation_ids:
            return JsonResponse({'error': 'No graduation forms selected'}, status=400)
        
        deleted_count = 0
        for graduation_id in graduation_ids:
            try:
                graduation = GraduationForm.objects.get(id=graduation_id)
                
                # Log the action before deletion
                AuditLog.objects.create(
                    user=request.user,
                    action_type='graduation_bulk_deletion',
                    description=f'Deleted graduation form {graduation_id} for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
                )
                
                graduation.delete()
                deleted_count += 1
                
            except GraduationForm.DoesNotExist:
                continue
        
        return JsonResponse({
            'success': True,
            'message': f'Successfully deleted {deleted_count} graduation form(s)',
            'deleted_count': deleted_count
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def view_graduation_registrar(request, graduation_id):
    """View a graduation form in modal"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        graduation = GraduationForm.objects.get(id=graduation_id)
        profile = getattr(graduation.user, 'profile', None)
        
        # Populate the form with actual data
        context = {
            'graduation': graduation,
            'user': graduation.user,
            'profile': profile,
            'today': date.today().strftime('%Y-%m-%d')
        }
        
        return render(request, 'pdf/pdf-graduation.html', context)
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def print_graduation(request, graduation_id):
    """Print a graduation form"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        graduation = GraduationForm.objects.get(id=graduation_id)
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_print',
            description=f'Printed graduation form {graduation_id} for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        # Populate the form with actual data
        profile = getattr(graduation.user, 'profile', None)
        context = {
            'graduation': graduation,
            'user': graduation.user,
            'profile': profile,
            'today': date.today().strftime('%Y-%m-%d')
        }
        
        return render(request, 'pdf/pdf-graduation.html', context)
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def bulk_print_graduation(request):
    """Bulk print graduation forms"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        graduation_ids = request.GET.get('ids', '').split(',')
        
        if not graduation_ids or graduation_ids[0] == '':
            return JsonResponse({'error': 'No graduation forms selected'}, status=400)
        
        graduations = []
        for graduation_id in graduation_ids:
            try:
                graduation = GraduationForm.objects.get(id=graduation_id)
                graduations.append(graduation)
                
                # Log the action
                AuditLog.objects.create(
                    user=request.user,
                    action_type='graduation_bulk_print',
                    description=f'Bulk printed graduation form {graduation_id} for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
                )
                
            except GraduationForm.DoesNotExist:
                continue
        
        context = {
            'graduations': graduations
        }
        
        return render(request, 'pdf/pdf-graduation-bulk.html', context)
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def registrar_courses(request):
    """Render the registrar courses page"""
    if request.user.user_type not in ['admin', 'registrar']:
        messages.error(request, "Access denied. You don't have permission to view this page.")
        return redirect('login')
    
    from landing.models import AcademicProgram
    
    # Get all programs for dropdown filters
    programs = AcademicProgram.objects.all().order_by('program_type', 'code')
    
    context = {
        'programs': programs,
    }
    
    return render(request, 'REGISTRARCOURSE.html', context)

@login_required
def registrar_document_release(request):
    """Render the registrar document release page"""
    if request.user.user_type not in ['admin', 'registrar']:
        messages.error(request, "Access denied. You don't have permission to view this page.")
        return redirect('login')
    
    # Get all document requests with related data
    document_requests = DocumentRequest.objects.select_related('requester', 'requester__profile').all().order_by('-created_at')
    
    context = {
        'document_requests': document_requests,
    }
    
    return render(request, 'REGISTRARDOCUMENTRELEASE.html', context)

@login_required
def document_release_data_api(request):
    """API endpoint to get document release data for AJAX requests"""
    if not (request.user.user_type in ['admin', 'registrar'] or is_business_manager(request.user)):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get filter parameters
        course_filter = request.GET.get('course')
        year_filter = request.GET.get('year')
        section_filter = request.GET.get('section')
        status_filter = request.GET.get('status')
        search_query = request.GET.get('search')
        
        # Build query
        document_requests = DocumentRequest.objects.select_related('requester', 'requester__profile').all()
        
        if course_filter:
            document_requests = document_requests.filter(requester__profile__program=course_filter)
        if year_filter:
            document_requests = document_requests.filter(requester__profile__year_level=year_filter)
        if section_filter:
            # Filter by section from EnrollmentForm
            document_requests = document_requests.filter(requester__enrollment_forms__section=section_filter).distinct()
        if status_filter:
            document_requests = document_requests.filter(status=status_filter)
        if search_query:
            document_requests = document_requests.filter(
                Q(requester__full_name__icontains=search_query) |
                Q(requester__profile__student_number__icontains=search_query) |
                Q(requester__profile__program__icontains=search_query)
            )
        
        # Order by submission date (most recent first)
        document_requests = document_requests.order_by('-created_at')
        
        # Serialize data
        data = []
        for doc_request in document_requests:
            # Get section from enrollment forms
            enrollment_form = EnrollmentForm.objects.filter(user=doc_request.requester).first()
            section = enrollment_form.section if enrollment_form else 'N/A'
            
            data.append({
                'id': str(doc_request.id),
                'requester': {
                    'id': str(doc_request.requester.id),
                    'full_name': doc_request.requester.full_name,
                    'profile': {
                        'student_number': doc_request.requester.profile.student_number if hasattr(doc_request.requester, 'profile') else None,
                        'program': doc_request.requester.profile.program if hasattr(doc_request.requester, 'profile') else None,
                        'year_level': doc_request.requester.profile.year_level if hasattr(doc_request.requester, 'profile') else None,
                    } if hasattr(doc_request.requester, 'profile') else None,
                    'section': section
                },
                'document_type': doc_request.document_type,
                'purpose': doc_request.purpose,
                'preferred_release': doc_request.preferred_release.isoformat() if doc_request.preferred_release else None,
                'status': doc_request.status,
                'created_at': doc_request.created_at.astimezone(pytz.timezone('Asia/Manila')).isoformat(),
                'updated_at': doc_request.updated_at.astimezone(pytz.timezone('Asia/Manila')).isoformat(),
                # Business Manager status
                'business_manager_status': getattr(doc_request, 'business_manager_status', 'pending'),
                'business_manager_timestamp': doc_request.business_manager_timestamp.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if getattr(doc_request, 'business_manager_timestamp', None) else None,
                'business_manager_comment': getattr(doc_request, 'business_manager_comment', None),
            })
        
        return JsonResponse({'data': data})
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def submit_release_date(request):
    """Submit a release date for a document"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        document_request_id = data.get('document_request_id')
        release_date = data.get('release_date')
        
        if not document_request_id or not release_date:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Get the document request
        document_request = DocumentRequest.objects.get(id=document_request_id)
        
        # Update the document request with release date only
        document_request.preferred_release = release_date
        document_request.save()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='release_date_submitted',
            description=f'Release date {release_date} submitted for {document_request.document_type} - {document_request.requester.full_name}'
        )
        
        return JsonResponse({'success': True, 'message': 'Release date submitted successfully'})
        
    except DocumentRequest.DoesNotExist:
        return JsonResponse({'error': 'Document request not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def update_release_date(request):
    """Update the release date for a document"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        document_request_id = data.get('document_request_id')
        release_date = data.get('release_date')
        
        if not document_request_id or not release_date:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Get the document request
        document_request = DocumentRequest.objects.get(id=document_request_id)
        
        # Update the release date
        document_request.preferred_release = release_date
        document_request.save()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='release_date_updated',
            description=f'Release date updated to {release_date} for {document_request.document_type} - {document_request.requester.full_name}'
        )
        
        return JsonResponse({'success': True, 'message': 'Release date updated successfully'})
        
    except DocumentRequest.DoesNotExist:
        return JsonResponse({'error': 'Document request not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def update_document_status(request):
    """Update the status of a document request"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        document_request_id = data.get('document_request_id')
        new_status = data.get('status')
        
        if not document_request_id or not new_status:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Validate status
        valid_statuses = ['pending', 'processing', 'ready', 'released', 'blocked_due_to_balance']
        if new_status not in valid_statuses:
            return JsonResponse({'error': 'Invalid status'}, status=400)
        
        # Get the document request
        document_request = DocumentRequest.objects.get(id=document_request_id)
        
        # Validate release date is set for release status
        if new_status == 'released' and not document_request.preferred_release:
            return JsonResponse({
                'error': 'A release date must be set before marking a document as released. Please set a release date first.'
            }, status=400)
        
        # Update the status
        old_status = document_request.status
        document_request.status = new_status
        document_request.save()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='document_status_updated',
            description=f'Document status updated from {old_status} to {new_status} for {document_request.document_type} - {document_request.requester.full_name}'
        )
        
        # Send notifications for ready status
        if new_status == 'ready' and old_status != 'ready':
            try:
                from landing.notification_service import NotificationService
                NotificationService.notify_document_ready(
                    student=document_request.requester,
                    document_request=document_request
                )
            except Exception as e:
                logger.error(f"Error sending document ready notification: {str(e)}")
        
        return JsonResponse({'success': True, 'message': f'Document status updated to {new_status}'})
        
    except DocumentRequest.DoesNotExist:
        return JsonResponse({'error': 'Document request not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def delete_document_release(request, document_request_id):
    """Delete a document request"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'DELETE':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        document_request = DocumentRequest.objects.get(id=document_request_id)
        document_request.delete()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='document_request_deleted',
            description=f'Document request {document_request.document_type} deleted for {document_request.requester.full_name}'
        )
        
        return JsonResponse({'success': True, 'message': 'Document request deleted successfully'})
        
    except DocumentRequest.DoesNotExist:
        return JsonResponse({'error': 'Document request not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def bulk_delete_document_release(request):
    """Bulk delete document requests"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        document_request_ids = data.get('document_request_ids', [])
        
        if not document_request_ids:
            return JsonResponse({'error': 'No document request IDs provided'}, status=400)
        
        # Delete the document requests
        deleted_count = 0
        for doc_id in document_request_ids:
            try:
                document_request = DocumentRequest.objects.get(id=doc_id)
                document_request.delete()
                deleted_count += 1
                
                # Log the action
                AuditLog.objects.create(
                    user=request.user,
                    action_type='document_request_deleted',
                    description=f'Document request {document_request.document_type} deleted for {document_request.requester.full_name}'
                )
            except DocumentRequest.DoesNotExist:
                continue
        
        return JsonResponse({
            'success': True, 
            'message': f'Successfully deleted {deleted_count} document request(s)',
            'deleted_count': deleted_count
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def registrar_reports(request):
    """Render the registrar reports page"""
    if request.user.user_type not in ['admin', 'registrar']:
        messages.error(request, "Access denied. You don't have permission to view this page.")
        return redirect('login')
    
    context = {
        # Add any report data here
    }
    
    return render(request, 'REGISTRARREPORTS.html', context)

@login_required
def registrar_user_management(request):
    """Render the registrar user management page"""
    if request.user.user_type not in ['admin', 'registrar']:
        messages.error(request, "Access denied. You don't have permission to view this page.")
        return redirect('login')
    
    # Get all users with related data
    users = User.objects.select_related('profile', 'alumni_profile', 'signatory_profile').all()
    
    # Get unique values for filters
    user_types = User.objects.values_list('user_type', flat=True).distinct()
    courses = StudentProfile.objects.values_list('program', flat=True).distinct()
    years = StudentProfile.objects.values_list('year_level', flat=True).distinct()
    
    context = {
        'users': users,
        'user_types': user_types,
        'courses': courses,
        'years': years,
    }
    
    return render(request, 'REGISTRARUSERMANAGEMENT.html', context)

@login_required
def registrar_profile(request):
    """Render the registrar profile page"""
    if request.user.user_type not in ['admin', 'registrar']:
        messages.error(request, "Access denied. You don't have permission to view this page.")
        return redirect('login')
    
    # Get or create registrar profile
    from landing.models import RegistrarProfile
    registrar_profile, created = RegistrarProfile.objects.get_or_create(user=request.user)
    
    # Split full name into first and last name
    full_name_parts = request.user.full_name.split(' ', 1)
    first_name = full_name_parts[0] if full_name_parts else ''
    last_name = full_name_parts[1] if len(full_name_parts) > 1 else ''
    
    context = {
        'user': request.user,
        'registrar_profile': registrar_profile,
        'first_name': first_name,
        'last_name': last_name,
    }
    
    return render(request, 'REGISTRARPROFILE.html', context)

@login_required
def registrar_profile_data_api(request):
    """API endpoint to get registrar profile data"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from landing.models import RegistrarProfile
        registrar_profile, created = RegistrarProfile.objects.get_or_create(user=request.user)
        
        # Split full name into first and last name
        full_name_parts = request.user.full_name.split(' ', 1)
        first_name = full_name_parts[0] if full_name_parts else ''
        last_name = full_name_parts[1] if len(full_name_parts) > 1 else ''
        
        profile_data = {
            'first_name': first_name,
            'last_name': last_name,
            'birthdate': registrar_profile.birthdate.strftime('%Y-%m-%d') if registrar_profile.birthdate else None,
            'gender': registrar_profile.gender,
            'position': registrar_profile.position,
            'department': registrar_profile.department,
            'address': registrar_profile.address,
            'email': request.user.email,
            'contact_number': request.user.contact_number,
            'office_location': registrar_profile.office_location,
            'office_hours': registrar_profile.office_hours,
            'bio': registrar_profile.bio,
            'profile_picture_url': registrar_profile.profile_picture_url
        }
        
        return JsonResponse({
            'success': True,
            'profile': profile_data
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def registrar_profile_update_api(request):
    """API endpoint to update registrar profile"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            import json
            data = json.loads(request.body)
            
            from landing.models import RegistrarProfile
            registrar_profile, created = RegistrarProfile.objects.get_or_create(user=request.user)
            
            # Update user fields
            if data.get('firstName') and data.get('lastName'):
                request.user.full_name = f"{data['firstName']} {data['lastName']}"
            
            if data.get('email'):
                request.user.email = data['email']
            
            if data.get('contactNumber'):
                request.user.contact_number = data['contactNumber']
            
            request.user.save()
            
            # Update registrar profile fields
            if data.get('birthdate'):
                registrar_profile.birthdate = data['birthdate']
            
            if data.get('gender'):
                registrar_profile.gender = data['gender']
            
            if data.get('position'):
                registrar_profile.position = data['position']
            
            if data.get('department'):
                registrar_profile.department = data['department']
            
            if data.get('address'):
                registrar_profile.address = data['address']
            
            if data.get('officeLocation'):
                registrar_profile.office_location = data['officeLocation']
            
            if data.get('officeHours'):
                registrar_profile.office_hours = data['officeHours']
            
            if data.get('bio'):
                registrar_profile.bio = data['bio']
            
            registrar_profile.save()
            
            return JsonResponse({
                'success': True,
                'message': 'Profile updated successfully'
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def registrar_profile_change_password_api(request):
    """API endpoint to change registrar password"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            import json
            data = json.loads(request.body)
            
            old_password = data.get('old_password')
            new_password = data.get('new_password')
            
            if not old_password or not new_password:
                return JsonResponse({'error': 'Both old and new passwords are required'}, status=400)
            
            # Verify old password
            if not request.user.check_password(old_password):
                return JsonResponse({'error': 'Current password is incorrect'}, status=400)
            
            # Validate new password
            if len(new_password) < 8:
                return JsonResponse({'error': 'New password must be at least 8 characters long'}, status=400)
            
            # Set new password
            request.user.set_password(new_password)
            request.user.save()
            
            return JsonResponse({
                'success': True,
                'message': 'Password changed successfully'
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def registrar_profile_upload_picture_api(request):
    """API endpoint to upload registrar profile picture"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            from landing.models import RegistrarProfile
            registrar_profile, created = RegistrarProfile.objects.get_or_create(user=request.user)
            
            if 'profile_picture' not in request.FILES:
                return JsonResponse({'error': 'No image file provided'}, status=400)
            
            profile_picture = request.FILES['profile_picture']
            
            # Validate file type
            if not profile_picture.content_type.startswith('image/'):
                return JsonResponse({'error': 'Please upload a valid image file'}, status=400)
            
            # Validate file size (max 5MB)
            if profile_picture.size > 5 * 1024 * 1024:
                return JsonResponse({'error': 'Image size should be less than 5MB'}, status=400)
            
            # Save the image
            registrar_profile.profile_picture = profile_picture
            registrar_profile.save()
            
            return JsonResponse({
                'success': True,
                'message': 'Profile picture uploaded successfully',
                'profile_picture_url': registrar_profile.profile_picture_url
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

# ========================================
# REGISTRAR PIN SETUP FUNCTIONS
# ========================================

@require_POST
@login_required
def registrar_set_pin(request):
    """Set PIN for registrar"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        pin = request.POST.get('pin')
        confirm_pin = request.POST.get('confirm_pin')
        
        if not pin or not confirm_pin:
            return JsonResponse({'error': 'PIN and confirmation required'}, status=400)
        
        if pin != confirm_pin:
            return JsonResponse({'error': 'PINs do not match'}, status=400)
        
        if len(pin) < 6:
            return JsonResponse({'error': 'PIN must be at least 6 characters'}, status=400)
        
        # Get or create registrar profile
        from landing.models import RegistrarProfile
        registrar_profile, created = RegistrarProfile.objects.get_or_create(
            user=request.user,
            defaults={'position': 'Registrar'}  # Default position
        )
        
        # In a real implementation, you'd hash the PIN
        # For now, we'll store it as is (you should implement proper hashing)
        registrar_profile.pin = pin
        registrar_profile.pin_set = True
        registrar_profile.force_password_change = False
        registrar_profile.save()
        
        return JsonResponse({'success': True, 'message': 'PIN set successfully'})
        
    except Exception as e:
        print(f"Error in registrar_set_pin: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@require_POST
@login_required
def registrar_change_pin(request):
    """Change PIN for registrar"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        current_pin = request.POST.get('currentPin')
        new_pin = request.POST.get('newPin')
        confirm_pin = request.POST.get('confirmPin')
        
        if not current_pin or not new_pin or not confirm_pin:
            return JsonResponse({'error': 'All PIN fields are required'}, status=400)
        
        if new_pin != confirm_pin:
            return JsonResponse({'error': 'New PIN and confirmation do not match'}, status=400)
        
        if len(new_pin) < 6:
            return JsonResponse({'error': 'New PIN must be at least 6 characters'}, status=400)
        
        # Get registrar profile
        from landing.models import RegistrarProfile
        try:
            registrar_profile = RegistrarProfile.objects.get(user=request.user)
        except RegistrarProfile.DoesNotExist:
            return JsonResponse({'error': 'Registrar profile not found'}, status=404)
        
        # Verify current PIN
        if not registrar_profile.pin:
            return JsonResponse({'error': 'No PIN is currently set. Please contact administrator.'}, status=400)
        
        # For now, direct comparison (should implement proper hashing in production)
        if registrar_profile.pin != current_pin:
            return JsonResponse({'error': 'Current PIN is incorrect'}, status=400)
        
        # Update to new PIN
        registrar_profile.pin = new_pin
        registrar_profile.save()
        
        return JsonResponse({'success': True, 'message': 'PIN changed successfully'})
        
    except Exception as e:
        print(f"Error in registrar_change_pin: {e}")
        return JsonResponse({'error': 'An error occurred while changing PIN'}, status=500)


@require_POST
@login_required
def registrar_verify_pin(request):
    """Verify PIN for registrar"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        pin = request.POST.get('pin')
        
        if not pin:
            return JsonResponse({'error': 'PIN required'}, status=400)
        
        registrar_profile = getattr(request.user, 'registrar_profile', None)
        if not registrar_profile or not registrar_profile.pin_set:
            return JsonResponse({'error': 'PIN not set'}, status=400)
        
        # Verify PIN (in production, implement proper hashing)
        if pin == registrar_profile.pin:
            return JsonResponse({'success': True})
        else:
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
    except Exception as e:
        print(f"Error in registrar_verify_pin: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def registrar_check_setup_status(request):
    """Check if registrar needs first-time setup"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        registrar_profile = getattr(request.user, 'registrar_profile', None)
        
        # Check if setup is required
        requires_setup = (
            registrar_profile is None or 
            registrar_profile.force_password_change or 
            not registrar_profile.pin_set
        )
        
        return JsonResponse({'requires_setup': requires_setup})
        
    except Exception as e:
        print(f"Error in registrar_check_setup_status: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@require_POST
@login_required
def registrar_change_password(request):
    """Change password for registrar"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        current_password = request.POST.get('current_password')
        new_password = request.POST.get('new_password')
        confirm_password = request.POST.get('confirm_password')
        
        if not current_password or not new_password or not confirm_password:
            return JsonResponse({'error': 'All fields are required'}, status=400)
        
        if new_password != confirm_password:
            return JsonResponse({'error': 'New passwords do not match'}, status=400)
        
        if len(new_password) < 8:
            return JsonResponse({'error': 'Password must be at least 8 characters'}, status=400)
        
        # Check current password
        from django.contrib.auth import authenticate
        user = authenticate(username=request.user.username, password=current_password)
        if not user:
            return JsonResponse({'error': 'Current password is incorrect'}, status=400)
        
        # Set new password
        request.user.set_password(new_password)
        request.user.save()
        
        # Update registrar profile to mark password as changed
        from landing.models import RegistrarProfile
        registrar_profile, created = RegistrarProfile.objects.get_or_create(
            user=request.user,
            defaults={'position': 'Registrar'}
        )
        registrar_profile.force_password_change = False
        registrar_profile.save()
        
        return JsonResponse({'success': True, 'message': 'Password changed successfully'})
        
    except Exception as e:
        print(f"Error in registrar_change_password: {e}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def registrar_messages(request):
    """Render the registrar messages page"""
    if request.user.user_type not in ['admin', 'registrar']:
        messages.error(request, "Access denied. You don't have permission to view this page.")
        return redirect('login')
    
    context = {
        # Add message data here
    }
    
    return render(request, 'REGISTRARMESSAGES.html', context)

@login_required
def dashboard_data_api(request):
    """API endpoint to get dashboard data for AJAX refresh"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from datetime import datetime, timezone as dt_timezone, timedelta
        import json
        
        # Get current date and calculate date ranges
        today = timezone.now().date()
        last_week = today - timedelta(days=7)
        
        # Basic statistics
        total_clearance_requests = ClearanceForm.objects.count()
        pending_clearance_requests = ClearanceForm.objects.filter(status='pending').count()
        total_enrollment_requests = EnrollmentForm.objects.count()
        pending_enrollment_requests = EnrollmentForm.objects.filter(status='pending').count()
        total_graduation_requests = GraduationForm.objects.count()
        pending_graduation_requests = GraduationForm.objects.filter(status='pending').count()
        total_document_requests = DocumentRequest.objects.count()
        pending_document_requests = DocumentRequest.objects.filter(status='pending').count()
        
        # Pending signatures - Only count signatories that are actually pending for approval
        pending_signatures_count = ClearanceSignatory.objects.filter(
            status='pending',
            clearance__status='pending'  # Only count if the clearance form is still pending
        ).count()
        
        new_signatures_today = ClearanceSignatory.objects.filter(
            updated_at__date=today,
            status='pending'
        ).count()
        
        # Disapproved forms
        disapproved_forms_count = (
            ClearanceForm.objects.filter(status='disapproved').count() +
            EnrollmentForm.objects.filter(status='rejected').count() +
            GraduationForm.objects.filter(status='rejected').count() +
            DocumentRequest.objects.filter(status='rejected').count()
        )
        
        recently_disapproved = (
            ClearanceForm.objects.filter(status='disapproved', submitted_at__date__gte=last_week).count() +
            EnrollmentForm.objects.filter(status='rejected', created_at__date__gte=last_week).count() +
            GraduationForm.objects.filter(status='rejected', created_at__date__gte=last_week).count()
        )
        
        # Chart data for last 7 days
        chart_dates = []
        accomplishment_data = []
        visitors_data = []
        documents_data = []
        
        for i in range(7):
            date = today - timedelta(days=6-i)
            chart_dates.append(date.strftime('%b %d'))
            
            daily_clearance = ClearanceForm.objects.filter(status='approved', submitted_at__date=date).count()
            daily_enrollment = EnrollmentForm.objects.filter(status='approved', created_at__date=date).count()
            daily_graduation = GraduationForm.objects.filter(status='approved', created_at__date=date).count()
            daily_documents = DocumentRequest.objects.filter(status='released', created_at__date=date).count()
            accomplishment_data.append(daily_clearance + daily_enrollment + daily_graduation + daily_documents)
            
            daily_visitors = (
                ClearanceForm.objects.filter(submitted_at__date=date).count() +
                EnrollmentForm.objects.filter(created_at__date=date).count() +
                GraduationForm.objects.filter(created_at__date=date).count() +
                DocumentRequest.objects.filter(created_at__date=date).count()
            )
            visitors_data.append(daily_visitors)
            documents_data.append(daily_documents)
        
        # Recent activity
        recent_activity = []
        
        # Get recent clearance forms
        recent_clearance = ClearanceForm.objects.order_by('-submitted_at')[:5]
        for clearance in recent_clearance:
            recent_activity.append({
                'type': 'clearance',
                'title': f'Clearance Form #{clearance.id}',
                'status': clearance.status,
                'date': clearance.submitted_at.strftime('%Y-%m-%d %H:%M'),
                'user': clearance.student.full_name if clearance.student else 'Unknown'
            })
        
        # Get recent enrollment forms
        recent_enrollment = EnrollmentForm.objects.order_by('-created_at')[:5]
        for enrollment in recent_enrollment:
            recent_activity.append({
                'type': 'enrollment',
                'title': f'Enrollment Form #{enrollment.id}',
                'status': enrollment.status,
                'date': enrollment.created_at.strftime('%Y-%m-%d %H:%M'),
                'user': enrollment.user.full_name if enrollment.user else 'Unknown'
            })
        
        # Get recent graduation forms
        recent_graduation = GraduationForm.objects.order_by('-created_at')[:5]
        for graduation in recent_graduation:
            recent_activity.append({
                'type': 'graduation',
                'title': f'Graduation Form #{graduation.id}',
                'status': graduation.status,
                'date': graduation.created_at.strftime('%Y-%m-%d %H:%M'),
                'user': graduation.user.full_name if graduation.user else 'Unknown'
            })
        
        # Get recent document requests
        recent_documents = DocumentRequest.objects.order_by('-created_at')[:5]
        for document in recent_documents:
            recent_activity.append({
                'type': 'document',
                'title': f'Document Request: {document.document_type}',
                'status': document.status,
                'date': document.created_at.strftime('%Y-%m-%d %H:%M'),
                'user': document.student.full_name if document.student else 'Unknown'
            })
        
        # Sort by date and take top 10
        recent_activity.sort(key=lambda x: x['date'], reverse=True)
        recent_activity = recent_activity[:10]
        
        # Get upcoming calendar events from database
        try:
            from landing.models import CalendarEvent
            next_week = today + timedelta(days=7)
            calendar_events = CalendarEvent.objects.filter(
                start_date__gte=today,
                start_date__lte=next_week
            ).order_by('start_date', 'start_time')[:10]
            
            upcoming_events = []
            for event in calendar_events:
                upcoming_events.append({
                    'time': event.display_time,
                    'title': event.title,
                    'color': event.color,
                    'date': event.start_date.strftime('%Y-%m-%d'),
                    'is_holiday': False
                })
        except ImportError:
            # Fallback if CalendarEvent model doesn't exist
            upcoming_events = []
        
        
        response_data = {
            'statistics': {
                'total_clearance_requests': total_clearance_requests,
                'pending_clearance_requests': pending_clearance_requests,
                'total_enrollment_requests': total_enrollment_requests,
                'pending_enrollment_requests': pending_enrollment_requests,
                'total_graduation_requests': total_graduation_requests,
                'pending_graduation_requests': pending_graduation_requests,
                'total_document_requests': total_document_requests,
                'pending_document_requests': pending_document_requests,
                'pending_signatures_count': pending_signatures_count,
                'new_signatures_today': new_signatures_today,
                'disapproved_forms_count': disapproved_forms_count,
                'recently_disapproved': recently_disapproved,
            },
            'charts': {
                'accomplishment': {
                    'categories': chart_dates,
                    'series': [{'name': 'Accomplishment', 'data': accomplishment_data}]
                },
                'visitors': {
                    'categories': chart_dates,
                    'series': [{'name': 'Visitors', 'data': visitors_data}]
                },
                'documents': {
                    'categories': chart_dates,
                    'series': [{'name': 'Documents Released', 'data': documents_data}]
                }
            },
            'recent_activity': recent_activity,
            'upcoming_events': upcoming_events
        }
        
        return JsonResponse(response_data)
        
    except Exception as e:
        # Return error response instead of crashing
        import traceback
        print(f"Dashboard API Error: {str(e)}")
        print(traceback.format_exc())
        
        return JsonResponse({
            'error': f'Dashboard data error: {str(e)}',
            'statistics': {
                'total_clearance_requests': 0,
                'pending_clearance_requests': 0,
                'total_enrollment_requests': 0,
                'pending_enrollment_requests': 0,
                'total_graduation_requests': 0,
                'pending_graduation_requests': 0,
                'total_document_requests': 0,
                'pending_document_requests': 0,
                'pending_signatures_count': 0,
                'new_signatures_today': 0,
                'disapproved_forms_count': 0,
                'recently_disapproved': 0,
            },
            'charts': {
                'accomplishment': {'categories': [], 'series': [{'name': 'Accomplishment', 'data': []}]},
                'visitors': {'categories': [], 'series': [{'name': 'Visitors', 'data': []}]},
                'documents': {'categories': [], 'series': [{'name': 'Documents Released', 'data': []}]}
            },
            'recent_activity': [],
            'upcoming_events': []
        }, status=500)

# Calendar Event Management Views
@login_required
def calendar_events_api(request):
    """API endpoint to get calendar events for a specific month"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    from datetime import datetime, timezone as dt_timezone, date, timedelta
    
    year = int(request.GET.get('year', timezone.now().year))
    month = int(request.GET.get('month', timezone.now().month))
    
    from landing.models import CalendarEvent
    
    # Get events for the specified month
    start_date = date(year, month, 1)
    if month == 12:
        end_date = date(year + 1, 1, 1) - timedelta(days=1)
    else:
        end_date = date(year, month + 1, 1) - timedelta(days=1)
    
    events = CalendarEvent.objects.filter(
        start_date__gte=start_date,
        start_date__lte=end_date
    ).order_by('start_date', 'start_time')
    
    events_data = []
    for event in events:
        events_data.append({
            'id': str(event.id),
            'title': event.title,
            'description': event.description,
            'start_date': event.start_date.strftime('%Y-%m-%d'),
            'start_time': event.start_time.strftime('%H:%M') if event.start_time else None,
            'end_date': event.end_date.strftime('%Y-%m-%d') if event.end_date else None,
            'end_time': event.end_time.strftime('%H:%M') if event.end_time else None,
            'is_all_day': event.is_all_day,
            'color': event.color,
            'event_type': event.event_type,
            'is_holiday': event.is_holiday,
            'created_by': event.created_by.full_name
        })
    
    return JsonResponse({'events': events_data})

def create_google_calendar_url(event_data):
    """Create a Google Calendar URL for adding an event"""
    base_url = "https://calendar.google.com/calendar/render"
    
    # Format dates and times
    start_date = event_data['start_date']
    start_time = event_data.get('start_time', '')
    end_date = event_data.get('end_date', start_date)
    end_time = event_data.get('end_time', '')
    
    # Create start and end datetime strings
    if start_time:
        start_datetime = f"{start_date}T{start_time}:00"
        if end_time:
            end_datetime = f"{end_date}T{end_time}:00"
        else:
            # If no end time, make it 1 hour later
            end_datetime = f"{start_date}T{start_time}:00"
    else:
        # All day event
        start_datetime = start_date
        end_datetime = end_date
    
    # Build the URL parameters
    params = {
        'action': 'TEMPLATE',
        'text': event_data['title'],
        'dates': f"{start_datetime}/{end_datetime}",
        'details': event_data.get('description', ''),
        'location': 'School Registrar Office',
        'sf': 'true',
        'output': 'xml'
    }
    
    # Convert to URL query string
    query_string = '&'.join([f"{k}={v}" for k, v in params.items()])
    return f"{base_url}?{query_string}"

@login_required
def add_calendar_event(request):
    """Add a new calendar event and create Google Calendar link"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            from landing.models import CalendarEvent
            from datetime import datetime, timezone as dt_timezone
            
            # Create the event in our database
            event = CalendarEvent.objects.create(
                title=data['title'],
                description=data.get('description', ''),
                start_date=datetime.strptime(data['start_date'], '%Y-%m-%d').date(),
                start_time=datetime.strptime(data['start_time'], '%H:%M').time() if data.get('start_time') else None,
                end_date=datetime.strptime(data['end_date'], '%Y-%m-%d').date() if data.get('end_date') else None,
                end_time=datetime.strptime(data['end_time'], '%H:%M').time() if data.get('end_time') else None,
                event_type=data.get('event_type', 'event'),
                color=data.get('color', 'blue'),
                is_all_day=data.get('is_all_day', False),
                is_holiday=data.get('is_holiday', False),
                created_by=request.user
            )
            
            # Create Google Calendar URL
            google_calendar_url = create_google_calendar_url(data)
            
            return JsonResponse({
                'success': True,
                'event_id': str(event.id),
                'google_calendar_url': google_calendar_url,
                'message': 'Event added successfully! Click the link to add it to Google Calendar.'
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=400)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def edit_calendar_event(request, event_id):
    """Edit an existing calendar event"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from landing.models import CalendarEvent
        event = CalendarEvent.objects.get(id=event_id)
    except CalendarEvent.DoesNotExist:
        return JsonResponse({'error': 'Event not found'}, status=404)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            from datetime import datetime, timezone as dt_timezone
            
            event.title = data['title']
            event.description = data.get('description', '')
            event.event_type = data.get('event_type', 'event')
            event.color = data.get('color', 'blue')
            event.start_date = datetime.strptime(data['start_date'], '%Y-%m-%d').date()
            event.start_time = datetime.strptime(data['start_time'], '%H:%M').time() if data.get('start_time') else None
            event.end_date = datetime.strptime(data['end_date'], '%Y-%m-%d').date() if data.get('end_date') else None
            event.end_time = datetime.strptime(data['end_time'], '%H:%M').time() if data.get('end_time') else None
            event.is_all_day = data.get('is_all_day', False)
            event.is_holiday = data.get('is_holiday', False)
            event.save()
            
            return JsonResponse({'success': True})
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=400)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def delete_calendar_event(request, event_id):
    """Delete a calendar event"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from landing.models import CalendarEvent
        event = CalendarEvent.objects.get(id=event_id)
        event.delete()
        return JsonResponse({'success': True})
    except CalendarEvent.DoesNotExist:
        return JsonResponse({'error': 'Event not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=400)

@login_required
def user_management_data_api(request):
    """API endpoint to get user data for AJAX requests"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get filter parameters
        user_type_filter = request.GET.get('user_type')
        course_filter = request.GET.get('course')
        year_filter = request.GET.get('year')
        status_filter = request.GET.get('status')
        search_query = request.GET.get('search')
        
        # Build query
        users = User.objects.select_related('profile', 'alumni_profile', 'signatory_profile', 'registrar_profile', 'business_manager_profile').all()
        
        if user_type_filter:
            users = users.filter(user_type=user_type_filter)
        if course_filter:
            users = users.filter(profile__program=course_filter)
        if year_filter:
            try:
                year_value = int(year_filter)
                users = users.filter(profile__year_level=year_value)
            except (ValueError, TypeError):
                # If year_filter is not a valid integer, skip this filter
                pass
        if status_filter:
            if status_filter == 'active':
                users = users.filter(is_active=True)
            elif status_filter == 'inactive':
                users = users.filter(is_active=False)
        if search_query:
            users = users.filter(
                Q(full_name__icontains=search_query) |
                Q(email__icontains=search_query) |
                Q(username__icontains=search_query) |
                Q(contact_number__icontains=search_query)
            )
        
        # Prepare user data
        user_data = []
        for user in users:
            user_info = {
                'id': str(user.id),
                'username': user.username,
                'full_name': user.full_name,
                'email': user.email or '',
                'contact_number': user.contact_number or '',
                'user_type': user.get_user_type_display(),
                'status': 'Active' if user.is_active else 'Inactive',
                'created_at': user.created_at.strftime('%Y-%m-%d %H:%M'),
                'last_login': user.last_login.strftime('%Y-%m-%d %H:%M') if user.last_login else 'Never',
                'profile_picture': '/static/images/default-profile.png',
                'course': '',
                'year': '',
                'section': '',
                'address': '',
                'gender': '',
                'birthdate': '',
                'notes': ''
            }
            
            # Add profile-specific data
            if user.user_type == 'student' and hasattr(user, 'profile'):
                profile = user.profile
                user_info.update({
                    'profile_picture': profile.profile_picture_url,
                    'course': profile.program,
                    'year': f"{profile.year_level}rd Year" if profile.year_level == 3 else f"{profile.year_level}nd Year" if profile.year_level == 2 else f"{profile.year_level}st Year",
                    'address': profile.address or '',
                    'gender': profile.gender or '',
                    'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile.birthdate else '',
                    'notes': f"Student Number: {profile.student_number}"
                })
            elif user.user_type == 'alumni' and hasattr(user, 'alumni_profile'):
                profile = user.alumni_profile
                user_info.update({
                    'profile_picture': profile.profile_picture_url,
                    'course': profile.course_graduated,
                    'year': profile.year_graduated,
                    'address': profile.address or '',
                    'gender': profile.gender or '',
                    'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile.birthdate else '',
                    'notes': f"Alumni ID: {profile.alumni_id}, Graduated: {profile.year_graduated}"
                })
            elif user.user_type == 'signatory':
                # For signatories, check for business manager profile first, then regular signatory profile
                if hasattr(user, 'business_manager_profile'):
                    # Business manager signatories
                    profile = user.business_manager_profile
                    user_info.update({
                        'profile_picture': profile.profile_picture_url,
                        'course': profile.position or 'Business Manager',
                        'year': profile.department or '',
                        'address': profile.address or '',
                        'gender': profile.gender or '',
                        'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile.birthdate else '',
                        'notes': f"Position: {profile.position or 'Business Manager'}" + (f", Department: {profile.department}" if profile.department else "") + (f", Notes: {profile.bio}" if profile.bio else "")
                    })
                elif hasattr(user, 'signatory_profile'):
                    # Regular signatories
                    profile = user.signatory_profile
                    user_info.update({
                        'profile_picture': profile.profile_picture_url,
                        'course': profile.get_signatory_type_display(),
                        'year': profile.department or '',
                        'address': profile.address or '',
                        'gender': profile.gender or '',
                        'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile.birthdate else '',
                        'notes': f"Signatory Type: {profile.get_signatory_type_display()}" + (f", Department: {profile.department}" if profile.department else "") + (f", Notes: {profile.notes}" if profile.notes else "")
                    })
                else:
                    user_info.update({
                        'profile_picture': '/static/images/default-profile.png',
                        'notes': f"Role: {user.get_user_type_display()}"
                    })
            else:
                # For admin, business_manager - check if admin has registrar_profile
                if user.user_type == 'admin' and hasattr(user, 'registrar_profile'):
                    # This is a registrar (admin with registrar profile)
                    profile = user.registrar_profile
                    user_info.update({
                        'profile_picture': profile.profile_picture_url,
                        'course': profile.position or '',
                        'year': profile.department or '',
                        'address': profile.address or '',
                        'gender': profile.gender or '',
                        'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile.birthdate else '',
                        'notes': f"Position: {profile.position}" + (f", Department: {profile.department}" if profile.department else "") + (f", Notes: {profile.bio}" if profile.bio else "")
                    })
                else:
                    # Regular admin or business manager
                    user_info['profile_picture'] = '/static/images/default-profile.png'
                    user_info['notes'] = f"Role: {user.get_user_type_display()}"
            
            user_data.append(user_info)
        
        return JsonResponse({
            'users': user_data,
            'total_count': len(user_data),
            'success': True
        })
        
    except Exception as e:
        return JsonResponse({
            'error': str(e),
            'users': [],
            'total_count': 0,
            'success': False
        }, status=500)

@login_required
def create_user_api(request):
    """API endpoint to create a new user"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        
        # Validate required fields
        required_fields = ['username', 'full_name', 'user_type', 'email']
        for field in required_fields:
            if not data.get(field):
                return JsonResponse({'error': f'{field} is required'}, status=400)
        
        print(f"DEBUG: About to create user with username: '{data['username']}' and email: '{data.get('email', '').strip()}'")
        
        # Check for existing users BEFORE starting transaction
        # Check if username already exists
        existing_username = User.objects.filter(username=data['username']).first()
        if existing_username:
            print(f"DEBUG: Username '{data['username']}' already exists - User: {existing_username.full_name} (ID: {existing_username.id})")
            return JsonResponse({'error': f'Username already exists (used by {existing_username.full_name})'}, status=400)
        
        # Check if the email is already being used as a username by another user
        existing_user_with_email_as_username = User.objects.filter(username=data.get('email', '').strip()).first()
        if existing_user_with_email_as_username:
            print(f"DEBUG: Email '{data.get('email', '').strip()}' is already being used as username by user: {existing_user_with_email_as_username.full_name}")
            return JsonResponse({'error': f'Email is already being used as username by another user ({existing_user_with_email_as_username.full_name})'}, status=400)
        
        # Check if email already exists
        if data.get('email') and data['email'].strip() and data['email'].strip() != data['username']:
            existing_email = User.objects.filter(email=data['email'].strip()).first()
            if existing_email:
                print(f"DEBUG: Email '{data['email'].strip()}' already exists - User: {existing_email.full_name} (ID: {existing_email.id})")
                return JsonResponse({'error': f'Email already exists (used by {existing_email.full_name})'}, status=400)
        
        # Always auto-generate password
        import secrets
        import string
        # Generate a secure 12-character password with letters, numbers, and symbols
        alphabet = string.ascii_letters + string.digits + "!@#$%^&*"
        generated_password = ''.join(secrets.choice(alphabet) for i in range(12))
        data['password'] = generated_password
        
        # Use database transaction to prevent race conditions during user creation
        try:
            with transaction.atomic():
                # Double-check for race conditions inside transaction
                if User.objects.select_for_update().filter(username=data['username']).exists():
                    raise IntegrityError(f"Username '{data['username']}' was just taken by another user.")
                
                # Create user
                user = User.objects.create_user(
                    username=data['username'],
                    email=data.get('email', '').strip() or '',  # Use empty string if email is empty or None
                    full_name=data['full_name'],
                    user_type=data['user_type'],
                    contact_number=data.get('contact_number', ''),
                    is_active=data.get('is_active', True)
                )
                
                # Set password
                user.set_password(data['password'])
                user.save()
                
                print(f"DEBUG: User created successfully - ID: {user.id}, Username: {user.username}")
            
                # Create profile based on user type
                if data['user_type'] == 'student':
                    # Generate a unique student number if not provided
                    student_number = data.get('student_number', '').strip()
                    if not student_number:
                        # Generate a unique student number based on timestamp
                        import time
                        student_number = f"STU{int(time.time())}"
                    
                    StudentProfile.objects.create(
                        user=user,
                        student_number=student_number,
                        program=data.get('program', ''),
                        year_level=data.get('year_level', 1),
                        address=data.get('address', ''),
                        gender=data.get('gender', ''),
                        birthdate=data.get('birthdate'),
                        is_graduating=data.get('is_graduating', False)
                    )
                    print(f"DEBUG: StudentProfile created successfully for user {user.id}")
                elif data['user_type'] == 'alumni':
                    # Generate a unique alumni ID if not provided
                    alumni_id = data.get('alumni_id', '').strip()
                    if not alumni_id:
                        # Generate a unique alumni ID based on timestamp
                        import time
                        alumni_id = f"ALM{int(time.time())}"
                    
                    AlumniProfile.objects.create(
                        user=user,
                        alumni_id=alumni_id,
                        course_graduated=data.get('course_graduated', ''),
                        year_graduated=data.get('year_graduated', ''),
                        address=data.get('address', ''),
                        gender=data.get('gender', ''),
                        birthdate=data.get('birthdate')
                    )
                    print(f"DEBUG: AlumniProfile created successfully for user {user.id}")
                elif data['user_type'] == 'signatory':
                    # Create SignatoryProfile for signatory users
                    SignatoryProfile.objects.create(
                        user=user,
                        signatory_type=data.get('signatory_type', ''),
                        department=data.get('department', ''),
                        notes=data.get('notes', ''),
                        address=data.get('address', ''),
                        gender=data.get('gender', ''),
                        birthdate=data.get('birthdate')
                    )
                    print(f"DEBUG: SignatoryProfile created successfully for user {user.id}")
                    
                    # Log the signatory creation with details
                    AuditLog.objects.create(
                        user=request.user,
                        action_type='create_signatory',
                        description=f'Created signatory user: {data["full_name"]} - Type: {data.get("signatory_type", "")} - Department: {data.get("department", "")}'
                    )
                    
        except IntegrityError as e:
            print(f"DEBUG: IntegrityError creating user: {str(e)}")
            if 'username' in str(e):
                return JsonResponse({'error': f'Username "{data["username"]}" is already taken. Please choose a different username.'}, status=400)
            elif 'email' in str(e):
                return JsonResponse({'error': f'Email "{data.get("email", "")}" is already being used. Please choose a different email.'}, status=400)
            else:
                return JsonResponse({'error': 'A user with these details already exists. Please try different values.'}, status=400)
        except Exception as e:
            print(f"DEBUG: Error in transaction: {str(e)}")
            import traceback
            traceback.print_exc()
            return JsonResponse({'error': f'Error creating user: {str(e)}'}, status=500)
        
        # Log the action
        try:
            AuditLog.objects.create(
                user=request.user,
                action_type='create_user',
                description=f'Created new {data["user_type"]} user: {data["full_name"]}'
            )
        except Exception as e:
            print(f"DEBUG: Error creating audit log: {str(e)}")
            # Don't fail the entire request if audit log fails
            pass
        
        response_data = {
            'success': True,
            'message': 'User created successfully',
            'user_id': str(user.id),
            'username': data['username'],
            'full_name': data['full_name']
        }
        
        # Send auto-generated password via email
        try:
            from django.core.mail import send_mail
            from django.conf import settings
            from django.template.loader import render_to_string
            
            # Prepare email context
            email_context = {
                'user_name': data['full_name'],
                'email': user.email,
                'username': user.username, 
                'password': generated_password,
                'user_type': data['user_type'].title(),
                'login_url': request.build_absolute_uri('/login/')
            }
            
            # Render email template
            html_message = render_to_string('emails/new_user_credentials.html', email_context)
            plain_message = f"""
Welcome to PTS College and Advanced Studies!

Dear {data['full_name']},

Your account has been created successfully. Here are your login credentials:

Email: {user.email}
Password: {generated_password}

Please log in at: {request.build_absolute_uri('/login/')}

For security reasons, we recommend changing your password after your first login.

Best regards,
Office of the Registrar
PTS College and Advanced Studies
"""
            
            send_mail(
                subject='Welcome to PTS College - Your Account Credentials',
                message=plain_message,
                html_message=html_message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[user.email],
                fail_silently=False
            )
            
            print(f"✅ Credentials email sent to {user.email}")
            response_data['message'] = f'User created successfully. Login credentials have been sent to {user.email}'
            
        except Exception as e:
            print(f"❌ Error sending credentials email: {e}")
            response_data['message'] = f'User created successfully, but failed to send email. Please provide credentials manually.'
        
        return JsonResponse(response_data)
        
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON data'}, status=400)
    except Exception as e:
        import traceback
        print(f"DEBUG: Exception in create_user_api: {str(e)}")
        print(f"DEBUG: Exception type: {type(e).__name__}")
        print(f"DEBUG: Full traceback:")
        traceback.print_exc()
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def delete_user_api(request, user_id):
    """API endpoint to delete a user"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'DELETE':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Prevent self-deletion
        if str(request.user.id) == user_id:
            return JsonResponse({'error': 'Cannot delete your own account'}, status=400)
        
        user = User.objects.get(id=user_id)
        user_name = user.full_name
        user_type = user.user_type
        
        # Delete the user (this will cascade to related profiles)
        user.delete()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='delete_user',
            description=f'Deleted {user_type} user: {user_name}'
        )
        
        return JsonResponse({
            'success': True,
            'message': 'User deleted successfully'
        })
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def get_user_details_api(request, user_id):
    """API endpoint to get detailed user information"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        user = User.objects.select_related('profile', 'alumni_profile', 'signatory_profile', 'registrar_profile').get(id=user_id)
        
        user_data = {
            'id': str(user.id),
            'username': user.username,
            'full_name': user.full_name,
            'email': user.email or '',
            'contact_number': user.contact_number or '',
            'user_type': user.user_type,
            'user_type_display': user.get_user_type_display(),
            'is_active': user.is_active,
            'created_at': user.created_at.strftime('%Y-%m-%d %H:%M'),
            'last_login': user.last_login.strftime('%Y-%m-%d %H:%M') if user.last_login else 'Never',
            'profile_picture': '/static/images/default-profile.png',
            'course': '',
            'year': '',
            'section': '',
            'address': '',
            'gender': '',
            'birthdate': '',
            'notes': ''
        }
        
        # Add profile-specific data
        if user.user_type == 'student' and hasattr(user, 'profile'):
            profile = user.profile
            user_data.update({
                'profile_picture': profile.profile_picture_url,
                'course': profile.program,
                'year': profile.year_level,
                'address': profile.address or '',
                'gender': profile.gender or '',
                'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile.birthdate else '',
                'notes': f"Student Number: {profile.student_number}",
                'is_graduating': profile.is_graduating
            })
        elif user.user_type == 'alumni' and hasattr(user, 'alumni_profile'):
            profile = user.alumni_profile
            user_data.update({
                'profile_picture': profile.profile_picture_url,
                'course': profile.course_graduated,
                'year': profile.year_graduated,
                'address': profile.address or '',
                'gender': profile.gender or '',
                'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile.birthdate else '',
                'notes': f"Alumni ID: {profile.alumni_id}, Graduated: {profile.year_graduated}"
            })
        elif user.user_type == 'signatory':
            # For signatories, display signatory profile information
            if hasattr(user, 'signatory_profile'):
                profile = user.signatory_profile
                user_data.update({
                    'profile_picture': profile.profile_picture_url,
                    'course': profile.get_signatory_type_display(),
                    'year': profile.department or '',
                    'address': profile.address or '',
                    'gender': profile.gender or '',
                    'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile.birthdate else '',
                    'notes': f"Signatory Type: {profile.get_signatory_type_display()}" + (f", Department: {profile.department}" if profile.department else "") + (f", Notes: {profile.notes}" if profile.notes else "")
                })
            else:
                user_data.update({
                    'profile_picture': '/static/images/default-profile.png',
                    'notes': f"Role: {user.get_user_type_display()}"
                })
        else:
            # For admin, business_manager - check if admin has registrar_profile
            if user.user_type == 'admin' and hasattr(user, 'registrar_profile'):
                # This is a registrar (admin with registrar profile)
                profile = user.registrar_profile
                user_data.update({
                    'profile_picture': profile.profile_picture_url,
                    'course': profile.position or '',
                    'year': profile.department or '',
                    'address': profile.address or '',
                    'gender': profile.gender or '',
                    'birthdate': profile.birthdate.strftime('%Y-%m-%d') if profile.birthdate else '',
                    'notes': f"Position: {profile.position}" + (f", Department: {profile.department}" if profile.department else "") + (f", Notes: {profile.bio}" if profile.bio else "")
                })
            else:
                # Regular admin or business manager
                user_data['profile_picture'] = '/static/images/default-profile.png'
                user_data['notes'] = f"Role: {user.get_user_type_display()}"
        
        return JsonResponse(user_data)
        
    except User.DoesNotExist:
        return JsonResponse({'error': 'User not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


# ========================================
# SIGNATORY VIEWS
# ========================================

@login_required
def signatory_dashboard(request):
    """Signatory Dashboard View"""
    if request.user.user_type != 'signatory':
        return redirect('login')
    
    try:
        # Get signatory profile
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        
        # Get pending clearance requests for this signatory
        pending_clearances = ClearanceSignatory.objects.filter(
            signatory=request.user,
            status='pending'
        ).count()
        
        # Get pending enrollment requests for this signatory
        pending_enrollments = EnrollmentSignatory.objects.filter(
            signatory=request.user,
            status='pending'
        ).count()
        
        # Get pending graduation requests for this signatory
        pending_graduations = GraduationSignatory.objects.filter(
            signatory=request.user,
            status='pending'
        ).count()
        
        context = {
            'signatory_profile': signatory_profile,
            'pending_clearances': pending_clearances,
            'pending_enrollments': pending_enrollments,
            'pending_graduations': pending_graduations,
        }
        
        return render(request, 'SIGNATORYDASHBOARD.html', context)
        
    except Exception as e:
        print(f"Error in signatory_dashboard: {e}")
        return render(request, 'SIGNATORYDASHBOARD.html', {})


@login_required
def signatory_clearance(request):
    """Signatory Clearance View"""
    if request.user.user_type != 'signatory':
        return redirect('login')
    
    try:
        # Get signatory profile
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        
        context = {
            'signatory_profile': signatory_profile,
        }
        
        return render(request, 'SIGNATORYCLEARANCE.html', context)
        
    except Exception as e:
        print(f"Error in signatory_clearance: {e}")
        return render(request, 'SIGNATORYCLEARANCE.html', {})


@login_required
def signatory_enrollment(request):
    """Signatory Enrollment View - Only for Academic Dean"""
    if request.user.user_type != 'signatory':
        return redirect('login')
    
    try:
        # Check if user is Academic Dean
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        if not signatory_profile or signatory_profile.signatory_type != 'academic_dean':
            messages.error(request, "Access denied. Only Academic Dean can access enrollment forms.")
            return redirect('signatory_dashboard')
        
        context = {
            'signatory_profile': signatory_profile,
        }
        
        return render(request, 'SIGNATORYENROLLMENT.html', context)
        
    except Exception as e:
        print(f"Error in signatory_enrollment: {e}")
        return render(request, 'SIGNATORYENROLLMENT.html', {})


@login_required
def signatory_enrollment_data_api(request):
    """API endpoint to get enrollment data for signatory"""
    print(f"Enrollment API called by user: {request.user.full_name}, type: {request.user.user_type}")
    
    if request.user.user_type != 'signatory':
        print("Access denied: User is not a signatory")
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        print(f"Signatory profile: {signatory_profile}")
        if signatory_profile:
            print(f"Signatory type: {signatory_profile.signatory_type}")
        
        course_filter = request.GET.get('course', '')
        year_filter = request.GET.get('year', '')
        section_filter = request.GET.get('section', '')
        status_filter = request.GET.get('status', '')
        search_query = request.GET.get('search', '')
        
        print(f"Filters: course={course_filter}, year={year_filter}, section={section_filter}, status={status_filter}, search={search_query}")
        
        enrollment_forms = EnrollmentForm.objects.all().select_related('user__profile')
        print(f"Total enrollment forms found: {enrollment_forms.count()}")
        
        if course_filter:
            enrollment_forms = enrollment_forms.filter(course__icontains=course_filter)
        if year_filter:
            enrollment_forms = enrollment_forms.filter(year__icontains=year_filter)
        if section_filter:
            enrollment_forms = enrollment_forms.filter(section__icontains=section_filter)
        if search_query:
            enrollment_forms = enrollment_forms.filter(
                Q(user__full_name__icontains=search_query) |
                Q(user__profile__student_number__icontains=search_query) |
                Q(course__icontains=search_query)
            )
        
        print(f"Enrollment forms after filtering: {enrollment_forms.count()}")
        
        enrollment_data = []
        for enrollment in enrollment_forms:
            try:
                student = enrollment.user
                student_profile = getattr(student, 'profile', None)
                
                all_signatories = EnrollmentSignatory.objects.filter(
                    enrollment=enrollment
                ).select_related('signatory')

                # Defaults
                dean_status = 'pending'
                dean_timestamp = None
                business_manager_status = 'pending'
                business_manager_timestamp = None
                registrar_status = 'pending'
                registrar_timestamp = None

                for signatory in all_signatories:
                    # Convert to Philippines timezone for display
                    from django.utils import timezone
                    import pytz
                    
                    if signatory.status != 'pending' and signatory.updated_at:
                        # Convert UTC to Philippines timezone
                        ph_tz = pytz.timezone('Asia/Manila')
                        if timezone.is_aware(signatory.updated_at):
                            ph_time = signatory.updated_at.astimezone(ph_tz)
                        else:
                            ph_time = timezone.make_aware(signatory.updated_at, timezone.utc).astimezone(ph_tz)
                        ts = ph_time.strftime('%Y-%m-%d %I:%M %p')
                    else:
                        ts = None
                        
                    if signatory.role == 'dean':
                        dean_status = signatory.status
                        dean_timestamp = ts
                    elif signatory.role == 'business_manager':
                        business_manager_status = signatory.status
                        business_manager_timestamp = ts
                    elif signatory.role == 'registrar':
                        registrar_status = signatory.status
                        registrar_timestamp = ts

                roles_required = {'dean', 'business_manager', 'registrar'}
                statuses = {s.role: s.status for s in all_signatories}

                # Determine overall status and timestamp
                # Only two statuses: "pending" or "completed"
                overall_timestamp = None
                
                if roles_required.issubset(statuses.keys()) and all(statuses.get(role, 'pending') == 'approved' for role in roles_required):
                    # All required signatories have approved
                    overall_status = 'completed'
                    timestamps = [ts for ts in [dean_timestamp, business_manager_timestamp, registrar_timestamp] if ts]
                    overall_timestamp = max(timestamps) if timestamps else None
                else:
                    # Still pending - not all required signatories have approved yet
                    overall_status = 'pending'
                    overall_timestamp = None
                
                if status_filter:
                    if status_filter == 'completed' and overall_status != 'completed':
                        continue
                    elif status_filter == 'pending' and overall_status != 'pending':
                        continue
                    elif status_filter == 'disapproved' and overall_status != 'disapproved':
                        continue
                
                enrollment_data.append({
                    'id': str(enrollment.id),
                    'enrollment_id': str(enrollment.id),
                    'student_name': student.full_name,
                    'student_number': student_profile.student_number if student_profile else 'N/A',
                    'course': enrollment.course,
                    'year': enrollment.year,
                    'section': enrollment.section or 'N/A',
                    'date_submitted': enrollment.created_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%B %d, %Y'),
                    'dean_status': dean_status,
                    'dean_timestamp': dean_timestamp,
                    'business_manager_status': business_manager_status,
                    'business_manager_timestamp': business_manager_timestamp,
                    'registrar_status': registrar_status,
                    'registrar_timestamp': registrar_timestamp,
                    'overall_status': overall_status,
                    'overall_timestamp': overall_timestamp,
                    'can_approve': dean_status == 'pending',
                    'can_disapprove': dean_status == 'pending',
                })
            except Exception as e:
                print(f"Error processing enrollment {enrollment.id}: {e}")
                continue
        
        print(f"Final enrollment data count: {len(enrollment_data)}")
        return JsonResponse({'success': True, 'enrollments': enrollment_data})
    
    except Exception as e:
        print(f"Error in signatory_enrollment_data_api: {e}")
        return JsonResponse({'error': str(e)}, status=500)



@login_required
def signatory_enrollment_filter_options(request):
    """API endpoint to get filter options for enrollment"""
    print(f"Filter options API called by user: {request.user.full_name}")
    
    if request.user.user_type != 'signatory':
        print("Access denied: User is not a signatory")
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get all enrollment forms
        enrollment_forms = EnrollmentForm.objects.all().select_related(
            'user__profile'
        )
        
        print(f"Total enrollment forms for filter options: {enrollment_forms.count()}")
        
        # Get unique courses
        courses = enrollment_forms.values_list(
            'course', flat=True
        ).distinct().exclude(course__isnull=True).exclude(
            course=''
        ).order_by('course')
        
        # Get unique years
        years = enrollment_forms.values_list(
            'year', flat=True
        ).distinct().exclude(year__isnull=True).order_by('year')
        
        # Get unique sections
        sections = enrollment_forms.values_list(
            'section', flat=True
        ).distinct().exclude(section__isnull=True).exclude(
            section=''
        ).order_by('section')
        
        print(f"Filter options - Courses: {list(courses)}, Years: {list(years)}, Sections: {list(sections)}")
        
        return JsonResponse({
            'success': True,
            'courses': list(courses),
            'years': list(years),
            'sections': list(sections),
        })
        
    except Exception as e:
        print(f"Error in signatory_enrollment_filter_options: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_approve_enrollment(request):
    """Approve enrollment form"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Check if user is Academic Dean
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        if not signatory_profile or signatory_profile.signatory_type != 'academic_dean':
            return JsonResponse({'error': 'Access denied. Only Academic Dean can approve enrollment forms.'}, status=403)
        
        # Verify PIN
        pin = request.POST.get('pin')
        if not pin or not signatory_profile.pin_set:
            return JsonResponse({'error': 'PIN verification required'}, status=400)
        
        # Verify PIN (you should hash the PIN for security)
        if not signatory_profile.pin or signatory_profile.pin != pin:
            return JsonResponse({'error': 'Incorrect PIN'}, status=400)
        
        enrollment_id = request.POST.get('enrollment_id')
        comment = request.POST.get('comment', '')
        
        if not enrollment_id:
            return JsonResponse({'error': 'Enrollment ID is required'}, status=400)
        
        # Get or create enrollment signatory record
        enrollment = EnrollmentForm.objects.get(id=enrollment_id)
        enrollment_signatory, created = EnrollmentSignatory.objects.get_or_create(
            enrollment=enrollment,
            signatory=request.user,
            defaults={
                'status': 'pending',
                'role': 'dean'
            }
        )
        
        # Allow editing disapproved enrollments (changing from disapproved to approved)
        if enrollment_signatory.status == 'approved':
            return JsonResponse({'error': 'Enrollment already approved'}, status=400)
        
        # Update status
        enrollment_signatory.status = 'approved'
        enrollment_signatory.remarks = comment
        enrollment_signatory.ip_address = get_client_ip(request)
        enrollment_signatory.save()
        
        # Send individual approval notification to student
        try:
            from landing.notification_service import NotificationService
            NotificationService.notify_form_approval(
                form_instance=enrollment,
                form_type='enrollment',
                signatory_user=request.user,
                remarks=comment
            )
        except Exception as e:
            print(f"Error sending approval notification: {e}")
        
        # Check if all required signatories approved and update enrollment status
        required_roles = ['business_manager', 'registrar', 'dean']
        all_signatories = EnrollmentSignatory.objects.filter(enrollment=enrollment)
        
        print(f"DEBUG: Checking enrollment {enrollment.id} status update")
        print(f"DEBUG: Found {all_signatories.count()} signatory records")
        for sig in all_signatories:
            print(f"DEBUG: Signatory {sig.signatory.full_name} ({sig.role}): {sig.status}")
        
        # Check if we have all required roles and all are approved
        signatory_roles = set(sig.role for sig in all_signatories)
        required_roles_set = set(required_roles)
        
        if (signatory_roles >= required_roles_set and 
            all_signatories.count() >= 4 and 
            all(s.status == 'approved' for s in all_signatories)):
            enrollment.status = 'approved'
            enrollment.save()
            print(f"DEBUG: Updated enrollment {enrollment.id} status to approved")
            
            # Send notifications for completed enrollment
            try:
                from landing.notification_service import NotificationService
                NotificationService.notify_enrollment_completed(enrollment.user, enrollment)
                NotificationService.notify_admin_form_completed('enrollment', enrollment.user.full_name)
            except Exception as e:
                print(f"Error sending enrollment completion notifications: {e}")
        else:
            missing_roles = required_roles_set - signatory_roles
            print(f"DEBUG: Not all required signatories approved yet. Missing roles: {missing_roles}")
        
        # Log activity
        SignatoryActivityLog.objects.create(
            signatory=request.user,
            action_type='approve',
            form_type='enrollment',
            form_id=enrollment.id,
            student_name=enrollment.user.full_name,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Enrollment approved successfully'
        })
        
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment not found'}, status=404)
    except Exception as e:
        print(f"Error in signatory_approve_enrollment: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_disapprove_enrollment(request):
    """Disapprove enrollment form"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Check if user is Academic Dean
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        if not signatory_profile or signatory_profile.signatory_type != 'academic_dean':
            return JsonResponse({'error': 'Access denied. Only Academic Dean can disapprove enrollment forms.'}, status=403)
        
        # Verify PIN
        pin = request.POST.get('pin')
        if not pin or not signatory_profile.pin_set:
            return JsonResponse({'error': 'PIN verification required'}, status=400)
        
        # Verify PIN
        if not signatory_profile.pin or signatory_profile.pin != pin:
            return JsonResponse({'error': 'Incorrect PIN'}, status=400)
        
        enrollment_id = request.POST.get('enrollment_id')
        reasons = request.POST.getlist('reasons[]')
        comment = request.POST.get('comment', '')
        appointment_date = request.POST.get('appointment_date')
        
        if not enrollment_id:
            return JsonResponse({'error': 'Enrollment ID is required'}, status=400)
        
        if not reasons:
            return JsonResponse({'error': 'Please select at least one reason'}, status=400)
        
        # Get or create enrollment signatory record
        enrollment = EnrollmentForm.objects.get(id=enrollment_id)
        enrollment_signatory, created = EnrollmentSignatory.objects.get_or_create(
            enrollment=enrollment,
            signatory=request.user,
            defaults={
                'status': 'pending',
                'role': 'dean'
            }
        )
        
        if enrollment_signatory.status != 'pending':
            return JsonResponse({'error': 'Enrollment has already been processed'}, status=400)
        
        # Update status
        enrollment_signatory.status = 'disapproved'
        enrollment_signatory.remarks = f"Reasons: {', '.join(reasons)}. {comment}"
        enrollment_signatory.ip_address = get_client_ip(request)
        enrollment_signatory.save()
        
        # Log activity
        SignatoryActivityLog.objects.create(
            signatory=request.user,
            action_type='disapprove',
            form_type='enrollment',
            form_id=enrollment.id,
            student_name=enrollment.user.full_name,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Enrollment disapproved successfully'
        })
        
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment not found'}, status=404)
    except Exception as e:
        print(f"Error in signatory_disapprove_enrollment: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_print_enrollment(request, enrollment_id):
    """Print enrollment form"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        enrollment = EnrollmentForm.objects.get(id=enrollment_id)
        student = enrollment.user
        student_profile = getattr(student, 'profile', None)
        
        context = {
            'enrollment_forms': [{
                'enrollment': enrollment,
                'student': student,
                'profile': student_profile,
            }]
        }
        
        # Log activity
        SignatoryActivityLog.objects.create(
            signatory=request.user,
            action_type='print',
            form_type='enrollment',
            form_id=enrollment.id,
            student_name=student.full_name,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        return render(request, 'pdf/pdf-enrollment.html', context)
        
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment form not found'}, status=404)
    except Exception as e:
        print(f"Error in signatory_print_enrollment: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_bulk_print_enrollment(request):
    """Bulk print enrollment forms"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'GET':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        enrollment_ids = request.GET.getlist('ids')
        
        if not enrollment_ids:
            return JsonResponse({'error': 'No enrollment forms selected'}, status=400)
        
        enrollments = []
        for enrollment_id in enrollment_ids:
            try:
                enrollment = EnrollmentForm.objects.get(id=enrollment_id)
                student = enrollment.user
                student_profile = getattr(student, 'profile', None)
                
                enrollments.append({
                    'enrollment': enrollment,
                    'student': student,
                    'student_profile': student_profile,
                })
                
                # Log activity
                SignatoryActivityLog.objects.create(
                    signatory=request.user,
                    action_type='print',
                    form_type='enrollment',
                    form_id=enrollment.id,
                    student_name=student.full_name,
                    ip_address=get_client_ip(request),
                    user_agent=request.META.get('HTTP_USER_AGENT', '')
                )
            except EnrollmentForm.DoesNotExist:
                continue
        
        context = {
            'enrollment_forms': enrollments,
        }
        
        return render(request, 'pdf/pdf-enrollment-bulk.html', context)
        
    except Exception as e:
        print(f"Error in signatory_bulk_print_enrollment: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_print_clearance(request, clearance_id):
    """Print single clearance - redirect to preview with single ID"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    # Redirect to preview function with single ID
    from django.http import HttpResponseRedirect
    return HttpResponseRedirect(f'/signatory/clearance/preview-print/?ids={clearance_id}')


@login_required  
def signatory_bulk_print_clearance(request):
    """Return printable HTML fragment for preview modal - MATCHES BUSINESS MANAGER"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    clearance_ids = request.GET.get('ids', '').split(',')
    if not clearance_ids or clearance_ids == ['']:
        return JsonResponse({'error': 'No clearance IDs provided'}, status=400)
    
    # Filter out empty IDs
    clearance_ids = [id.strip() for id in clearance_ids if id.strip()]
    if not clearance_ids:
        return JsonResponse({'error': 'No valid clearance IDs provided'}, status=400)
    
    clearance_forms = []
    
    # Efficiently fetch all clearances with their signatories
    clearances = ClearanceForm.objects.select_related(
        'student', 'student__profile'
    ).prefetch_related(
        'signatories__signatory__signatory_profile',
        'student__enrollment_forms'
    ).filter(id__in=clearance_ids)
    
    for clearance_form in clearances:
        try:
            # Get enrollment form
            enrollment_form = clearance_form.student.enrollment_forms.first()
            
            # Get signatories for this clearance
            clearance_signatories = clearance_form.signatories.all()
            
            clearance_forms.append({
                'clearance': clearance_form,
                'student': clearance_form.student,
                'profile': clearance_form.student.profile,
                'enrollment': enrollment_form,
                'signatories': clearance_signatories,  # Use the actual queryset
            })
        except Exception as e:
            continue  # Skip problematic clearances
    
    # Check if any clearances were found
    if not clearance_forms:
        return JsonResponse({'error': 'No valid clearance forms found for the provided IDs'}, status=400)
    
    context = {
        'clearance_forms': clearance_forms,
        'is_preview': True,  # Flag to indicate this is for preview
    }
    
    return render(request, 'pdf/pdf-clearance-preview.html', context)


@login_required
def signatory_delete_enrollment(request, enrollment_id):
    """Delete enrollment form"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        enrollment = EnrollmentForm.objects.get(id=enrollment_id)
        student_name = enrollment.user.full_name
        
        # Log activity before deletion
        SignatoryActivityLog.objects.create(
            signatory=request.user,
            action_type='delete',
            form_type='enrollment',
            form_id=enrollment.id,
            student_name=student_name,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        enrollment.delete()
        
        return JsonResponse({
            'success': True,
            'message': 'Enrollment deleted successfully'
        })
        
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment form not found'}, status=404)
    except Exception as e:
        print(f"Error in signatory_delete_enrollment: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_bulk_delete_enrollment(request):
    """Bulk delete enrollment forms"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        enrollment_ids = data.get('enrollment_ids', [])
        
        if not enrollment_ids:
            return JsonResponse({'error': 'No enrollment forms selected'}, status=400)
        
        deleted_count = 0
        for enrollment_id in enrollment_ids:
            try:
                enrollment = EnrollmentForm.objects.get(id=enrollment_id)
                student_name = enrollment.user.full_name
                
                # Log activity before deletion
                SignatoryActivityLog.objects.create(
                    signatory=request.user,
                    action_type='delete',
                    form_type='enrollment',
                    form_id=enrollment.id,
                    student_name=student_name,
                    ip_address=get_client_ip(request),
                    user_agent=request.META.get('HTTP_USER_AGENT', '')
                )
                
                enrollment.delete()
                deleted_count += 1
            except EnrollmentForm.DoesNotExist:
                continue
        
        return JsonResponse({
            'success': True,
            'message': f'{deleted_count} enrollment forms deleted successfully'
        })
        
    except Exception as e:
        print(f"Error in signatory_bulk_delete_enrollment: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_bulk_approve_enrollment(request):
    """Bulk approve enrollment forms"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Check if user is Academic Dean
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        if not signatory_profile or signatory_profile.signatory_type != 'academic_dean':
            return JsonResponse({'error': 'Access denied. Only Academic Dean can approve enrollment forms.'}, status=403)
        
        # Verify PIN
        pin = request.POST.get('pin')
        if not pin or not signatory_profile.pin_set:
            return JsonResponse({'error': 'PIN verification required'}, status=400)
        
        if not signatory_profile.pin or signatory_profile.pin != pin:
            return JsonResponse({'error': 'Incorrect PIN'}, status=400)
        
        enrollment_ids = request.POST.getlist('enrollment_ids[]')
        comment = request.POST.get('comment', '')
        
        if not enrollment_ids:
            return JsonResponse({'error': 'No enrollment forms selected'}, status=400)
        
        processed_count = 0
        
        for enrollment_id in enrollment_ids:
            try:
                # Get or create enrollment signatory record
                enrollment = EnrollmentForm.objects.get(id=enrollment_id)
                enrollment_signatory, created = EnrollmentSignatory.objects.get_or_create(
                    enrollment=enrollment,
                    signatory=request.user,
                    defaults={
                        'status': 'pending',
                        'role': 'dean'
                    }
                )
                
                # Only process if still pending
                if enrollment_signatory.status == 'pending':
                    enrollment_signatory.status = 'approved'
                    enrollment_signatory.remarks = comment
                    enrollment_signatory.ip_address = get_client_ip(request)
                    enrollment_signatory.save()
                    
                    processed_count += 1
                    
                    # Check if all required signatories approved and update enrollment status
                    required_roles = ['business_manager', 'registrar', 'dean']
                    all_signatories = EnrollmentSignatory.objects.filter(enrollment=enrollment)
                    
                    # Check if we have all required roles and all are approved
                    signatory_roles = set(sig.role for sig in all_signatories)
                    required_roles_set = set(required_roles)
                    
                    if (signatory_roles >= required_roles_set and 
                        all_signatories.count() >= 4 and 
                        all(s.status == 'approved' for s in all_signatories)):
                        enrollment.status = 'approved'
                        enrollment.save()
                    
                    # Create audit log
                    AuditLog.objects.create(
                        user=request.user,
                        action='Bulk Approved Enrollment Form',
                        model_name='EnrollmentForm',
                        object_id=enrollment_id,
                        changes=f"Enrollment form approved via bulk action. Remarks: {comment}" if comment else "Enrollment form approved via bulk action",
                        ip_address=get_client_ip(request)
                    )
                    
            except EnrollmentForm.DoesNotExist:
                continue
            except Exception as e:
                print(f"Error processing enrollment {enrollment_id}: {e}")
                continue
        
        return JsonResponse({
            'success': True,
            'processed_count': processed_count,
            'message': f'{processed_count} enrollment(s) approved successfully'
        })
        
    except Exception as e:
        print(f"Error in signatory_bulk_approve_enrollment: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_bulk_disapprove_enrollment(request):
    """Bulk disapprove enrollment forms"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        # Check if user is Academic Dean
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        if not signatory_profile or signatory_profile.signatory_type != 'academic_dean':
            return JsonResponse({'error': 'Access denied. Only Academic Dean can disapprove enrollment forms.'}, status=403)
        
        # Verify PIN
        pin = request.POST.get('pin')
        if not pin or not signatory_profile.pin_set:
            return JsonResponse({'error': 'PIN verification required'}, status=400)
        
        if not signatory_profile.pin or signatory_profile.pin != pin:
            return JsonResponse({'error': 'Incorrect PIN'}, status=400)
        
        enrollment_ids = request.POST.getlist('enrollment_ids[]')
        comment = request.POST.get('comment', '')
        reasons = request.POST.getlist('reasons[]')
        
        if not enrollment_ids:
            return JsonResponse({'error': 'No enrollment forms selected'}, status=400)
        
        if not reasons:
            return JsonResponse({'error': 'Please provide at least one reason'}, status=400)
        
        processed_count = 0
        
        for enrollment_id in enrollment_ids:
            try:
                # Get or create enrollment signatory record
                enrollment = EnrollmentForm.objects.get(id=enrollment_id)
                enrollment_signatory, created = EnrollmentSignatory.objects.get_or_create(
                    enrollment=enrollment,
                    signatory=request.user,
                    defaults={
                        'status': 'pending',
                        'role': 'dean'
                    }
                )
                
                # Only process if still pending
                if enrollment_signatory.status == 'pending':
                    enrollment_signatory.status = 'disapproved'
                    enrollment_signatory.remarks = f"Reasons: {', '.join(reasons)}" + (f". Comments: {comment}" if comment else "")
                    enrollment_signatory.ip_address = get_client_ip(request)
                    enrollment_signatory.save()
                    
                    processed_count += 1
                    
                    # Update enrollment status to disapproved
                    enrollment.status = 'disapproved'
                    enrollment.save()
                    
                    # Create audit log
                    AuditLog.objects.create(
                        user=request.user,
                        action='Bulk Disapproved Enrollment Form',
                        model_name='EnrollmentForm',
                        object_id=enrollment_id,
                        changes=f"Enrollment form disapproved via bulk action. Reasons: {', '.join(reasons)}. Comments: {comment}" if comment else f"Enrollment form disapproved via bulk action. Reasons: {', '.join(reasons)}",
                        ip_address=get_client_ip(request)
                    )
                    
            except EnrollmentForm.DoesNotExist:
                continue
            except Exception as e:
                print(f"Error processing enrollment {enrollment_id}: {e}")
                continue
        
        return JsonResponse({
            'success': True,
            'processed_count': processed_count,
            'message': f'{processed_count} enrollment(s) disapproved successfully'
        })
        
    except Exception as e:
        print(f"Error in signatory_bulk_disapprove_enrollment: {e}")
        return JsonResponse({'error': str(e)}, status=500)


# ==================== SIGNATORY GRADUATION VIEWS ====================

@login_required
def signatory_graduation(request):
    """Signatory Graduation Management View - President Only"""
    if request.user.user_type != 'signatory':
        return redirect('login')
    
    # Check if user is President or Academic Dean
    signatory_profile = getattr(request.user, 'signatory_profile', None)
    if not signatory_profile or signatory_profile.signatory_type not in ['president', 'academic_dean']:
        messages.error(request, 'Access denied. Only President or Academic Dean can access graduation forms.')
        return redirect('signatory_dashboard')
    
    context = {
        'signatory_profile': signatory_profile,
    }
    return render(request, 'SIGNATORYGRADUATION.html', context)


@login_required
def signatory_graduation_data_api(request):
    """API endpoint to get graduation data for signatory (President only)."""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    # Check if user is President or Academic Dean
    signatory_profile = getattr(request.user, 'signatory_profile', None)
    if not signatory_profile or signatory_profile.signatory_type not in ['president', 'academic_dean']:
        return JsonResponse({'error': 'Access denied. Only President or Academic Dean can access graduation forms.'}, status=403)
    
    try:
        # Get filter parameters
        filter_status = request.GET.get('status', '')
        search_query = request.GET.get('search', '')
        course_filter = request.GET.get('course', '')
        year_filter = request.GET.get('year', '')
        section_filter = request.GET.get('section', '')
        
        # Base query
        graduation_forms = GraduationForm.objects.select_related('user').prefetch_related('signatories')
        
        # Apply course filter (ignore placeholder values)
        if course_filter and not course_filter.startswith('Filter by'):
            graduation_forms = graduation_forms.filter(user__profile__program__icontains=course_filter)
        
        # Apply year filter (ignore placeholder values)
        if year_filter and not year_filter.startswith('Filter by'):
            graduation_forms = graduation_forms.filter(user__profile__year_level=year_filter)
        
        # Apply section filter (ignore placeholder values)
        if section_filter and not section_filter.startswith('Filter by'):
            user_ids_with_section = EnrollmentForm.objects.filter(
                section__icontains=section_filter
            ).values_list('user_id', flat=True)
            graduation_forms = graduation_forms.filter(user_id__in=user_ids_with_section)
        
        # Apply search if provided
        if search_query:
            graduation_forms = graduation_forms.filter(
                Q(user__full_name__icontains=search_query) |
                Q(user__profile__student_number__icontains=search_query) |
                Q(user__profile__program__icontains=search_query) |
                Q(grad_appno__icontains=search_query)
            )
        
        graduation_data = []
        
        for graduation in graduation_forms:
            # Determine the current user's role in the graduation workflow
            user_role = 'dean' if signatory_profile.signatory_type == 'academic_dean' else 'president'
            
            # Get all signatory statuses for this graduation
            current_user_signatory = graduation.signatories.filter(
                role=user_role, 
                signatory=request.user
            ).first()
            dean_signatory = graduation.signatories.filter(role='dean').first()
            business_manager_signatory = graduation.signatories.filter(role='business_manager').first()
            registrar_signatory = graduation.signatories.filter(role='registrar').first()
            president_signatory = graduation.signatories.filter(role='president').first()
            
            # Determine current user's status (for their respective column)
            current_user_status = current_user_signatory.status if current_user_signatory else 'pending'
            current_user_timestamp = None
            current_user_remarks = ''
            
            if current_user_signatory and current_user_signatory.updated_at:
                manila_tz = pytz.timezone('Asia/Manila')
                current_user_timestamp = current_user_signatory.updated_at.astimezone(manila_tz).strftime('%Y-%m-%d %I:%M %p')
            
            if current_user_signatory:
                current_user_remarks = current_user_signatory.remarks or ''
            
            # Determine overall status - only 'pending' or 'completed'
            roles_required = ['dean', 'business_manager', 'registrar', 'president']
            all_approved = all([
                dean_signatory and dean_signatory.status == 'approved',
                business_manager_signatory and business_manager_signatory.status == 'approved', 
                registrar_signatory and registrar_signatory.status == 'approved',
                president_signatory and president_signatory.status == 'approved'
            ])
            overall_status = 'completed' if all_approved else 'pending'
            
            # Apply status filter after determining overall status
            if filter_status and filter_status != overall_status:
                continue
            
            # Get section from enrollment forms
            enrollment_form = EnrollmentForm.objects.filter(user=graduation.user).first()
            section = enrollment_form.section if enrollment_form else 'N/A'
            
            graduation_entry = {
                'id': str(graduation.id),
                'student_name': graduation.user.full_name,
                'student_number': graduation.user.profile.student_number if hasattr(graduation.user, 'profile') else 'N/A',
                'course': graduation.user.profile.program if hasattr(graduation.user, 'profile') else 'N/A',
                'year': graduation.user.profile.year_level if hasattr(graduation.user, 'profile') else 'N/A',
                'section': section,
                'grad_appno': graduation.grad_appno or 'N/A',
                'email': graduation.user.email,
                'date_submitted': graduation.created_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p'),
                'dean_status': dean_signatory.status if dean_signatory else 'pending',
                'dean_timestamp': dean_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if dean_signatory and dean_signatory.updated_at else '',
                'business_status': business_manager_signatory.status if business_manager_signatory else 'pending', 
                'business_timestamp': business_manager_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if business_manager_signatory and business_manager_signatory.updated_at else '',
                'registrar_status': registrar_signatory.status if registrar_signatory else 'pending',
                'registrar_timestamp': registrar_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if registrar_signatory and registrar_signatory.updated_at else '',
                'president_status': president_signatory.status if president_signatory else 'pending',
                'president_timestamp': president_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if president_signatory and president_signatory.updated_at else '',
                'overall_status': overall_status,
                # Fields for current user's column
                'user_role': user_role,
                'user_status': current_user_status,
                'user_timestamp': current_user_timestamp,
                'user_remarks': current_user_remarks,
            }
            graduation_data.append(graduation_entry)
        
        # Sort by submission date (newest first)
        graduation_data.sort(key=lambda x: x['date_submitted'], reverse=True)
        
        return JsonResponse({
            'success': True,
            'graduation_data': graduation_data
        })
        
    except Exception as e:
        print(f"Error in signatory_graduation_data_api: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_graduation_filter_options(request):
    """API endpoint to get filter options for graduation"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    # Check if user is President or Academic Dean
    signatory_profile = getattr(request.user, 'signatory_profile', None)
    if not signatory_profile or signatory_profile.signatory_type not in ['president', 'academic_dean']:
        return JsonResponse({'error': 'Access denied. Only President or Academic Dean can access graduation forms.'}, status=403)
    
    try:
        # Get all graduation forms with related user profiles
        graduation_forms = GraduationForm.objects.select_related('user__profile').all()
        
        # Get unique courses from user profiles
        courses = graduation_forms.values_list(
            'user__profile__program', flat=True
        ).distinct().exclude(user__profile__program__isnull=True).exclude(
            user__profile__program=''
        ).order_by('user__profile__program')
        
        # Get unique years from user profiles
        years = graduation_forms.values_list(
            'user__profile__year_level', flat=True
        ).distinct().exclude(user__profile__year_level__isnull=True).order_by('user__profile__year_level')
        
        # Get unique sections from enrollment forms
        enrollment_forms = EnrollmentForm.objects.filter(
            user__in=graduation_forms.values_list('user', flat=True)
        )
        sections = enrollment_forms.values_list(
            'section', flat=True
        ).distinct().exclude(section__isnull=True).exclude(
            section=''
        ).order_by('section')
        
        return JsonResponse({
            'success': True,
            'courses': list(courses),
            'years': list(years),
            'sections': list(sections),
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_approve_graduation(request):
    """Approve graduation form - President endpoint"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    # Check if user is President or Academic Dean
    signatory_profile = getattr(request.user, 'signatory_profile', None)
    if not signatory_profile or signatory_profile.signatory_type not in ['president', 'academic_dean']:
        return JsonResponse({'error': 'Access denied. Only President or Academic Dean can approve graduation forms.'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        graduation_id = request.POST.get('graduation_id')
        pin = request.POST.get('pin')
        comment = request.POST.get('comment', '')
        
        if not graduation_id or not pin:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Verify PIN
        if not signatory_profile.pin_set or not signatory_profile.pin:
            return JsonResponse({'error': 'PIN not set'}, status=400)
        
        if signatory_profile.pin != pin:
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get graduation form
        graduation = GraduationForm.objects.get(id=graduation_id)
        
        # Determine the correct role based on user's signatory type
        user_role = 'dean' if signatory_profile.signatory_type == 'academic_dean' else 'president'
        
        # Create or update signatory record with correct role
        signatory_record, created = GraduationSignatory.objects.get_or_create(
            graduation=graduation,
            signatory=request.user,
            role=user_role,
            defaults={'status': 'pending'}
        )
        
        if signatory_record.status == 'approved':
            return JsonResponse({'error': 'Graduation form has already been approved'}, status=400)
        
        # Update status
        signatory_record.status = 'approved'
        signatory_record.remarks = comment
        signatory_record.ip_address = get_client_ip(request)
        signatory_record.save()
        
        # Send individual approval notification to student
        try:
            from landing.notification_service import NotificationService
            NotificationService.notify_form_approval(
                form_instance=graduation,
                form_type='graduation',
                signatory_user=request.user,
                remarks=comment
            )
        except Exception as e:
            print(f"Error sending approval notification: {e}")
        
        # Check if all required signatories approved and update graduation status
        required_roles = ['dean', 'business_manager', 'registrar', 'president']
        all_signatories = GraduationSignatory.objects.filter(graduation=graduation)
        
        # Check if we have all required roles and all are approved
        signatory_roles = set(sig.role for sig in all_signatories)
        required_roles_set = set(required_roles)
        
        if (signatory_roles >= required_roles_set and 
            all_signatories.count() >= 4 and 
            all(s.status == 'approved' for s in all_signatories)):
            graduation.status = 'approved'
            graduation.save()
            
            # Send notifications for completed graduation
            try:
                from landing.notification_service import NotificationService
                NotificationService.notify_graduation_completed(graduation.user, graduation)
                NotificationService.notify_admin_form_completed('graduation', graduation.user.full_name)
            except Exception as e:
                print(f"Error sending graduation completion notifications: {e}")
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_approval',
            description=f'President approved graduation form {graduation_id} for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Graduation form approved successfully'
        })
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_disapprove_graduation(request):
    """Disapprove graduation form - President endpoint"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    # Check if user is President
    signatory_profile = getattr(request.user, 'signatory_profile', None)
    if not signatory_profile or signatory_profile.signatory_type not in ['president', 'academic_dean']:
        return JsonResponse({'error': 'Access denied. Only President or Academic Dean can disapprove graduation forms.'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        graduation_id = request.POST.get('graduation_id')
        pin = request.POST.get('pin')
        reasons = request.POST.getlist('reasons[]')
        appointment_date = request.POST.get('appointment_date')
        comment = request.POST.get('comment', '')
        
        if not graduation_id or not pin:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Verify PIN
        if not signatory_profile.pin_set or not signatory_profile.pin:
            return JsonResponse({'error': 'PIN not set'}, status=400)
        
        if signatory_profile.pin != pin:
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get graduation form
        graduation = GraduationForm.objects.get(id=graduation_id)
        
        # Determine the correct role based on user's signatory type
        user_role = 'dean' if signatory_profile.signatory_type == 'academic_dean' else 'president'
        
        # Create or update signatory record with correct role
        signatory_record, created = GraduationSignatory.objects.get_or_create(
            graduation=graduation,
            signatory=request.user,
            role=user_role,
            defaults={'status': 'pending'}
        )
        
        if signatory_record.status == 'disapproved':
            return JsonResponse({'error': 'Graduation form has already been disapproved'}, status=400)
        
        # Update status
        from django.utils import timezone
        signatory_record.status = 'disapproved'
        signatory_record.remarks = f"Reasons: {', '.join(reasons)}. Appointment: {appointment_date}. {comment}"
        signatory_record.ip_address = get_client_ip(request)
        signatory_record.updated_at = timezone.now()
        signatory_record.save()
        
        # Send notification to student
        try:
            from landing.notification_service import NotificationService
            notification_service = NotificationService()
            notification_service.handle_form_disapproval(
                form=graduation,
                form_type='graduation',
                disapproval_reasons=reasons,
                settlement_instructions=comment,
                appointment_date=appointment_date
            )
        except Exception as e:
            print(f"Error sending president graduation disapproval notification: {e}")
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_disapproval',
            description=f'President disapproved graduation form {graduation_id} for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Graduation form disapproved successfully'
        })
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_bulk_approve_graduation(request):
    """Bulk approve graduation forms - President endpoint"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    # Check if user is President or Academic Dean
    signatory_profile = getattr(request.user, 'signatory_profile', None)
    if not signatory_profile or signatory_profile.signatory_type not in ['president', 'academic_dean']:
        return JsonResponse({'error': 'Access denied. Only President or Academic Dean can approve graduation forms.'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        graduation_ids = request.POST.getlist('graduation_ids[]')
        pin = request.POST.get('pin')
        comment = request.POST.get('comment', '')
        
        if not graduation_ids:
            return JsonResponse({'error': 'No graduation forms selected'}, status=400)
        
        # Verify PIN
        if not pin or not signatory_profile.pin_set:
            return JsonResponse({'error': 'PIN verification required'}, status=400)
        
        if not signatory_profile.pin or signatory_profile.pin != pin:
            return JsonResponse({'error': 'Incorrect PIN'}, status=400)
        
        # Determine the correct role based on user's signatory type
        user_role = 'dean' if signatory_profile.signatory_type == 'academic_dean' else 'president'
        processed_count = 0
        
        for graduation_id in graduation_ids:
            try:
                # Get or create signatory record with correct role
                graduation = GraduationForm.objects.get(id=graduation_id)
                signatory_record, created = GraduationSignatory.objects.get_or_create(
                    graduation=graduation,
                    signatory=request.user,
                    role=user_role,
                    defaults={'status': 'pending'}
                )
                
                # Only process if not already approved
                if signatory_record.status != 'approved':
                    signatory_record.status = 'approved'
                    signatory_record.remarks = comment
                    signatory_record.ip_address = get_client_ip(request)
                    signatory_record.save()
                    
                    processed_count += 1
                    
                    # Check if all required signatories approved and update graduation status
                    required_roles = ['dean', 'business_manager', 'registrar', 'president']
                    all_signatories = GraduationSignatory.objects.filter(graduation=graduation)
                    
                    signatory_roles = set(sig.role for sig in all_signatories)
                    required_roles_set = set(required_roles)
                    
                    if (signatory_roles >= required_roles_set and 
                        all_signatories.count() >= 4 and 
                        all(s.status == 'approved' for s in all_signatories)):
                        graduation.status = 'approved'
                        graduation.save()
                    
                    # Create audit log
                    AuditLog.objects.create(
                        user=request.user,
                        action='Bulk Approved Graduation Form',
                        model_name='GraduationForm',
                        object_id=graduation_id,
                        changes=f"Graduation form approved via bulk action. Comments: {comment}" if comment else "Graduation form approved via bulk action",
                        ip_address=get_client_ip(request)
                    )
                    
            except GraduationForm.DoesNotExist:
                continue
            except Exception as e:
                print(f"Error processing graduation {graduation_id}: {e}")
                continue
        
        return JsonResponse({
            'success': True,
            'processed_count': processed_count,
            'message': f'{processed_count} graduation(s) approved successfully'
        })
        
    except Exception as e:
        print(f"Error in signatory_bulk_approve_graduation: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_bulk_disapprove_graduation(request):
    """Bulk disapprove graduation forms - President endpoint"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    # Check if user is President
    signatory_profile = getattr(request.user, 'signatory_profile', None)
    if not signatory_profile or signatory_profile.signatory_type not in ['president', 'academic_dean']:
        return JsonResponse({'error': 'Access denied. Only President or Academic Dean can disapprove graduation forms.'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        graduation_ids = request.POST.getlist('graduation_ids[]')
        pin = request.POST.get('pin')
        comment = request.POST.get('comment', '')
        reasons = request.POST.getlist('reasons[]')
        appointment_date = request.POST.get('appointment_date')
        
        if not graduation_ids:
            return JsonResponse({'error': 'No graduation forms selected'}, status=400)
        
        if not reasons:
            return JsonResponse({'error': 'Please provide at least one reason'}, status=400)
        
        if not appointment_date:
            return JsonResponse({'error': 'Please provide an appointment date'}, status=400)
        
        # Verify PIN
        if not pin or not signatory_profile.pin_set:
            return JsonResponse({'error': 'PIN verification required'}, status=400)
        
        if not signatory_profile.pin or signatory_profile.pin != pin:
            return JsonResponse({'error': 'Incorrect PIN'}, status=400)
        
        # Determine the correct role based on user's signatory type
        user_role = 'dean' if signatory_profile.signatory_type == 'academic_dean' else 'president'
        processed_count = 0
        
        for graduation_id in graduation_ids:
            try:
                # Get or create signatory record with correct role
                graduation = GraduationForm.objects.get(id=graduation_id)
                signatory_record, created = GraduationSignatory.objects.get_or_create(
                    graduation=graduation,
                    signatory=request.user,
                    role=user_role,
                    defaults={'status': 'pending'}
                )
                
                # Only process if not already disapproved
                if signatory_record.status != 'disapproved':
                    from django.utils import timezone
                    signatory_record.status = 'disapproved'
                    signatory_record.remarks = f"Reasons: {', '.join(reasons)}. Appointment: {appointment_date}" + (f". Comments: {comment}" if comment else "")
                    signatory_record.ip_address = get_client_ip(request)
                    signatory_record.updated_at = timezone.now()
                    signatory_record.save()
                    
                    processed_count += 1
                    
                    # Create audit log
                    AuditLog.objects.create(
                        user=request.user,
                        action='Bulk Disapproved Graduation Form',
                        model_name='GraduationForm',
                        object_id=graduation_id,
                        changes=f"Graduation form disapproved via bulk action. Reasons: {', '.join(reasons)}. Comments: {comment}" if comment else f"Graduation form disapproved via bulk action. Reasons: {', '.join(reasons)}",
                        ip_address=get_client_ip(request)
                    )
                    
            except GraduationForm.DoesNotExist:
                continue
            except Exception as e:
                print(f"Error processing graduation {graduation_id}: {e}")
                continue
        
        return JsonResponse({
            'success': True,
            'processed_count': processed_count,
            'message': f'{processed_count} graduation(s) disapproved successfully'
        })
        
    except Exception as e:
        print(f"Error in signatory_bulk_disapprove_graduation: {e}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def signatory_graduation_view(request, graduation_id):
    """View a graduation form - Signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        graduation = GraduationForm.objects.get(id=graduation_id)
        profile = getattr(graduation.user, 'profile', None)
        
        context = {
            'graduation': graduation,
            'user': graduation.user,
            'profile': profile,
            'today': date.today().strftime('%Y-%m-%d')
        }
        
        return render(request, 'pdf/pdf-graduation.html', context)
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def signatory_graduation_print(request, graduation_id):
    """Print a graduation form - Signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        graduation = GraduationForm.objects.get(id=graduation_id)
        profile = getattr(graduation.user, 'profile', None)
        
        context = {
            'graduation': graduation,
            'user': graduation.user,
            'profile': profile,
            'today': date.today().strftime('%Y-%m-%d')
        }
        
        return render(request, 'pdf/pdf-graduation.html', context)
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def signatory_graduation_bulk_print(request):
    """Bulk print graduation forms - Signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    graduation_ids = request.GET.get('ids', '').split(',')
    graduation_ids = [gid.strip() for gid in graduation_ids if gid.strip()]
    
    if not graduation_ids:
        return JsonResponse({'error': 'No graduation IDs provided'}, status=400)
    
    try:
        graduation_forms = []
        for graduation_id in graduation_ids:
            try:
                graduation = GraduationForm.objects.get(id=graduation_id)
                profile = getattr(graduation.user, 'profile', None)
                graduation_forms.append({
                    'graduation': graduation,
                    'student': graduation.user,
                    'profile': profile
                })
            except GraduationForm.DoesNotExist:
                continue
    
        if not graduation_forms:
            return JsonResponse({'error': 'No valid graduation forms found'}, status=400)
        
        context = {
            'graduation_forms': graduation_forms,
            'is_preview': True,
        }
        
        return render(request, 'pdf/pdf-graduation.html', context)
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def signatory_reports(request):
    """Signatory Reports View"""
    if request.user.user_type != 'signatory':
        return redirect('login')
    
    try:
        # Get signatory profile
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        
        context = {
            'signatory_profile': signatory_profile,
        }
        
        return render(request, 'SIGNATORYREPORTS.html', context)
        
    except Exception as e:
        print(f"Error in signatory_reports: {e}")
        return render(request, 'SIGNATORYREPORTS.html', {})


@login_required
def signatory_reports_data_api(request):
    """API endpoint to get reports data for signatory (original behavior: own activity logs)."""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get filter parameters
        from_date = request.GET.get('from_date', '')
        to_date = request.GET.get('to_date', '')
        form_status = request.GET.get('form_status', '')
        period_type = request.GET.get('period_type', '')
        
        # Get activity logs for this signatory
        activity_logs = SignatoryActivityLog.objects.filter(
            signatory=request.user
        )
        
        # Apply date filters
        if from_date:
            activity_logs = activity_logs.filter(created_at__date__gte=from_date)
        
        if to_date:
            activity_logs = activity_logs.filter(created_at__date__lte=to_date)
        
        # Apply form status filter
        if form_status:
            if form_status in ['approve', 'disapprove', 'view']:
                activity_logs = activity_logs.filter(action_type=form_status)
        
        # Apply period filter
        if period_type:
            from datetime import datetime, timezone as dt_timezone, timedelta
            today = timezone.now().date()
            
            if period_type == 'day':
                activity_logs = activity_logs.filter(created_at__date=today)
            elif period_type == 'week':
                week_ago = today - timedelta(days=7)
                activity_logs = activity_logs.filter(created_at__date__gte=week_ago)
            elif period_type == 'month':
                month_ago = today - timedelta(days=30)
                activity_logs = activity_logs.filter(created_at__date__gte=month_ago)
        
        # Prepare data for response (matches signatory frontend expectations)
        reports_data = []
        for log in activity_logs:
            reports_data.append({
                'id': str(log.id),
                'student_name': log.student_name,
                'form_type': log.get_form_type_display(),
                'action_type': log.get_action_type_display(),
                'date': log.created_at.strftime('%Y-%m-%d'),
                'time': log.created_at.strftime('%I:%M %p'),
                'ip_address': log.ip_address or 'N/A',
                'signatory': log.signatory.full_name,
            })
        
        return JsonResponse({
            'success': True,
            'reports': reports_data,
        })
        
    except Exception as e:
        print(f"Error in signatory_reports_data_api: {e}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def registrar_reports_data_api(request):
    """Enhanced API endpoint to get a unified, paginated activity feed for admin/registrar reports tab."""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)

    try:
        from datetime import datetime, timezone as dt_timezone, timedelta
        from django.core.paginator import Paginator
        from django.db.models import Q
        import logging
        logger = logging.getLogger(__name__)

        # Validate and normalize parameters - ignore empty strings
        from_date = request.GET.get('from_date', '').strip() or ''
        to_date = request.GET.get('to_date', '').strip() or ''
        form_status = (request.GET.get('form_status', '').strip() or request.GET.get('action_type', '').strip()) or ''
        period_type = request.GET.get('period_type', '').strip() or ''
        role_filter = request.GET.get('role', '').strip() or ''
        form_type = request.GET.get('form_type', '').strip() or ''
        text_search = (request.GET.get('q', '').strip() or request.GET.get('search', '').strip()) or ''
        
        # Log normalized parameters for diagnostics
        logger.info(f"Reports API params: form_type={form_type}, from_date={from_date}, to_date={to_date}, page={request.GET.get('page', 1)}")
        
        # Validate form_type
        valid_form_types = ['clearance', 'enrollment', 'graduation', 'doc_release', 'document_release', 'all', '']
        if form_type and form_type not in valid_form_types:
            return JsonResponse({'error': f'Invalid form_type. Must be one of: {valid_form_types}'}, status=400)
        
        # Normalize form_type
        if form_type == 'doc_release':
            form_type = 'document_release'
        elif form_type == 'all':
            form_type = ''
        
        # Validate and parse page parameters
        try:
            page = max(1, int(request.GET.get('page', 1)))
        except (ValueError, TypeError):
            return JsonResponse({'error': 'Invalid page parameter'}, status=400)
            
        try:
            per_page = max(1, min(100, int(request.GET.get('per_page', 20))))
        except (ValueError, TypeError):
            return JsonResponse({'error': 'Invalid per_page parameter'}, status=400)
        
        # Validate date formats - handle empty dates defensively
        from_date_obj = None
        to_date_obj = None
        
        if from_date and from_date.strip():
            try:
                from_date_obj = datetime.strptime(from_date.strip(), '%Y-%m-%d').date()
            except (ValueError, AttributeError) as e:
                logger.warning(f"Invalid from_date '{from_date}': {e}")
                return JsonResponse({'error': 'Invalid from_date format. Use YYYY-MM-DD'}, status=400)
        
        if to_date and to_date.strip():
            try:
                to_date_obj = datetime.strptime(to_date.strip(), '%Y-%m-%d').date()
            except (ValueError, AttributeError) as e:
                logger.warning(f"Invalid to_date '{to_date}': {e}")
                return JsonResponse({'error': 'Invalid to_date format. Use YYYY-MM-DD'}, status=400)
        
        # Validate date range
        if from_date_obj and to_date_obj and from_date_obj > to_date_obj:
            return JsonResponse({'error': 'from_date cannot be after to_date'}, status=400)

        sig_qs = SignatoryActivityLog.objects.select_related('signatory')
        aud_qs = AuditLog.objects.select_related('user')

        # Apply date filters with timezone-safe handling
        if from_date_obj:
            sig_qs = sig_qs.filter(created_at__date__gte=from_date_obj)
            aud_qs = aud_qs.filter(timestamp__date__gte=from_date_obj)

        if to_date_obj:
            # Include full day up to 23:59:59 in server timezone
            import pytz
            from django.conf import settings
            
            to_date_end = datetime.combine(to_date_obj, datetime.max.time().replace(microsecond=0))
            
            # Make timezone-aware if USE_TZ is enabled
            if getattr(settings, 'USE_TZ', False):
                tz = pytz.timezone(getattr(settings, 'TIME_ZONE', 'UTC'))
                to_date_end = tz.localize(to_date_end)
            
            sig_qs = sig_qs.filter(created_at__lte=to_date_end)
            aud_qs = aud_qs.filter(timestamp__lte=to_date_end)

        # Apply period filters
        if period_type:
            today = timezone.now().date()
            if period_type == 'day':
                sig_qs = sig_qs.filter(created_at__date=today)
                aud_qs = aud_qs.filter(timestamp__date=today)
            elif period_type == 'week':
                week_ago = today - timedelta(days=7)
                sig_qs = sig_qs.filter(created_at__date__gte=week_ago)
                aud_qs = aud_qs.filter(timestamp__date__gte=week_ago)
            elif period_type == 'month':
                month_ago = today - timedelta(days=30)
                sig_qs = sig_qs.filter(created_at__date__gte=month_ago)
                aud_qs = aud_qs.filter(timestamp__date__gte=month_ago)

        # Apply action type filter
        if form_status in {'approve', 'disapprove', 'view', 'print', 'delete'}:
            sig_qs = sig_qs.filter(action_type=form_status)
            # Filter AuditLog for relevant system actions
            if form_status == 'approve':
                aud_qs = aud_qs.filter(action_type__icontains='approval')
            elif form_status == 'disapprove':
                aud_qs = aud_qs.filter(action_type__icontains='disapproval')
            else:
                aud_qs = AuditLog.objects.none()

        # Apply role filter
        if role_filter:
            if role_filter == 'signatory':
                aud_qs = AuditLog.objects.none()
            elif role_filter in ['admin', 'registrar']:
                sig_qs = SignatoryActivityLog.objects.none()
                aud_qs = aud_qs.filter(user__user_type=role_filter)
            elif role_filter == 'system':
                sig_qs = SignatoryActivityLog.objects.none()
                aud_qs = aud_qs.filter(user__isnull=True)

        # Apply form type filter - only use valid fields
        if form_type:
            if form_type == 'clearance':
                sig_qs = sig_qs.filter(form_type__icontains='clearance')
                aud_qs = aud_qs.filter(description__icontains='clearance')
            elif form_type == 'enrollment':
                sig_qs = sig_qs.filter(form_type__icontains='enrollment')
                aud_qs = aud_qs.filter(description__icontains='enrollment')
            elif form_type == 'graduation':
                sig_qs = sig_qs.filter(form_type__icontains='graduation')
                aud_qs = aud_qs.filter(description__icontains='graduation')
            elif form_type == 'document_release':
                sig_qs = sig_qs.filter(form_type__icontains='document')
                aud_qs = aud_qs.filter(description__icontains='document')

        # Apply text search
        if text_search:
            # Search in signatory logs
            sig_q = (
                Q(signatory__full_name__icontains=text_search) |
                Q(student_name__icontains=text_search) |
                Q(form_type__icontains=text_search) |
                Q(action_type__icontains=text_search)
            )
            sig_qs = sig_qs.filter(sig_q)
            
            # Search in audit logs
            aud_q = (
                Q(user__full_name__icontains=text_search) |
                Q(action_type__icontains=text_search) |
                Q(description__icontains=text_search)
            )
            aud_qs = aud_qs.filter(aud_q)

        # Build unified feed
        feed = []
        
        # Get student course lookup for performance
        student_names = [log.student_name for log in sig_qs if log.student_name]
        student_course_map = {}
        if student_names:
            from landing.models import User, StudentProfile
            student_profiles = StudentProfile.objects.select_related('user').filter(
                user__full_name__in=student_names
            )
            student_course_map = {
                profile.user.full_name: profile.program 
                for profile in student_profiles
            }
        
        # Add signatory activities
        for log in sig_qs:
            user_role = getattr(log.signatory, 'user_type', 'signatory')
            student_course = student_course_map.get(log.student_name, '') if log.student_name else ''
            feed.append({
                'timestamp': log.created_at,
                'user_display': getattr(log.signatory, 'full_name', 'Unknown'),
                'role': user_role,
                'action_type': log.action_type,
                'entity_type': log.form_type,
                'entity_id': str(log.form_id),
                'entity_ref': log.student_name,
                'student_course': student_course,
                'student_name': log.student_name,  # Add explicit student_name field
                'form_type_display': log.get_form_type_display(),
                'metadata': {
                    'form_type_display': log.get_form_type_display(),
                    'action_display': log.get_action_type_display(),
                    'user_agent': log.user_agent,
                    'location_data': log.location_data
                },
                'ip_address': log.ip_address or None,
                'source': 'activity_log'
            })

        # Add audit log activities  
        for log in aud_qs:
            user_role = getattr(log.user, 'user_type', 'system') if log.user else 'system'
            feed.append({
                'timestamp': log.timestamp,
                'user_display': getattr(log.user, 'full_name', 'System') if log.user else 'System',
                'role': user_role,
                'action_type': log.action_type,
                'entity_type': 'system',
                'entity_id': None,
                'entity_ref': None,
                'student_course': '',
                'student_name': '',  # Add explicit student_name field for system logs
                'form_type_display': 'System',
                'metadata': {
                    'description': log.description,
                    'action_display': log.action_type.replace('_', ' ').title()
                },
                'ip_address': extract_ip_from_description(log.description),
                'source': 'audit_log'
            })

        # Add Document Release activities
        if not form_type or form_type == 'document_release':
            from landing.models import DocumentRequest, StudentProfile
            doc_qs = DocumentRequest.objects.select_related('requester')
            
            # Apply date filters to document requests
            if from_date:
                try:
                    from_date_obj = datetime.strptime(from_date, '%Y-%m-%d').date()
                    doc_qs = doc_qs.filter(created_at__date__gte=from_date_obj)
                except ValueError:
                    pass
            
            if to_date:
                try:
                    to_date_obj = datetime.strptime(to_date, '%Y-%m-%d').date()
                    doc_qs = doc_qs.filter(created_at__date__lte=to_date_obj)
                except ValueError:
                    pass
            
            # Apply period filters
            if period_type:
                today = timezone.now().date()
                if period_type == 'day':
                    doc_qs = doc_qs.filter(created_at__date=today)
                elif period_type == 'week':
                    week_ago = today - timedelta(days=7)
                    doc_qs = doc_qs.filter(created_at__date__gte=week_ago)
                elif period_type == 'month':
                    month_ago = today - timedelta(days=30)
                    doc_qs = doc_qs.filter(created_at__date__gte=month_ago)
            
            # Apply text search
            if text_search:
                doc_q = (
                    Q(requester__full_name__icontains=text_search) |
                    Q(document_type__icontains=text_search) |
                    Q(purpose__icontains=text_search) |
                    Q(status__icontains=text_search)
                )
                doc_qs = doc_qs.filter(doc_q)
            
            # Add document request activities
            for doc_req in doc_qs:
                # Get requester course info
                requester_course = ''
                try:
                    student_profile = StudentProfile.objects.select_related('user').get(user=doc_req.requester)
                    requester_course = student_profile.program
                except StudentProfile.DoesNotExist:
                    pass
                
                # Map status to action type
                status_action_map = {
                    'draft': 'Created',
                    'pending': 'Submitted', 
                    'processing': 'Processing',
                    'ready': 'Approved',
                    'released': 'Released',
                    'blocked_due_to_balance': 'Blocked'
                }
                
                action_display = status_action_map.get(doc_req.status, doc_req.status.title())
                
                feed.append({
                    'timestamp': doc_req.updated_at,  # Use updated_at for status changes
                    'user_display': doc_req.requester.full_name,
                    'role': 'student',
                    'action_type': doc_req.status,
                    'entity_type': 'document_request',
                    'entity_id': str(doc_req.id),
                    'entity_ref': doc_req.requester.full_name,
                    'student_course': requester_course,
                    'student_name': doc_req.requester.full_name,
                    'form_type_display': 'Document Release',
                    'metadata': {
                        'document_type': doc_req.document_type,
                        'status': doc_req.status,
                        'action_display': action_display,
                        'purpose': doc_req.purpose or '',
                        'preferred_release': str(doc_req.preferred_release) if doc_req.preferred_release else ''
                    },
                    'ip_address': None,  # Document requests don't track IP
                    'source': 'document_request'
                })

        # Sort by timestamp (most recent first)
        feed.sort(key=lambda x: x['timestamp'], reverse=True)

        # Apply pagination
        paginator = Paginator(feed, per_page)
        page_obj = paginator.get_page(page)
        
        # Log queryset counts for diagnostics
        logger.info(f"Queryset counts: feed_total={len(feed)}, paginated_count={paginator.count}, page={page_obj.number}/{paginator.num_pages}")
        
        # Format response
        activities = []
        for item in page_obj:
            activities.append({
                'timestamp': item['timestamp'].strftime('%Y-%m-%d %H:%M:%S'),
                'user_display': item['user_display'],
                'role': item['role'],
                'action_type': item['action_type'],
                'entity_type': item['entity_type'],
                'entity_id': item['entity_id'],
                'entity_ref': item['entity_ref'],
                'student_course': item.get('student_course', ''),
                'student_name': item.get('student_name', ''),
                'form_type_display': item.get('form_type_display', ''),
                'metadata': item['metadata'],
                'ip_address': item['ip_address'],
                'source': item['source'],
                # Legacy format for existing frontend
                'actor': item['user_display'],
                'activity': item['metadata'].get('action_display', item['action_type']),
                'details': f"{item['metadata'].get('form_type_display', item['entity_type'])} • {item['entity_ref']}" if item['entity_ref'] else item['metadata'].get('description', ''),
                'date': item['timestamp'].strftime('%Y-%m-%d'),
                'time': item['timestamp'].strftime('%I:%M %p'),
            })

        return JsonResponse({
            'success': True,
            'items': activities,
            'count': paginator.count,
            'page': page_obj.number,
            'pages': paginator.num_pages,
            # Legacy compatibility
            'reports': activities,
            'pagination': {
                'current_page': page_obj.number,
                'total_pages': paginator.num_pages,
                'total_items': paginator.count
            }
        })

    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Error in registrar_reports_data_api: {e}", exc_info=True)
        return JsonResponse({'error': 'Internal server error'}, status=500)


@login_required
def registrar_reports_csv_export(request):
    """CSV export endpoint for activity stream data"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        import csv
        from django.http import HttpResponse
        from datetime import datetime, timezone as dt_timezone, timedelta
        from django.db.models import Q
        
        # Get same parameters as main API (without pagination)
        from_date = request.GET.get('from_date', '')
        to_date = request.GET.get('to_date', '')
        form_status = request.GET.get('form_status', '') or request.GET.get('action_type', '')
        period_type = request.GET.get('period_type', '')
        role_filter = request.GET.get('role', '')
        text_search = request.GET.get('q', '').strip() or request.GET.get('search', '').strip()

        sig_qs = SignatoryActivityLog.objects.select_related('signatory')
        aud_qs = AuditLog.objects.select_related('user')

        # Apply same filters as main API
        if from_date:
            try:
                from_date_obj = datetime.strptime(from_date, '%Y-%m-%d').date()
                sig_qs = sig_qs.filter(created_at__date__gte=from_date_obj)
                aud_qs = aud_qs.filter(timestamp__date__gte=from_date_obj)
            except ValueError:
                pass

        if to_date:
            try:
                to_date_obj = datetime.strptime(to_date, '%Y-%m-%d').date()
                sig_qs = sig_qs.filter(created_at__date__lte=to_date_obj)
                aud_qs = aud_qs.filter(timestamp__date__lte=to_date_obj)
            except ValueError:
                pass

        if period_type:
            today = timezone.now().date()
            if period_type == 'day':
                sig_qs = sig_qs.filter(created_at__date=today)
                aud_qs = aud_qs.filter(timestamp__date=today)
            elif period_type == 'week':
                week_ago = today - timedelta(days=7)
                sig_qs = sig_qs.filter(created_at__date__gte=week_ago)
                aud_qs = aud_qs.filter(timestamp__date__gte=week_ago)
            elif period_type == 'month':
                month_ago = today - timedelta(days=30)
                sig_qs = sig_qs.filter(created_at__date__gte=month_ago)
                aud_qs = aud_qs.filter(timestamp__date__gte=month_ago)

        if form_status in {'approve', 'disapprove', 'view', 'print', 'delete'}:
            sig_qs = sig_qs.filter(action_type=form_status)
            if form_status == 'approve':
                aud_qs = aud_qs.filter(action_type__icontains='approval')
            elif form_status == 'disapprove':
                aud_qs = aud_qs.filter(action_type__icontains='disapproval')
            else:
                aud_qs = AuditLog.objects.none()

        if role_filter:
            if role_filter == 'signatory':
                aud_qs = AuditLog.objects.none()
            elif role_filter in ['admin', 'registrar']:
                sig_qs = SignatoryActivityLog.objects.none()
                aud_qs = aud_qs.filter(user__user_type=role_filter)
            elif role_filter == 'system':
                sig_qs = SignatoryActivityLog.objects.none()
                aud_qs = aud_qs.filter(user__isnull=True)

        if text_search:
            sig_q = (
                Q(signatory__full_name__icontains=text_search) |
                Q(student_name__icontains=text_search) |
                Q(form_type__icontains=text_search) |
                Q(action_type__icontains=text_search)
            )
            sig_qs = sig_qs.filter(sig_q)
            
            aud_q = (
                Q(user__full_name__icontains=text_search) |
                Q(action_type__icontains=text_search) |
                Q(description__icontains=text_search)
            )
            aud_qs = aud_qs.filter(aud_q)

        # Build unified feed for CSV export
        feed = []
        
        # Get student course lookup for CSV export
        student_names = [log.student_name for log in sig_qs if log.student_name]
        student_course_map = {}
        if student_names:
            from landing.models import User, StudentProfile
            student_profiles = StudentProfile.objects.select_related('user').filter(
                user__full_name__in=student_names
            )
            student_course_map = {
                profile.user.full_name: profile.program 
                for profile in student_profiles
            }
        
        for log in sig_qs:
            student_course = student_course_map.get(log.student_name, '') if log.student_name else ''
            feed.append({
                'timestamp': log.created_at,
                'user_display': getattr(log.signatory, 'full_name', 'Unknown'),
                'role': getattr(log.signatory, 'user_type', 'signatory'),
                'action_type': log.action_type,
                'entity_type': log.form_type,
                'entity_ref': log.student_name,
                'student_course': student_course,
                'ip_address': log.ip_address or '',
                'source': 'activity_log',
                'details': f"{log.get_action_type_display()} {log.get_form_type_display()}"
            })

        for log in aud_qs:
            feed.append({
                'timestamp': log.timestamp,
                'user_display': getattr(log.user, 'full_name', 'System') if log.user else 'System',
                'role': getattr(log.user, 'user_type', 'system') if log.user else 'system',
                'action_type': log.action_type,
                'entity_type': 'system',
                'entity_ref': '',
                'student_course': '',
                'ip_address': extract_ip_from_description(log.description) or '',
                'source': 'audit_log',
                'details': log.description or ''
            })

        # Sort by timestamp (most recent first)
        feed.sort(key=lambda x: x['timestamp'], reverse=True)

        # Generate CSV response
        response = HttpResponse(content_type='text/csv')
        timestamp_str = timezone.now().strftime('%Y%m%d_%H%M%S')
        response['Content-Disposition'] = f'attachment; filename="activity_report_{timestamp_str}.csv"'

        writer = csv.writer(response)
        writer.writerow([
            'Timestamp', 'User', 'Role', 'Action', 'Student Name', 
            'Course', 'Requested Form', 'IP Address', 'Source'
        ])

        for item in feed:
            writer.writerow([
                item['timestamp'].strftime('%Y-%m-%d %H:%M:%S'),
                item['user_display'],
                item['role'],
                item['action_type'],
                item['entity_ref'],  # Student name
                item['student_course'],  # Course
                item['details'][:200],  # Requested form (truncated)
                item['ip_address'],
                item['source']
            ])

        return response

    except Exception as e:
        import traceback
        print(f"Error in registrar_reports_csv_export: {e}")
        print(traceback.format_exc())
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def registrar_forms_list_api(request):
    """API endpoint to list forms for the selected type, ordered by date desc, paginated"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from django.core.paginator import Paginator
        from datetime import datetime, timezone as dt_timezone
        import logging
        logger = logging.getLogger(__name__)

        # Get filter parameters
        form_type = request.GET.get('form_type', '').strip()
        page = int(request.GET.get('page', 1))
        per_page = min(50, int(request.GET.get('per_page', 20)))

        # Validate form_type
        if not form_type or form_type not in ['clearance', 'enrollment', 'graduation', 'doc_release']:
            return JsonResponse({'error': 'Valid form_type required: clearance, enrollment, graduation, doc_release'}, status=400)

        # Map doc_release to document_request for consistency
        if form_type == 'doc_release':
            form_type = 'document_request'

        # Get forms based on type, ordered by date desc
        if form_type == 'clearance':
            forms_qs = ClearanceForm.objects.select_related('student').order_by('-submitted_at')
            form_model_name = 'clearance'
        elif form_type == 'enrollment':
            forms_qs = EnrollmentForm.objects.select_related('user').order_by('-created_at')
            form_model_name = 'enrollment'
        elif form_type == 'graduation':
            forms_qs = GraduationForm.objects.select_related('user').order_by('-created_at')
            form_model_name = 'graduation'
        elif form_type == 'document_request':
            forms_qs = DocumentRequest.objects.select_related('requester').order_by('-created_at')
            form_model_name = 'doc_release'
        else:
            return JsonResponse({'error': 'Unsupported form type'}, status=400)

        # Apply pagination
        paginator = Paginator(forms_qs, per_page)
        total_count = paginator.count
        total_pages = paginator.num_pages

        if page > total_pages and total_count > 0:
            return JsonResponse({'error': f'Page {page} out of range (max: {total_pages})'}, status=400)

        forms_page = paginator.get_page(page)

        # Build response items
        items = []
        for form in forms_page:
            # Extract common fields based on form type
            if form_model_name == 'clearance':
                form_id = str(form.id)
                title = f"Clearance - {form.clearance_type.title()}"
                requester = form.student.full_name
                date = form.submitted_at
                status = form.status
            elif form_model_name == 'enrollment':
                form_id = str(form.id)
                title = f"Enrollment - {form.course} Year {form.year}"
                requester = form.user.full_name
                date = form.created_at
                status = form.status
            elif form_model_name == 'graduation':
                form_id = str(form.id)
                title = f"Graduation - {form.grad_appno}"
                requester = form.user.full_name
                date = form.created_at
                status = form.status
            elif form_model_name == 'doc_release':
                form_id = str(form.id)
                title = f"Document - {form.document_type}"
                requester = form.requester.full_name
                date = form.created_at
                status = form.status

            # Create URLs for download (PDF) and view actions
            download_url = f"/registrar/forms/{form_model_name}/{form_id}/download/"
            view_url = f"/registrar/forms/{form_model_name}/{form_id}/view/"

            items.append({
                'id': form_id,
                'form_type': form_model_name,
                'title': title,
                'requester': requester,
                'date': date.strftime('%Y-%m-%d %H:%M:%S') if date else 'N/A',
                'status': status.title() if status else 'Unknown',
                'download_url': download_url,
                'view_url': view_url
            })

        logger.info(f"Forms list: {form_type}, page {page}/{total_pages}, {len(items)} items")

        return JsonResponse({
            'success': True,
            'items': items,
            'count': total_count,
            'page': page,
            'pages': total_pages,
            'per_page': per_page
        })

    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Error in registrar_forms_list_api: {e}", exc_info=True)
        return JsonResponse({'error': 'Internal server error'}, status=500)


@login_required  
def registrar_form_download(request, form_type, form_id):
    """Download individual form as PDF"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from django.template.loader import render_to_string
        from django.http import HttpResponse
        import logging
        logger = logging.getLogger(__name__)

        # Validate form_type
        if form_type not in ['clearance', 'enrollment', 'graduation', 'doc_release']:
            return JsonResponse({'error': 'Invalid form type'}, status=400)

        # Get the form based on type
        form_obj = None
        template_name = None
        
        if form_type == 'clearance':
            form_obj = ClearanceForm.objects.select_related('student').get(id=form_id)
            template_name = 'pdf/pdf-clearance.html'
            filename_prefix = f"clearance_{form_obj.clearance_type}"
        elif form_type == 'enrollment':
            form_obj = EnrollmentForm.objects.select_related('user').get(id=form_id)
            template_name = 'pdf/pdf-enrollment.html'
            filename_prefix = "enrollment"
        elif form_type == 'graduation':
            form_obj = GraduationForm.objects.select_related('user').get(id=form_id)
            template_name = 'pdf/pdf-graduation.html'
            filename_prefix = "graduation"
        elif form_type == 'doc_release':
            form_obj = DocumentRequest.objects.select_related('requester').get(id=form_id)
            template_name = 'pdf/document-request.html'  # Keep this for now as there may not be a pdf-document template
            filename_prefix = "document_request"

        # Prepare context for template
        context = {
            'form': form_obj,
            'user': form_obj.student if hasattr(form_obj, 'student') else (
                form_obj.user if hasattr(form_obj, 'user') else form_obj.requester),
            'generated_at': timezone.now(),
            'generated_by': request.user.full_name
        }

        # Render HTML content
        html_content = render_to_string(template_name, context, request=request)

        # Convert to PDF
        pdf_content = convert_html_to_pdf(html_content)

        # Create filename
        date_str = timezone.now().strftime('%Y-%m-%d')
        filename = f"{filename_prefix}_{form_id}_{date_str}.pdf"

        # Return PDF response
        response = HttpResponse(pdf_content, content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="{filename}"'

        logger.info(f"Form downloaded as PDF: {form_type} {form_id} by {request.user.username}")
        return response

    except (ClearanceForm.DoesNotExist, EnrollmentForm.DoesNotExist, 
            GraduationForm.DoesNotExist, DocumentRequest.DoesNotExist):
        return JsonResponse({'error': 'Form not found'}, status=404)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Error in registrar_form_download: {e}", exc_info=True)
        return JsonResponse({'error': 'Internal server error'}, status=500)


@login_required
def registrar_form_view(request, form_type, form_id):
    """View individual form (redirect to existing form view or render basic info)"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # For now, return basic form info as JSON (could be enhanced to return HTML view)
        if form_type not in ['clearance', 'enrollment', 'graduation', 'doc_release']:
            return JsonResponse({'error': 'Invalid form type'}, status=400)

        # Get the form based on type
        if form_type == 'clearance':
            form_obj = ClearanceForm.objects.select_related('student').get(id=form_id)
            form_info = {
                'id': str(form_obj.id),
                'type': 'clearance',
                'clearance_type': form_obj.clearance_type,
                'student': form_obj.student.full_name,
                'semester': form_obj.semester,
                'status': form_obj.status,
                'submitted_at': form_obj.submitted_at.isoformat() if form_obj.submitted_at else None
            }
        elif form_type == 'enrollment':
            form_obj = EnrollmentForm.objects.select_related('user').get(id=form_id)
            form_info = {
                'id': str(form_obj.id),
                'type': 'enrollment',
                'student': form_obj.user.full_name,
                'course': form_obj.course,
                'year': form_obj.year,
                'status': form_obj.status,
                'created_at': form_obj.created_at.isoformat()
            }
        elif form_type == 'graduation':
            form_obj = GraduationForm.objects.select_related('user').get(id=form_id)
            form_info = {
                'id': str(form_obj.id),
                'type': 'graduation',
                'student': form_obj.user.full_name,
                'grad_appno': form_obj.grad_appno,
                'status': form_obj.status,
                'created_at': form_obj.created_at.isoformat()
            }
        elif form_type == 'doc_release':
            form_obj = DocumentRequest.objects.select_related('requester').get(id=form_id)
            form_info = {
                'id': str(form_obj.id),
                'type': 'document_request',
                'requester': form_obj.requester.full_name,
                'document_type': form_obj.document_type,
                'status': form_obj.status,
                'created_at': form_obj.created_at.isoformat()
            }

        return JsonResponse({'success': True, 'form': form_info})

    except (ClearanceForm.DoesNotExist, EnrollmentForm.DoesNotExist, 
            GraduationForm.DoesNotExist, DocumentRequest.DoesNotExist):
        return JsonResponse({'error': 'Form not found'}, status=404)
    except Exception as e:
        import logging
        logger = logging.getLogger(__name__)
        logger.error(f"Error in registrar_form_view: {e}", exc_info=True)
        return JsonResponse({'error': 'Internal server error'}, status=500)


@login_required
def registrar_reports_list_api(request):
    """API endpoint to list generated report files from unified GeneratedReport model"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get all reports from unified model, ordered by most recent
        all_reports = GeneratedReport.objects.all().order_by('-created_at')
        
        # Get filter parameters
        report_type_filter = request.GET.get('report_type', '')
        generation_type_filter = request.GET.get('generation_type', '')  # manual/auto
        
        # Apply filters
        if report_type_filter:
            all_reports = all_reports.filter(report_type=report_type_filter)
        
        if generation_type_filter == 'manual':
            all_reports = all_reports.filter(generated_by__isnull=False)
        elif generation_type_filter == 'auto':
            all_reports = all_reports.filter(generated_by__isnull=True)
        
        reports = []
        
        for report in all_reports:
            # Determine if it's auto or manual based on generated_by field
            is_auto = report.generated_by is None
            
            # Get file information using FileField
            file_size = report.size_bytes or 0
            exists = report.file_exists
            download_url = report.file.url if exists and report.file else None
            filename = report.file.name.split('/')[-1] if report.file else 'N/A'
            
            # Format date range
            date_range = 'N/A'
            if report.period_start and report.period_end:
                date_range = f"{report.period_start} to {report.period_end}"
            
            # Format report type display
            report_type_display = report.get_report_type_display() if hasattr(report, 'get_report_type_display') else report.report_type.title()
            
            reports.append({
                'id': str(report.id),
                'type': 'auto' if is_auto else 'manual',
                'report_type': report_type_display,
                'period_type': 'Weekly' if is_auto else 'Custom',
                'filename': filename,
                'generated_at': report.created_at.strftime('%Y-%m-%d %H:%M:%S'),
                'date_range': date_range,
                'file_size': file_size,
                'exists': exists,
                'download_url': download_url,
                'generated_by': report.generated_by.full_name if report.generated_by else 'System (Auto)',
                'status': report.status,
                'notes': report.notes or ''
            })
        
        return JsonResponse({
            'success': True,
            'reports': reports[:50]  # Limit to 50 most recent
        })
        
    except Exception as e:
        import traceback
        print(f"Error in registrar_reports_list_api: {e}")
        print(traceback.format_exc())
        return JsonResponse({'error': str(e)}, status=500)


def get_forms_data_for_report(form_type=None, from_date=None, to_date=None, form_status=None, text_search=None):
    """
    Query actual form records (ClearanceForm, EnrollmentForm, etc.) for reports.
    Used when form_type is selected to match table behavior exactly.
    """
    from datetime import datetime, timezone as dt_timezone
    from django.db.models import Q
    
    if not form_type or form_type not in ['clearance', 'enrollment', 'graduation', 'document_release']:
        return []
    
    # Map form_type to model and normalize
    form_type_normalized = 'document_request' if form_type == 'document_release' else form_type
    
    # Date filtering
    date_filters = {}
    if from_date:
        try:
            from_date_obj = datetime.strptime(from_date, '%Y-%m-%d').date()
            if form_type_normalized == 'clearance':
                date_filters['submitted_at__date__gte'] = from_date_obj
            else:
                date_filters['created_at__date__gte'] = from_date_obj
        except ValueError:
            pass
    
    if to_date:
        try:
            to_date_obj = datetime.strptime(to_date, '%Y-%m-%d').date()
            # Include full day up to 23:59:59 for timezone-safe filtering
            import pytz
            from django.conf import settings
            to_date_end = datetime.combine(to_date_obj, datetime.max.time().replace(microsecond=0))
            
            # Make timezone-aware if USE_TZ is enabled
            if getattr(settings, 'USE_TZ', False):
                tz = pytz.timezone(getattr(settings, 'TIME_ZONE', 'UTC'))
                to_date_end = tz.localize(to_date_end)
            
            if form_type_normalized == 'clearance':
                date_filters['submitted_at__lte'] = to_date_end
            else:
                date_filters['created_at__lte'] = to_date_end
        except ValueError:
            pass
    
    # Query based on form type
    forms = []
    if form_type_normalized == 'clearance':
        qs = ClearanceForm.objects.select_related('student').filter(**date_filters)
        if form_status:
            qs = qs.filter(status__icontains=form_status)
        if text_search:
            qs = qs.filter(
                Q(student__full_name__icontains=text_search) |
                Q(clearance_type__icontains=text_search) |
                Q(status__icontains=text_search)
            )
        forms = qs.order_by('-submitted_at', '-id')
        
    elif form_type_normalized == 'enrollment':
        qs = EnrollmentForm.objects.select_related('user').filter(**date_filters)
        if form_status:
            qs = qs.filter(status__icontains=form_status)
        if text_search:
            qs = qs.filter(
                Q(user__full_name__icontains=text_search) |
                Q(course__icontains=text_search) |
                Q(status__icontains=text_search)
            )
        forms = qs.order_by('-created_at', '-id')
        
    elif form_type_normalized == 'graduation':
        qs = GraduationForm.objects.select_related('user').filter(**date_filters)
        if form_status:
            qs = qs.filter(status__icontains=form_status)
        if text_search:
            qs = qs.filter(
                Q(user__full_name__icontains=text_search) |
                Q(grad_appno__icontains=text_search) |
                Q(status__icontains=text_search)
            )
        forms = qs.order_by('-created_at', '-id')
        
    elif form_type_normalized == 'document_request':
        qs = DocumentRequest.objects.select_related('requester').filter(**date_filters)
        if form_status:
            qs = qs.filter(status__icontains=form_status)
        if text_search:
            qs = qs.filter(
                Q(requester__full_name__icontains=text_search) |
                Q(document_type__icontains=text_search) |
                Q(status__icontains=text_search)
            )
        forms = qs.order_by('-created_at', '-id')
    
    # Convert to standardized format for report template
    activities = []
    for form in forms:
        if form_type_normalized == 'clearance':
            activities.append({
                'student_name': form.student.full_name if form.student else 'N/A',
                'form_type': 'clearance',
                'form_type_display': 'Clearance',
                'action_type': 'submitted',
                'activity': 'submitted',
                'status': form.status or 'unknown',
                'signatory_name': 'Student',
                'timestamp': form.submitted_at,
                'ip_address': getattr(form, 'ip_address', None),
                'details': f"Clearance Type: {form.clearance_type or 'N/A'}",
                'source': 'form_data',
                'reference_id': str(form.id)
            })
        elif form_type_normalized == 'enrollment':
            activities.append({
                'student_name': form.user.full_name if form.user else 'N/A',
                'form_type': 'enrollment',
                'form_type_display': 'Enrollment',
                'action_type': 'submitted',
                'activity': 'submitted',
                'status': form.status or 'unknown',
                'signatory_name': 'Student',
                'timestamp': form.created_at,
                'ip_address': None,
                'details': f"Course: {form.course or 'N/A'}, Year: {form.year or 'N/A'}",
                'source': 'form_data',
                'reference_id': str(form.id)
            })
        elif form_type_normalized == 'graduation':
            activities.append({
                'student_name': form.user.full_name if form.user else 'N/A',
                'form_type': 'graduation',
                'form_type_display': 'Graduation',
                'action_type': 'submitted',
                'activity': 'submitted',
                'status': form.status or 'unknown',
                'signatory_name': 'Student',
                'timestamp': form.created_at,
                'ip_address': None,
                'details': f"Graduation App No: {form.grad_appno or 'N/A'}",
                'source': 'form_data',
                'reference_id': str(form.id)
            })
        elif form_type_normalized == 'document_request':
            activities.append({
                'student_name': form.requester.full_name if form.requester else 'N/A',
                'form_type': 'document_release',
                'form_type_display': 'Document Release',
                'action_type': 'requested',
                'activity': 'requested',
                'status': form.status or 'unknown',
                'signatory_name': 'Student',
                'timestamp': form.created_at,
                'ip_address': None,
                'details': f"Document Type: {form.document_type or 'N/A'}",
                'source': 'form_data',
                'reference_id': str(form.id)
            })
    
    return activities


def get_activity_data_for_report(form_type=None, from_date=None, to_date=None, form_status=None, 
                                 period_type=None, role_filter=None, text_search=None, signatory=None):
    """
    Unified function to query activity data for reports.
    Returns a list of standardized activity records for PDF generation.
    """
    from datetime import datetime, timezone as dt_timezone, timedelta
    from django.db.models import Q
    
    # Build base querysets
    sig_qs = SignatoryActivityLog.objects.select_related('signatory')
    aud_qs = AuditLog.objects.select_related('user')
    
    # Apply signatory filter if specified
    if signatory:
        sig_qs = sig_qs.filter(signatory=signatory)
        # For signatory-specific reports, exclude system audit logs
        aud_qs = AuditLog.objects.none()
    
    # Apply date filters with timezone-safe handling
    if from_date:
        try:
            from_date_obj = datetime.strptime(from_date, '%Y-%m-%d').date()
            sig_qs = sig_qs.filter(created_at__date__gte=from_date_obj)
            aud_qs = aud_qs.filter(timestamp__date__gte=from_date_obj)
        except ValueError:
            pass
    
    if to_date:
        try:
            to_date_obj = datetime.strptime(to_date, '%Y-%m-%d').date()
            # Include full day up to 23:59:59 in server timezone
            from datetime import timedelta
            import pytz
            from django.conf import settings
            
            to_date_end = datetime.combine(to_date_obj, datetime.max.time().replace(microsecond=0))
            
            # Make timezone-aware if USE_TZ is enabled
            if getattr(settings, 'USE_TZ', False):
                tz = pytz.timezone(getattr(settings, 'TIME_ZONE', 'UTC'))
                to_date_end = tz.localize(to_date_end)
            
            sig_qs = sig_qs.filter(created_at__lte=to_date_end)
            aud_qs = aud_qs.filter(timestamp__lte=to_date_end)
        except ValueError:
            pass
    
    # Apply period filters
    if period_type:
        today = timezone.now().date()
        if period_type == 'day':
            sig_qs = sig_qs.filter(created_at__date=today)
            aud_qs = aud_qs.filter(timestamp__date=today)
        elif period_type == 'week':
            week_ago = today - timedelta(days=7)
            sig_qs = sig_qs.filter(created_at__date__gte=week_ago)
            aud_qs = aud_qs.filter(timestamp__date__gte=week_ago)
    
    # Apply action type filter
    if form_status in {'approve', 'disapprove', 'view', 'print', 'delete'}:
        sig_qs = sig_qs.filter(action_type=form_status)
        if form_status == 'approve':
            aud_qs = aud_qs.filter(action_type__icontains='approval')
        elif form_status == 'disapprove':
            aud_qs = aud_qs.filter(action_type__icontains='disapproval')
        else:
            aud_qs = AuditLog.objects.none()
    
    # Apply role filter
    if role_filter:
        if role_filter == 'signatory':
            aud_qs = AuditLog.objects.none()
        elif role_filter in ['admin', 'registrar']:
            sig_qs = SignatoryActivityLog.objects.none()
            aud_qs = aud_qs.filter(user__user_type=role_filter)
        elif role_filter == 'system':
            sig_qs = SignatoryActivityLog.objects.none()
            aud_qs = aud_qs.filter(user__isnull=True)
    
    # Apply form type filter
    if form_type:
        if form_type == 'clearance':
            sig_qs = sig_qs.filter(form_type__icontains='clearance')
            aud_qs = aud_qs.filter(description__icontains='clearance')
        elif form_type == 'enrollment':
            sig_qs = sig_qs.filter(form_type__icontains='enrollment')
            aud_qs = aud_qs.filter(description__icontains='enrollment')
        elif form_type == 'graduation':
            sig_qs = sig_qs.filter(form_type__icontains='graduation')
            aud_qs = aud_qs.filter(description__icontains='graduation')
        elif form_type == 'document_release':
            sig_qs = sig_qs.filter(form_type__icontains='document')
            aud_qs = aud_qs.filter(description__icontains='document')
    
    # Apply text search
    if text_search:
        sig_q = (
            Q(signatory__full_name__icontains=text_search) |
            Q(student_name__icontains=text_search) |
            Q(form_type__icontains=text_search) |
            Q(action_type__icontains=text_search)
        )
        sig_qs = sig_qs.filter(sig_q)
        
        aud_q = (
            Q(user__full_name__icontains=text_search) |
            Q(action_type__icontains=text_search) |
            Q(description__icontains=text_search)
        )
        aud_qs = aud_qs.filter(aud_q)
    
    # Convert to standardized format and sort by timestamp desc, then id for deterministic ordering
    activities = []
    
    # Process signatory activities
    for activity in sig_qs.order_by('-created_at', '-id'):
        activities.append({
            'student_name': activity.student_name or 'N/A',
            'form_type': activity.form_type or 'unknown',
            'form_type_display': activity.form_type.replace('_', ' ').title() if activity.form_type else 'Unknown',
            'action_type': activity.action_type,
            'activity': activity.action_type,
            'status': activity.action_type,  # Map action to status
            'signatory_name': activity.signatory.full_name if activity.signatory else 'Unknown',
            'timestamp': activity.created_at,
            'ip_address': getattr(activity, 'ip_address', None),
            'details': getattr(activity, 'remarks', ''),
            'source': 'signatory_activity'
        })
    
    # Process audit activities (only if not signatory-specific)
    if not signatory:
        for activity in aud_qs.order_by('-timestamp', '-id'):
            activities.append({
                'student_name': 'System',
                'form_type': 'system',
                'form_type_display': 'System Activity',
                'action_type': activity.action_type or 'action',
                'activity': activity.action_type or 'action',
                'status': 'completed',
                'signatory_name': activity.user.full_name if activity.user else 'System',
                'timestamp': activity.timestamp,
                'ip_address': getattr(activity, 'ip_address', None),
                'details': activity.description or '',
                'source': 'audit_log'
            })
    
    # Sort all activities by timestamp desc, then by id for deterministic ordering
    activities.sort(key=lambda x: (x['timestamp'], getattr(x, 'id', 0)), reverse=True)
    
    return activities


@login_required
def registrar_generate_manual_report(request):
    """Generate manual report for registrar/admin using current filters"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)

    try:
        from datetime import datetime, timezone as dt_timezone, timedelta
        from django.template.loader import render_to_string
        import pytz
        import logging
        logger = logging.getLogger(__name__)

        # Get and validate filter parameters
        from_date = request.POST.get('from_date', '').strip()
        to_date = request.POST.get('to_date', '').strip()
        form_status = request.POST.get('form_status', '').strip() or request.POST.get('action_type', '').strip()
        period_type = request.POST.get('period_type', '').strip()
        role_filter = request.POST.get('role', '').strip()
        form_type = request.POST.get('form_type', '').strip()
        text_search = request.POST.get('q', '').strip() or request.POST.get('search', '').strip()

        # Validate date format
        start_date, end_date = None, None
        if from_date:
            try:
                start_date = datetime.strptime(from_date, '%Y-%m-%d').date()
            except ValueError:
                return JsonResponse({'error': 'Invalid from_date format. Use YYYY-MM-DD'}, status=400)
        
        if to_date:
            try:
                end_date = datetime.strptime(to_date, '%Y-%m-%d').date()
            except ValueError:
                return JsonResponse({'error': 'Invalid to_date format. Use YYYY-MM-DD'}, status=400)

        if start_date and end_date and start_date > end_date:
            return JsonResponse({'error': 'from_date cannot be after to_date'}, status=400)

        # Default to last week if no dates provided
        if not start_date and not end_date:
            ph_tz = pytz.timezone('Asia/Manila')
            now = timezone.now(ph_tz)
            end_date = now.date()
            start_date = end_date - timedelta(days=7)

        # Normalize form status
        if form_status:
            form_status_lower = form_status.lower()
            if 'approved' in form_status_lower: 
                form_status = 'approve'
            elif 'declined' in form_status_lower or 'disapproved' in form_status_lower: 
                form_status = 'disapprove'
            elif 'pending' in form_status_lower: 
                form_status = 'view'

        # Log parameters for diagnostics
        logger.info(f"Manual report params: form_type={form_type}, dates={from_date} to {to_date}, status={form_status}")

        # Use unified query that matches table logic exactly
        if form_type and form_type in ['clearance', 'enrollment', 'graduation', 'document_release']:
            # When form type is selected, query actual forms like the table does
            activities = get_forms_data_for_report(
                form_type=form_type,
                from_date=from_date,
                to_date=to_date,
                form_status=form_status,
                text_search=text_search
            )
        else:
            # Default to activity logs when no form type selected
            activities = get_activity_data_for_report(
                form_type=form_type,
                from_date=from_date,
                to_date=to_date,
                form_status=form_status,
                period_type=period_type,
                role_filter=role_filter,
                text_search=text_search
            )

        # Log diagnostic info for row count matching
        data_source = "forms" if form_type and form_type in ['clearance', 'enrollment', 'graduation', 'document_release'] else "activities"
        logger.info(f"Manual report query result: {data_source} data, {len(activities)} rows found")

        # Prepare context for professional PDF template
        ph_tz = pytz.timezone('Asia/Manila')
        now = datetime.now(ph_tz)
        
        context = {
            'report_title': 'Activity Report',
            'report_id': f'AR-{now.strftime("%Y%m%d%H%M%S")}',
            'generated_by': request.user.full_name or request.user.username,
            'generated_at': now,
            'period_start': start_date,
            'period_end': end_date,
            'activities': activities,
            'total_count': len(activities),
            'filters': {
                'form_type': form_type,
                'form_status': form_status,
                'text_search': text_search,
                'role_filter': role_filter,
                'period_type': period_type
            }
        }

        # Generate HTML using professional template
        html_content = render_to_string('pdf/professional-report.html', context)
        
        # Convert HTML to PDF
        pdf_bytes = convert_html_to_pdf(html_content)
        if not pdf_bytes:
            return JsonResponse({'error': 'PDF generation failed'}, status=500)
        
        # Calculate checksum
        import hashlib
        checksum = hashlib.sha256(pdf_bytes).hexdigest()
        
        # Create filename: {form_type}_{YYYY-MM-DD}.pdf
        date_str = now.strftime('%Y-%m-%d')
        if form_type:
            filename = f"{form_type}_{date_str}.pdf"
        else:
            filename = f"activity_report_{date_str}.pdf"
        
        # Create database record
        from django.core.files.base import ContentFile
        generated_report = GeneratedReport.objects.create(
            report_type='manual_activity',
            generated_by=request.user,
            period_start=start_date,
            period_end=end_date,
            file=ContentFile(pdf_bytes, name=filename),
            size_bytes=len(pdf_bytes),
            checksum=checksum,
            status='completed',
            notes=f'Professional table PDF with {len(activities)} activities'
        )
        
        # Send notification about new report generation
        try:
            from landing.notification_service import NotificationService
            NotificationService.notify_report_generated(generated_report)
        except Exception as e:
            logger.error(f"Error sending report generation notification: {str(e)}")

        # Return PDF with proper headers
        from django.http import HttpResponse
        response = HttpResponse(pdf_bytes, content_type='application/pdf')
        response['Content-Disposition'] = f'attachment; filename="{filename}"'
        response['Content-Length'] = len(pdf_bytes)
        
        logger.info(f"Professional PDF generated: {filename}, {len(activities)} rows, record ID: {generated_report.id}")
        return response

    except Exception as e:
        import traceback
        logger = logging.getLogger(__name__)
        logger.error(f"Manual report generation failed: {e}", exc_info=True)
        return JsonResponse({'error': 'Internal server error'}, status=500)


@login_required
def registrar_generate_signatory_pack(request):
    """Generate PDF pack for signatory reports - POST only"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    import logging
    logger = logging.getLogger(__name__)
    
    try:
        import json
        from datetime import datetime, timezone as dt_timezone
        from django.http import HttpResponse
        from django.template.loader import render_to_string
        
        # Parse and validate request data
        try:
            data = json.loads(request.body)
            logger.info(f"Generate pack request: {data}")
        except json.JSONDecodeError as e:
            logger.warning(f"Invalid JSON in request body: {e}")
            return JsonResponse({'error': 'Invalid JSON in request body'}, status=400)
        
        form_type = (data.get('form_type') or data.get('report_type', '')).strip()
        from_date = (data.get('from_date', '')).strip()
        to_date = (data.get('to_date', '')).strip()
        
        # Validate required parameters
        if not form_type:
            return JsonResponse({'error': 'Missing required parameter: form_type'}, status=400)
        
        if not from_date or not to_date:
            return JsonResponse({'error': 'Missing required parameters: from_date and to_date'}, status=400)
        
        # Validate form_type
        valid_form_types = ['clearance', 'enrollment', 'graduation', 'document_release']
        if form_type not in valid_form_types:
            return JsonResponse({'error': f'Invalid form_type. Must be one of: {valid_form_types}'}, status=400)
        
        # Validate and parse dates
        try:
            from_date_obj = datetime.strptime(from_date, '%Y-%m-%d').date()
            to_date_obj = datetime.strptime(to_date, '%Y-%m-%d').date()
        except ValueError as e:
            logger.warning(f"Invalid date format: {e}")
            return JsonResponse({'error': 'Invalid date format. Use YYYY-MM-DD'}, status=400)
        
        if from_date_obj > to_date_obj:
            return JsonResponse({'error': 'from_date cannot be after to_date'}, status=400)
        
        # Get all signatories that have activities for this form type and date range
        # Use timezone-safe date filtering
        import pytz
        from django.conf import settings
        
        to_date_end = datetime.combine(to_date_obj, datetime.max.time().replace(microsecond=0))
        
        # Make timezone-aware if USE_TZ is enabled
        if getattr(settings, 'USE_TZ', False):
            tz = pytz.timezone(getattr(settings, 'TIME_ZONE', 'UTC'))
            to_date_end = tz.localize(to_date_end)
            
        sig_qs = SignatoryActivityLog.objects.select_related('signatory').filter(
            created_at__date__gte=from_date_obj,
            created_at__lte=to_date_end
        )
        
        # Apply form type filter
        if form_type == 'clearance':
            sig_qs = sig_qs.filter(form_type__icontains='clearance')
        elif form_type == 'enrollment':
            sig_qs = sig_qs.filter(form_type__icontains='enrollment')
        elif form_type == 'graduation':
            sig_qs = sig_qs.filter(form_type__icontains='graduation')
        elif form_type == 'document_release':
            sig_qs = sig_qs.filter(form_type__icontains='document')
        
        # Get unique signatories who have activities
        unique_signatories = set()
        for activity in sig_qs:
            if activity.signatory:
                unique_signatories.add(activity.signatory)
        
        if not unique_signatories:
            logger.info(f"No signatories found for {form_type} pack in date range {from_date} to {to_date}")
            return JsonResponse({'message': 'No items to include'}, status=204)
        
        logger.info(f"Found {len(unique_signatories)} signatories for {form_type} pack: {[s.full_name for s in unique_signatories]}")
        
        # Create ZIP of PDFs - one PDF per signatory
        import time
        import zipfile
        import io
        zip_start_time = time.time()
        
        # Helper function to generate professional PDF for a signatory
        def generate_signatory_pdf(signatory):
            # Query activities for this specific signatory using unified function
            signatory_activities = get_activity_data_for_report(
                form_type=form_type,
                from_date=from_date,
                to_date=to_date,
                signatory=signatory
            )
            
            # Prepare context for professional template
            context = {
                'report_title': f'{form_type.title()} Activity Report',
                'report_id': f'{form_type.upper()}-{signatory.id}-{from_date_obj.strftime("%Y%m%d")}',
                'generated_by': request.user.full_name or request.user.username,
                'generated_at': timezone.now(),
                'period_start': from_date_obj,
                'period_end': to_date_obj,
                'signatory': signatory,
                'activities': signatory_activities,
                'total_count': len(signatory_activities),
                'filters': {
                    'form_type': form_type,
                    'signatory': signatory.full_name
                }
            }
            
            # Render HTML using professional template
            try:
                html_content = render_to_string('pdf/professional-report.html', context)
            except Exception as template_error:
                logger.error(f"Template rendering failed for {signatory.full_name}: {template_error}")
                raise template_error
            
            # Convert HTML to PDF using existing function
            pdf_content = convert_html_to_pdf(html_content)
            if not pdf_content:
                raise Exception(f"PDF generation failed for {signatory.full_name}")
                
            return pdf_content
        
        # Create in-memory ZIP file
        zip_buffer = io.BytesIO()
        pdf_count = 0
        total_pdf_size = 0
        engine_used = "convert_html_to_pdf"
        
        try:
            with zipfile.ZipFile(zip_buffer, 'w', zipfile.ZIP_DEFLATED) as zip_file:
                for signatory in unique_signatories:
                    try:
                        # Generate professional PDF for this signatory
                        pdf_content = generate_signatory_pdf(signatory)
                        
                        # Create filename: {signatory_code_or_slug}_{YYYY-MM-DD}.pdf
                        signatory_slug = signatory.full_name.replace(' ', '_').replace('.', '').lower()
                        if hasattr(signatory, 'signatory_profile') and signatory.signatory_profile:
                            signatory_type = getattr(signatory.signatory_profile, 'signatory_type', '')
                            if signatory_type:
                                signatory_slug = signatory_type.replace(' ', '_').replace('.', '').lower()
                        
                        pdf_filename = f"{signatory_slug}_{from_date_obj.strftime('%Y-%m-%d')}.pdf"
                        
                        # Add PDF to ZIP
                        zip_file.writestr(pdf_filename, pdf_content)
                        pdf_count += 1
                        total_pdf_size += len(pdf_content)
                        
                        logger.info(f"Added PDF for {signatory.full_name}: {pdf_filename}, {len(get_activity_data_for_report(form_type=form_type, from_date=from_date, to_date=to_date, signatory=signatory))} activities")
                        
                    except Exception as pdf_error:
                        logger.error(f"Failed to generate PDF for {signatory}: {pdf_error}")
                        # Continue with other signatories
                        continue
            
            if pdf_count == 0:
                logger.error("No PDFs were successfully generated")
                return JsonResponse({'error': 'Failed to generate any PDFs'}, status=500)
            
            # Get ZIP content
            zip_content = zip_buffer.getvalue()
            
            # Create filename: {form_type}_signatory_pack_{YYYY-MM-DD}.zip
            filename = f"{form_type}_signatory_pack_{from_date_obj.strftime('%Y-%m-%d')}.zip"
            
            # Save to database record before sending response
            from django.core.files.base import ContentFile
            import hashlib
            
            # Calculate checksum
            checksum = hashlib.sha256(zip_content).hexdigest()
            
            # Create GeneratedReport record for the pack
            generated_report = GeneratedReport.objects.create(
                report_type=f'{form_type}_pack',
                generated_by=request.user,
                period_start=from_date_obj,
                period_end=to_date_obj,
                file=ContentFile(zip_content, name=filename),
                size_bytes=len(zip_content),
                checksum=checksum,
                status='completed',
                notes=f'ZIP pack with {pdf_count} PDFs, generated using {engine_used}'
            )
            
            # Create response with proper headers
            response = HttpResponse(zip_content, content_type='application/zip')
            response['Content-Disposition'] = f'attachment; filename="{filename}"'
            response['Content-Length'] = len(zip_content)
            
            render_duration = time.time() - zip_start_time
            logger.info(f"ZIP pack generated successfully with {engine_used}: {filename}, {pdf_count} PDFs, total PDF size: {total_pdf_size} bytes, ZIP size: {len(zip_content)} bytes, duration: {render_duration:.2f}s, record ID: {generated_report.id}")
            return response
            
        except Exception as zip_error:
            logger.error(f"ZIP creation failed: {zip_error}", exc_info=True)
            return JsonResponse({'error': 'ZIP pack generation failed'}, status=500)
    
    except Exception as e:
        logger.error(f"Unexpected error in registrar_generate_signatory_pack: {e}", exc_info=True)
        return JsonResponse({'error': 'Internal server error'}, status=500)


@login_required
def registrar_regenerate_weekly_report(request):
    """Regenerate a specific weekly report"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        from datetime import datetime, timezone as dt_timezone, timedelta
        from django.core.management import call_command
        from io import StringIO
        import sys
        
        data = json.loads(request.body)
        week_start = data.get('week_start')
        report_type = data.get('report_type')
        
        if not week_start or not report_type:
            return JsonResponse({
                'error': 'Missing required parameters: week_start and report_type'
            }, status=400)
        
        if report_type not in ['clearance', 'enrollment', 'graduation', 'document_release']:
            return JsonResponse({
                'error': 'Invalid report_type. Must be clearance, enrollment, graduation, or document_release'
            }, status=400)
        
        # Validate week_start is a Monday
        try:
            week_date = datetime.strptime(week_start, '%Y-%m-%d').date()
            if week_date.weekday() != 0:
                return JsonResponse({
                    'error': 'week_start must be a Monday'
                }, status=400)
        except ValueError:
            return JsonResponse({
                'error': 'Invalid date format. Use YYYY-MM-DD'
            }, status=400)
        
        # Capture management command output
        stdout_capture = StringIO()
        old_stdout = sys.stdout
        sys.stdout = stdout_capture
        
        try:
            # Call the management command for a single report type
            call_command(
                'generate_weekly_reports', 
                week=week_start,
                force=True
            )
            
            # Restore stdout
            sys.stdout = old_stdout
            command_output = stdout_capture.getvalue()
            
            # Find the generated report in database
            end_date = week_date + timedelta(days=6)
            
            generated_report = GeneratedReport.objects.filter(
                report_type=report_type,
                period_start=week_date,
                period_end=end_date
            ).first()
            
            if generated_report and generated_report.file_exists:
                return JsonResponse({
                    'success': True,
                    'message': f'Weekly {report_type} report regenerated successfully',
                    'report_id': str(generated_report.id),
                    'download_url': generated_report.file.url,
                    'filename': generated_report.filename,
                    'size_bytes': generated_report.size_bytes,
                    'period': f"{week_date} to {end_date}",
                    'command_output': command_output
                })
            else:
                return JsonResponse({
                    'error': 'Report regeneration failed - no file created',
                    'command_output': command_output
                }, status=500)
                
        except Exception as cmd_error:
            sys.stdout = old_stdout
            return JsonResponse({
                'error': f'Command execution failed: {str(cmd_error)}',
                'command_output': stdout_capture.getvalue()
            }, status=500)
        
    except json.JSONDecodeError:
        return JsonResponse({'error': 'Invalid JSON in request body'}, status=400)
    except Exception as e:
        import traceback
        print(f"Error regenerating weekly report: {e}")
        print(traceback.format_exc())
        return JsonResponse({'error': str(e)}, status=500)




@login_required
def signatory_profile(request):
    """Signatory Profile View"""
    if request.user.user_type != 'signatory':
        return redirect('login')
    
    try:
        # Get signatory profile
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        
        context = {
            'signatory_profile': signatory_profile,
        }
        
        return render(request, 'SIGNATORYPROFILE.html', context)
        
    except Exception as e:
        print(f"Error in signatory_profile: {e}")
        return render(request, 'SIGNATORYPROFILE.html', {})


@login_required
def signatory_messages(request):
    """Signatory Messages View"""
    if request.user.user_type != 'signatory':
        return redirect('login')
    
    try:
        # Get signatory profile
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        
        context = {
            'signatory_profile': signatory_profile,
        }
        
        return render(request, 'SIGNATORYMESSAGES.html', context)
        
    except Exception as e:
        print(f"Error in signatory_messages: {e}")
        return render(request, 'SIGNATORYMESSAGES.html', {})


@login_required
def signatory_reports(request):
    """Signatory Reports View"""
    if request.user.user_type != 'signatory':
        return redirect('login')
    
    try:
        # Get signatory profile
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        
        context = {
            'signatory_profile': signatory_profile,
        }
        
        return render(request, 'SIGNATORYREPORTS.html', context)
        
    except Exception as e:
        print(f"Error in signatory_reports: {e}")
        return render(request, 'SIGNATORYREPORTS.html', {})


# ========================================
# SIGNATORY DASHBOARD API ENDPOINTS
# ========================================

@login_required
def signatory_dashboard_data_api(request):
    """API endpoint to get new clearance forms data for signatory dashboard"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        print(f"Dashboard API called by user: {request.user.username} (type: {request.user.user_type})")
        
        # Get query parameters for filtering
        purpose_filter = request.GET.get('purpose', '')
        course_filter = request.GET.get('course', '')
        year_filter = request.GET.get('year', '')
        section_filter = request.GET.get('section', '')
        search_query = request.GET.get('search', '')
        
        print(f"Filters: purpose={purpose_filter}, course={course_filter}, year={year_filter}, section={section_filter}, search={search_query}")
        
        # Get new clearance forms (not seen by signatory)
        new_clearances = ClearanceSignatory.objects.filter(
            signatory=request.user,
            status='pending',
            seen_by_signatory=False
        ).select_related(
            'clearance__student__profile',
            'clearance'
        )
        
        print(f"Found {new_clearances.count()} pending clearances for user {request.user.username}")
        
        # Apply filters
        if purpose_filter:
            new_clearances = new_clearances.filter(clearance__clearance_type=purpose_filter.lower())
        
        if course_filter:
            new_clearances = new_clearances.filter(clearance__student__profile__program__icontains=course_filter)
        
        if year_filter:
            new_clearances = new_clearances.filter(clearance__student__profile__year_level=year_filter)
        
        if section_filter:
            new_clearances = new_clearances.filter(clearance__section__icontains=section_filter)
        
        if search_query:
            new_clearances = new_clearances.filter(
                Q(clearance__student__full_name__icontains=search_query) |
                Q(clearance__student__profile__student_number__icontains=search_query) |
                Q(clearance__student__profile__program__icontains=search_query)
            )
        
        # Prepare data for response
        clearance_data = []
        for clearance_signatory in new_clearances:
            try:
                student = clearance_signatory.clearance.student
                student_profile = getattr(student, 'profile', None)
                
                clearance_data.append({
                'id': str(clearance_signatory.id),
                'clearance_id': str(clearance_signatory.clearance.id),
                'student_name': student.full_name,
                'student_number': student_profile.student_number if student_profile else 'N/A',
                'course': student_profile.program if student_profile else 'N/A',
                'year': student_profile.year_level if student_profile else 'N/A',
                'section': clearance_signatory.clearance.section or 'N/A',
                'purpose': clearance_signatory.clearance.clearance_type.title(),
                'date_submitted': clearance_signatory.clearance.submitted_at.strftime('%B %d, %Y'),
                'semester': clearance_signatory.clearance.semester,
                'academic_year': clearance_signatory.clearance.academic_year or 'N/A',
            })
            except Exception as e:
                print(f"Error processing clearance {clearance_signatory.id}: {e}")
                continue
        
        # Get count of new clearances
        new_clearances_count = new_clearances.count()
        
        return JsonResponse({
            'success': True,
            'data': clearance_data,
            'count': new_clearances_count,
            'message': f'There are {new_clearances_count} new clearance form{"s" if new_clearances_count != 1 else ""} waiting for approval'
        })
        
    except Exception as e:
        print(f"Error in signatory_dashboard_data_api: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)


@login_required
def signatory_get_clearance_details(request, clearance_id):
    """API endpoint to get detailed clearance data for viewing"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        # Get the clearance form
        clearance = ClearanceForm.objects.select_related(
            'student__profile'
        ).get(id=clearance_id)
        
        # Get all signatory statuses for this clearance
        signatory_statuses = ClearanceSignatory.objects.filter(
            clearance=clearance
        ).select_related('signatory__signatory_profile')
        
        # Create a mapping of signatory types to their statuses
        signatory_data = {}
        print(f"Processing {signatory_statuses.count()} signatory records for clearance {clearance_id}")
        
        # Group signatories by type to handle duplicates
        signatory_groups = {}
        for signatory_record in signatory_statuses:
            # Safely get signatory type, handle cases where signatory_profile doesn't exist
            try:
                signatory_type = signatory_record.signatory.signatory_profile.signatory_type
                print(f"Found signatory type: {signatory_type} for user: {signatory_record.signatory.username}")
                # Map the signatory type to the correct key used in the frontend
                signatory_type_mapping = {
                    'library_director': 'director_of_library_&_information',
                    'scholarship_director': 'director_of_scholarship',
                    'it_director': 'information_technology',
                    'student_affairs': 'dean_of_student_affairs',
                    'registrar': 'registrar'  # Add registrar mapping
                }
                mapped_type = signatory_type_mapping.get(signatory_type, signatory_type)
                print(f"Mapped type: {mapped_type}")
            except Exception as e:
                print(f"Error processing signatory record: {e}")
                # If signatory_profile doesn't exist, this might be a registrar (admin) user
                # Check if the user is an admin/registrar and use 'registrar' as the type
                if signatory_record.signatory.user_type in ['admin', 'registrar']:
                    mapped_type = 'registrar'
                    print(f"User is admin/registrar, using mapped_type: {mapped_type}")
                else:
                    # If signatory_profile doesn't exist, skip this record
                    continue
            
            # Group by mapped type
            if mapped_type not in signatory_groups:
                signatory_groups[mapped_type] = []
            signatory_groups[mapped_type].append(signatory_record)
        
        # Process each group to select the best signatory
        for mapped_type, signatory_list in signatory_groups.items():
            if len(signatory_list) == 1:
                # Only one signatory of this type
                signatory_record = signatory_list[0]
                signatory_data[mapped_type] = {
                    'status': signatory_record.status,
                    'timestamp': signatory_record.updated_at.strftime('%B %d, %Y %I:%M %p') if signatory_record.updated_at else None,
                    'remarks': signatory_record.remarks
                }
                print(f"Added single signatory data for {mapped_type}: {signatory_record.status}")
            else:
                # Multiple signatories of the same type - choose the best one
                print(f"Multiple signatories for {mapped_type}: {len(signatory_list)}")
                
                # Priority: approved > disapproved > pending
                # Also prefer the current user if they're a signatory
                best_signatory = None
                current_user = request.user
                
                # First, try to find the current user's signatory
                for signatory_record in signatory_list:
                    if signatory_record.signatory == current_user:
                        best_signatory = signatory_record
                        print(f"    Found current user's signatory: {signatory_record.status}")
                        break
                
                # If not found, choose by status priority
                if not best_signatory:
                    for signatory_record in signatory_list:
                        if signatory_record.status == 'approved':
                            best_signatory = signatory_record
                            print(f"    Found approved signatory: {signatory_record.signatory.username}")
                            break
                        elif signatory_record.status == 'disapproved' and (not best_signatory or best_signatory.status == 'pending'):
                            best_signatory = signatory_record
                            print(f"    Found disapproved signatory: {signatory_record.signatory.username}")
                
                # If still not found, use the first one
                if not best_signatory:
                    best_signatory = signatory_list[0]
                    print(f"    Using first signatory: {best_signatory.signatory.username} ({best_signatory.status})")
                
                signatory_data[mapped_type] = {
                    'status': best_signatory.status,
                    'timestamp': best_signatory.updated_at.strftime('%B %d, %Y %I:%M %p') if best_signatory.updated_at else None,
                    'remarks': best_signatory.remarks
                }
                print(f"Added best signatory data for {mapped_type}: {best_signatory.status}")
        
        print(f"Final signatory_data: {signatory_data}")
        
        # Get student profile
        student_profile = getattr(clearance.student, 'profile', None)
        
        # Prepare response data
        response_data = {
            'clearance_id': str(clearance.id),
            'student_name': clearance.student.full_name,
            'student_number': student_profile.student_number if student_profile else 'N/A',
            'course': student_profile.program if student_profile else 'N/A',
            'year_level': student_profile.year_level if student_profile else 'N/A',
            'section': clearance.section or 'N/A',
            'purpose': clearance.clearance_type.title(),
            'date_submitted': clearance.submitted_at.strftime('%B %d, %Y'),
            'semester': clearance.semester,
            'academic_year': clearance.academic_year or 'N/A',
            'signatory_statuses': signatory_data
        }
        
        return JsonResponse({
            'success': True,
            'data': response_data
        })
        
    except ClearanceForm.DoesNotExist:
        return JsonResponse({'error': 'Clearance not found'}, status=404)
    except Exception as e:
        print(f"Error in signatory_get_clearance_details: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)


@login_required
def signatory_mark_clearance_seen(request):
    """API endpoint to mark clearance forms as seen by signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        
        # Check if it's a single clearance or multiple clearances
        clearance_signatory_id = request.POST.get('clearance_signatory_id')
        clearance_signatory_ids = request.POST.get('clearance_signatory_ids')
        
        if clearance_signatory_ids:
            # Handle multiple clearances (automatic marking when dashboard loads)
            try:
                ids_list = json.loads(clearance_signatory_ids)
                if not isinstance(ids_list, list):
                    return JsonResponse({'error': 'Invalid format for clearance signatory IDs'}, status=400)
                
                # Mark all clearances as seen
                updated_count = ClearanceSignatory.objects.filter(
                    id__in=ids_list,
                    signatory=request.user,
                    seen_by_signatory=False
                ).update(seen_by_signatory=True)
                
                return JsonResponse({
                    'success': True,
                    'message': f'{updated_count} clearance forms marked as seen'
                })
                
            except json.JSONDecodeError:
                return JsonResponse({'error': 'Invalid JSON format for clearance signatory IDs'}, status=400)
                
        elif clearance_signatory_id:
            # Handle single clearance (manual marking)
            clearance_signatory = ClearanceSignatory.objects.get(
                id=clearance_signatory_id,
                signatory=request.user
            )
            
            # Mark as seen
            clearance_signatory.seen_by_signatory = True
            clearance_signatory.save()
            
            return JsonResponse({
                'success': True,
                'message': 'Clearance form marked as seen'
            })
        else:
            return JsonResponse({'error': 'Either clearance_signatory_id or clearance_signatory_ids is required'}, status=400)
        
    except ClearanceSignatory.DoesNotExist:
        return JsonResponse({'error': 'Clearance form not found'}, status=404)
    except Exception as e:
        print(f"Error in signatory_mark_clearance_seen: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)


@login_required
def signatory_calendar_events_api(request):
    """API endpoint to get calendar events for signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        from landing.models import CalendarEvent
        
        # Get events created by this signatory or public events
        events = CalendarEvent.objects.filter(
            Q(created_by=request.user) | Q(is_holiday=True)
        ).order_by('start_date', 'start_time')
        
        events_data = []
        for event in events:
            events_data.append({
                'id': str(event.id),
                'title': event.title,
                'description': event.description or '',
                'event_type': event.event_type,
                'color': event.color,
                'start_date': event.start_date.strftime('%Y-%m-%d'),
                'start_time': event.start_time.strftime('%H:%M') if event.start_time else None,
                'end_date': event.end_date.strftime('%Y-%m-%d') if event.end_date else None,
                'end_time': event.end_time.strftime('%H:%M') if event.end_time else None,
                'is_all_day': event.is_all_day,
                'display_time': event.display_time,
                'created_by': event.created_by.full_name,
            })
        
        return JsonResponse({
            'success': True,
            'events': events_data
        })
        
    except Exception as e:
        print(f"Error in signatory_calendar_events_api: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)


@login_required
def signatory_add_calendar_event(request):
    """API endpoint to add calendar event for signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        from landing.models import CalendarEvent
        from datetime import datetime, timezone as dt_timezone
        
        # Get form data
        title = request.POST.get('title')
        description = request.POST.get('description', '')
        event_type = request.POST.get('event_type', 'event')
        color = request.POST.get('color', 'blue')
        start_date = request.POST.get('start_date')
        start_time = request.POST.get('start_time')
        end_date = request.POST.get('end_date')
        end_time = request.POST.get('end_time')
        is_all_day = request.POST.get('is_all_day', 'false').lower() == 'true'
        
        # Validate required fields
        if not title or not start_date:
            return JsonResponse({'error': 'Title and start date are required'}, status=400)
        
        # Parse dates
        try:
            start_date = datetime.strptime(start_date, '%Y-%m-%d').date()
            end_date = datetime.strptime(end_date, '%Y-%m-%d').date() if end_date else None
            start_time = datetime.strptime(start_time, '%H:%M').time() if start_time else None
            end_time = datetime.strptime(end_time, '%H:%M').time() if end_time else None
        except ValueError:
            return JsonResponse({'error': 'Invalid date/time format'}, status=400)
        
        # Create event
        event = CalendarEvent.objects.create(
            title=title,
            description=description,
            event_type=event_type,
            color=color,
            start_date=start_date,
            start_time=start_time,
            end_date=end_date,
            end_time=end_time,
            is_all_day=is_all_day,
            created_by=request.user
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Event added successfully',
            'event': {
                'id': str(event.id),
                'title': event.title,
                'description': event.description or '',
                'event_type': event.event_type,
                'color': event.color,
                'start_date': event.start_date.strftime('%Y-%m-%d'),
                'start_time': event.start_time.strftime('%H:%M') if event.start_time else None,
                'end_date': event.end_date.strftime('%Y-%m-%d') if event.end_date else None,
                'end_time': event.end_time.strftime('%H:%M') if event.end_time else None,
                'is_all_day': event.is_all_day,
                'display_time': event.display_time,
                'created_by': event.created_by.full_name,
            }
        })
        
    except Exception as e:
        print(f"Error in signatory_add_calendar_event: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)

@login_required
def signatory_filter_options_api(request):
    """API endpoint to get filter options for signatory dashboard"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        # Get all clearance forms assigned to this signatory
        clearance_signatories = ClearanceSignatory.objects.filter(
            signatory=request.user,
            status='pending',
            seen_by_signatory=False
        ).select_related(
            'clearance__student__profile',
            'clearance'
        )
        
        # Get unique courses (programs)
        courses = clearance_signatories.values_list(
            'clearance__student__profile__program', flat=True
        ).distinct().exclude(clearance__student__profile__program__isnull=True).exclude(
            clearance__student__profile__program=''
        ).order_by('clearance__student__profile__program')
        
        # Get unique years (year_level)
        years = clearance_signatories.values_list(
            'clearance__student__profile__year_level', flat=True
        ).distinct().exclude(clearance__student__profile__year_level__isnull=True).order_by(
            'clearance__student__profile__year_level'
        )
        
        # Get unique sections
        sections = clearance_signatories.values_list(
            'clearance__section', flat=True
        ).distinct().exclude(clearance__section__isnull=True).exclude(
            clearance__section=''
        ).order_by('clearance__section')
        
        return JsonResponse({
            'success': True,
            'courses': list(courses),
            'years': list(years),
            'sections': list(sections)
        })
        
    except Exception as e:
        print(f"Error in signatory_filter_options_api: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)



# ========================================
# SIGNATORY CLEARANCE API VIEWS
# ========================================

@login_required
def signatory_clearance_data_api(request):
    """API endpoint to get clearance data for signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        # Get signatory profile and type
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        if not signatory_profile:
            print(f"User {request.user.username} has no signatory profile")
            return JsonResponse({'error': 'Signatory profile not found'}, status=404)
        
        # Check if first-time setup is needed - but don't block data loading
        # The setup check is now handled by the main template
        if signatory_profile.force_password_change or not signatory_profile.pin_set:
            # Return empty data instead of blocking
            return JsonResponse({'data': [], 'requires_setup': True})
        
        signatory_type = signatory_profile.signatory_type
        
        # Get all clearance forms - every signatory should see all clearances
        # but they can only approve/disapprove in their own column
        clearances = ClearanceForm.objects.all().select_related('student', 'student__profile')
        
        # Apply filters
        course_filter = request.GET.get('course')
        year_filter = request.GET.get('year')
        section_filter = request.GET.get('section')
        status_filter = request.GET.get('status')
        search_query = request.GET.get('search')
        
        if course_filter and course_filter != 'Filter by Course':
            clearances = clearances.filter(
                student__profile__program__icontains=course_filter
            )
        
        if year_filter and year_filter != 'Filter by Year':
            clearances = clearances.filter(
                student__profile__year_level=int(year_filter)
            )
        
        if section_filter and section_filter != 'Filter by Section':
            clearances = clearances.filter(
                section__icontains=section_filter
            )
        
        if search_query:
            clearances = clearances.filter(
                Q(student__full_name__icontains=search_query) |
                Q(student__profile__student_number__icontains=search_query)
            )
        
        # Apply status filter
        if status_filter and status_filter != 'Filter by Status':
            if status_filter == 'completed':
                # Filter for clearances where all 10 signatory types have approved
                completed_clearance_ids = []
                required_signatory_types = {
                    'dorm_supervisor', 'canteen_concessionaire', 'library_director',
                    'scholarship_director', 'it_director', 'student_affairs',
                    'cashier', 'business_manager', 'registrar', 'academic_dean'
                }
                
                for clearance in ClearanceForm.objects.all():
                    all_signatories = ClearanceSignatory.objects.filter(clearance=clearance)
                    approved_signatory_types = set()
                    
                    for sig in all_signatories:
                        if sig.status == 'approved':
                            sig_profile = getattr(sig.signatory, 'signatory_profile', None)
                            if sig_profile:
                                approved_signatory_types.add(sig_profile.signatory_type)
                    
                    if required_signatory_types.issubset(approved_signatory_types):
                        completed_clearance_ids.append(clearance.id)
                clearances = clearances.filter(id__in=completed_clearance_ids)
            elif status_filter == 'pending':
                # Filter for clearances where not all signatories have approved
                pending_clearance_ids = []
                for clearance in ClearanceForm.objects.all():
                    all_signatories = ClearanceSignatory.objects.filter(clearance=clearance)
                    if not all_signatories.exists() or all_signatories.filter(status='approved').count() < all_signatories.count():
                        pending_clearance_ids.append(clearance.id)
                clearances = clearances.filter(id__in=pending_clearance_ids)
        
        # Order by submission date (most recent first)
        clearances = clearances.order_by('-submitted_at')
        
        data = []
        for clearance in clearances:
            student = clearance.student
            profile = getattr(student, 'profile', None)
            
            # Get all signatories for this clearance (lazy loading)
            all_signatories = ClearanceSignatory.objects.filter(clearance=clearance)
            signatory_data = {}
            
            # Define all possible signatory types
            all_signatory_types = {
                'dorm_supervisor': 'Dorm Supervisor',
                'canteen_concessionaire': 'Canteen Concessionaire',
                'library_director': 'Library Director',
                'scholarship_director': 'Scholarship Director',
                'it_director': 'IT Director',
                'student_affairs': 'Student Affairs',
                'cashier': 'Cashier',
                'business_manager': 'Business Manager',
                'registrar': 'Registrar',
                'academic_dean': 'Academic Dean'
            }
            
            # Process existing signatory records
            # Group signatories by type to handle duplicates
            signatory_groups = {}
            for signatory in all_signatories:
                signatory_profile = getattr(signatory.signatory, 'signatory_profile', None)
                if signatory_profile:
                    role_key = signatory_profile.signatory_type
                    if role_key not in signatory_groups:
                        signatory_groups[role_key] = []
                    signatory_groups[role_key].append(signatory)
            
            # Process each group to select the best signatory
            for role_key, signatory_list in signatory_groups.items():
                if len(signatory_list) == 1:
                    # Only one signatory of this type
                    signatory = signatory_list[0]
                    signatory_data[role_key] = {
                        'status': signatory.status,
                        'timestamp': signatory.updated_at.strftime('%Y-%m-%d %H:%M') if signatory.updated_at else None,
                        'remarks': signatory.remarks,
                        'ip_address': signatory.ip_address
                    }
                else:
                    # Multiple signatories of the same type - choose the best one
                    # Priority: approved > disapproved > pending
                    # Also prefer the current user if they're a signatory
                    best_signatory = None
                    current_user = request.user
                    
                    # First, try to find the current user's signatory
                    for signatory in signatory_list:
                        if signatory.signatory == current_user:
                            best_signatory = signatory
                            break
                    
                    # If not found, choose by status priority
                    if not best_signatory:
                        for signatory in signatory_list:
                            if signatory.status == 'approved':
                                best_signatory = signatory
                                break
                            elif signatory.status == 'disapproved' and (not best_signatory or best_signatory.status == 'pending'):
                                best_signatory = signatory
                    
                    # If still not found, use the first one
                    if not best_signatory:
                        best_signatory = signatory_list[0]
                    
                    signatory_data[role_key] = {
                        'status': best_signatory.status,
                        'timestamp': best_signatory.updated_at.strftime('%Y-%m-%d %H:%M') if best_signatory.updated_at else None,
                        'remarks': best_signatory.remarks,
                        'ip_address': best_signatory.ip_address
                    }
            
            # Create missing signatory records on-demand (lazy loading)
            for signatory_type_key, role_name in all_signatory_types.items():
                if signatory_type_key not in signatory_data:
                    # Find a signatory of this type
                    signatory_user = User.objects.filter(
                        user_type='signatory',
                        signatory_profile__signatory_type=signatory_type_key
                    ).first()
                    
                    if signatory_user:
                        # Create the missing record
                        clearance_signatory, created = ClearanceSignatory.objects.get_or_create(
                            clearance=clearance,
                            signatory=signatory_user,
                            defaults={
                                'status': 'pending',
                                'role': role_name,
                                'seen_by_signatory': False
                            }
                        )
                        
                        if created:
                            # Add to signatory_data for this response
                            signatory_data[signatory_type_key] = {
                                'status': 'pending',
                                'timestamp': None,
                                'remarks': None,
                                'ip_address': None
                            }
                        else:
                            # Record already exists, get its data
                            signatory_data[signatory_type_key] = {
                                'status': clearance_signatory.status,
                                'timestamp': clearance_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if clearance_signatory.updated_at else None,
                                'remarks': clearance_signatory.remarks,
                                'ip_address': clearance_signatory.ip_address
                            }
                    else:
                        # No signatory of this type exists, show as pending
                        signatory_data[signatory_type_key] = {
                            'status': 'pending',
                            'timestamp': None,
                            'remarks': None,
                            'ip_address': None
                        }
            
            # Check if current signatory can approve this clearance
            current_signatory_record = all_signatories.filter(signatory=request.user).first()
            can_approve = current_signatory_record and current_signatory_record.status == 'pending'
            
            # Get current signatory's status for this clearance
            current_signatory_status = 'pending'
            if current_signatory_record:
                current_signatory_status = current_signatory_record.status
            
            # Determine overall clearance status
            # Check if all 10 signatory types have approved
            required_signatory_types = set(all_signatory_types.keys())  # All 10 types
            approved_signatory_types = set()
            
            for sig in all_signatories:
                if sig.status == 'approved':
                    sig_profile = getattr(sig.signatory, 'signatory_profile', None)
                    if sig_profile:
                        approved_signatory_types.add(sig_profile.signatory_type)
            
            if required_signatory_types.issubset(approved_signatory_types):
                overall_status = 'completed'
            else:
                overall_status = 'pending'
            
            clearance_data = {
                'id': str(clearance.id),
                'student_id': str(student.id),
                'student_name': student.full_name,
                'student_number': profile.student_number if profile else 'N/A',
                'course': profile.program if profile else 'N/A',
                'year': profile.year_level if profile else 'N/A',
                'section': clearance.section or 'N/A',
                'date_submitted': clearance.submitted_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p'),
                'clearance_type': clearance.clearance_type,
                'status': overall_status,
                'signatory_type': signatory_type,
                'signatories': signatory_data,
                'can_approve': can_approve,
                'current_signatory_status': current_signatory_status
            }
            data.append(clearance_data)
        
        # Add pagination for large datasets
        page = int(request.GET.get('page', 1))
        page_size = int(request.GET.get('page_size', 50))
        
        # Simple pagination
        start = (page - 1) * page_size
        end = start + page_size
        paginated_data = data[start:end]
        
        return JsonResponse({
            'data': paginated_data,
            'pagination': {
                'page': page,
                'page_size': page_size,
                'total': len(data),
                'total_pages': (len(data) + page_size - 1) // page_size,
                'has_next': end < len(data),
                'has_previous': page > 1
            }
        })
        
    except Exception as e:
        print(f"Error in signatory_clearance_data_api: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@require_POST
@login_required
def signatory_approve_clearance(request):
    """Approve clearance by signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        clearance_id = request.POST.get('clearance_id')
        pin = request.POST.get('pin')
        comment = request.POST.get('comment', '')
        
        if not clearance_id or not pin:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Verify PIN
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        if not signatory_profile or not signatory_profile.pin_set:
            return JsonResponse({'error': 'PIN not set'}, status=400)
        
        # Verify PIN (in production, implement proper hashing)
        if pin != signatory_profile.pin:
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get or create the clearance signatory record (lazy loading)
        clearance_signatory, created = ClearanceSignatory.objects.get_or_create(
            clearance_id=clearance_id,
            signatory=request.user,
            defaults={
                'status': 'pending',
                'role': signatory_profile.get_signatory_type_display(),
                'seen_by_signatory': True
            }
        )
        
        # Allow editing disapproved clearances (changing from disapproved to approved)
        if clearance_signatory.status == 'approved':
            return JsonResponse({'error': 'Clearance already approved'}, status=400)
        
        # Update the status
        clearance_signatory.status = 'approved'
        clearance_signatory.remarks = comment
        clearance_signatory.ip_address = get_client_ip(request)
        clearance_signatory.save()
        
        # Log activity in both SignatoryActivityLog and AuditLog
        SignatoryActivityLog.objects.create(
            signatory=request.user,
            action_type='approve',
            form_type='clearance',
            form_id=clearance_id,
            student_name=clearance_signatory.clearance.student.full_name,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        # Also log in AuditLog for admin/registrar reporting (IP in description)
        AuditLog.objects.create(
            user=request.user,
            action_type='clearance_approval',
            description=f'Approved clearance form {clearance_id} for {clearance_signatory.clearance.student.full_name} [IP: {get_client_ip(request)}]'
        )
        
        # Send notification to student about approval
        try:
            from landing.notification_service import NotificationService
            NotificationService.notify_form_approval(
                form_instance=clearance_signatory.clearance,
                form_type='clearance',
                signatory_user=request.user,
                remarks=comment
            )
        except Exception as e:
            logger.error(f"Error sending approval notification: {str(e)}")
        
        # Check if all signatories have approved
        all_signatories = ClearanceSignatory.objects.filter(clearance_id=clearance_id)
        if all_signatories.filter(status='approved').count() == all_signatories.count():
            # All signatories approved, update clearance form status
            clearance_form = clearance_signatory.clearance
            clearance_form.status = 'approved'
            clearance_form.finalized_at = timezone.now()
            clearance_form.save()
            
            # Send clearance completed notification
            try:
                NotificationService.notify_clearance_completed(
                    student=clearance_form.student,
                    form_type='clearance',
                    form_instance=clearance_form
                )
                NotificationService.notify_admin_form_completed('clearance', clearance_form.student.full_name)
            except Exception as e:
                logger.error(f"Error sending clearance completion notification: {str(e)}")
        
        return JsonResponse({'success': True, 'message': 'Clearance approved successfully'})
        
    except Exception as e:
        print(f"Error in signatory_approve_clearance: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@require_POST
@login_required
def signatory_disapprove_clearance(request):
    """Disapprove clearance by signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        clearance_id = request.POST.get('clearance_id')
        pin = request.POST.get('pin')
        reasons = request.POST.getlist('reasons[]')
        comment = request.POST.get('comment', '')
        appointment_date = request.POST.get('appointment_date')
        
        if not clearance_id or not pin or not reasons:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Verify PIN
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        if not signatory_profile or not signatory_profile.pin_set:
            return JsonResponse({'error': 'PIN not set'}, status=400)
        
        # Verify PIN (in production, implement proper hashing)
        if pin != signatory_profile.pin:
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get or create the clearance signatory record (lazy loading)
        clearance_signatory, created = ClearanceSignatory.objects.get_or_create(
            clearance_id=clearance_id,
            signatory=request.user,
            defaults={
                'status': 'pending',
                'role': signatory_profile.get_signatory_type_display(),
                'seen_by_signatory': True
            }
        )
        
        if clearance_signatory.status != 'pending':
            return JsonResponse({'error': 'Clearance already processed'}, status=400)
        
        # Create remarks with reasons and appointment
        remarks_parts = [f"Reasons: {', '.join(reasons)}"]
        if comment:
            remarks_parts.append(f"Comment: {comment}")
        if appointment_date:
            remarks_parts.append(f"Appointment: {appointment_date}")
        
        remarks = " | ".join(remarks_parts)
        
        # Update the status
        clearance_signatory.status = 'disapproved'
        clearance_signatory.remarks = remarks
        clearance_signatory.ip_address = get_client_ip(request)
        clearance_signatory.save()
        
        # Log activity in both SignatoryActivityLog and AuditLog
        SignatoryActivityLog.objects.create(
            signatory=request.user,
            action_type='disapprove',
            form_type='clearance',
            form_id=clearance_id,
            student_name=clearance_signatory.clearance.student.full_name,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        # Also log in AuditLog for admin/registrar reporting (IP in description)
        AuditLog.objects.create(
            user=request.user,
            action_type='clearance_disapproval',
            description=f'Disapproved clearance form {clearance_id} for {clearance_signatory.clearance.student.full_name}. Reasons: {", ".join(reasons)} [IP: {get_client_ip(request)}]'
        )
        
        # Send notification to student about disapproval with settlement period
        try:
            from landing.notification_service import NotificationService
            notification_service = NotificationService()
            notification_service.handle_form_disapproval(
                form=clearance_signatory.clearance,
                form_type='clearance',
                disapproval_reasons=reasons,
                settlement_instructions=comment,
                appointment_date=appointment_date
            )
        except Exception as e:
            logger.error(f"Error sending disapproval notification: {str(e)}")
        
        # Update clearance form status to disapproved
        clearance_form = clearance_signatory.clearance
        clearance_form.status = 'disapproved'
        clearance_form.finalized_at = timezone.now()
        clearance_form.save()
        
        return JsonResponse({'success': True, 'message': 'Clearance disapproved successfully'})
        
    except Exception as e:
        print(f"Error in signatory_disapprove_clearance: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@require_POST
@login_required
def signatory_bulk_delete_clearance(request):
    """Bulk delete clearance records"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        clearance_ids = request.POST.getlist('clearance_ids[]')
        
        if not clearance_ids:
            return JsonResponse({'error': 'No clearance IDs provided'}, status=400)
        
        # Delete clearance signatory records for this signatory
        deleted_count = ClearanceSignatory.objects.filter(
            clearance_id__in=clearance_ids,
            signatory=request.user
        ).delete()[0]
        
        return JsonResponse({
            'success': True, 
            'message': f'{deleted_count} clearance records deleted successfully'
        })
        
    except Exception as e:
        print(f"Error in signatory_bulk_delete_clearance: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@require_POST  
@login_required
def signatory_bulk_approve_clearance(request):
    """Bulk approve multiple clearance forms for Signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            clearance_ids = data.get('clearance_ids', [])
            pin = data.get('pin')
            comment = data.get('comment', '')
            
            # Verify PIN first
            signatory_profile = getattr(request.user, 'signatory_profile', None)
            if not signatory_profile or not signatory_profile.pin_set:
                return JsonResponse({'error': 'PIN not set'}, status=400)
            
            if pin != signatory_profile.pin:
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            if not clearance_ids:
                return JsonResponse({'error': 'No clearance forms provided'}, status=400)
            
            clearance_forms = ClearanceForm.objects.filter(id__in=clearance_ids)
            
            if not clearance_forms.exists():
                return JsonResponse({'error': 'No clearance forms found'}, status=404)
            
            # Process bulk approval
            approved_count = 0
            student_names = []
            
            for clearance in clearance_forms:
                try:
                    # Get or create the clearance signatory record
                    clearance_signatory, created = ClearanceSignatory.objects.get_or_create(
                        clearance=clearance,
                        signatory=request.user,
                        defaults={
                            'status': 'approved',
                            'role': signatory_profile.get_signatory_type_display(),
                            'remarks': comment,
                            'ip_address': get_client_ip(request),
                            'seen_by_signatory': True
                        }
                    )
                    
                    # Only count if this is a new approval or update from pending
                    was_updated = False
                    if created:
                        was_updated = True
                    elif not created and clearance_signatory.status == 'pending':
                        clearance_signatory.status = 'approved'
                        clearance_signatory.remarks = comment
                        clearance_signatory.ip_address = get_client_ip(request)
                        clearance_signatory.save()
                        was_updated = True
                    
                    # Only increment count and add name if actually updated
                    if was_updated:
                        approved_count += 1
                        student_names.append(clearance.student.get_full_name())
                        
                        # Log activity only for actually updated records
                        SignatoryActivityLog.objects.create(
                            signatory=request.user,
                            action_type='approve',
                            form_type='clearance',
                            form_id=clearance.id,
                            student_name=clearance.student.full_name,
                            ip_address=get_client_ip(request),
                            user_agent=request.META.get('HTTP_USER_AGENT', '')
                        )
                    
                except Exception as e:
                    print(f"Error approving clearance {clearance.id}: {e}")
                    continue
            
            # Log bulk action in AuditLog
            AuditLog.objects.create(
                user=request.user,
                action_type='bulk_clearance_approval',
                description=f'Bulk approved {approved_count} clearance forms for students: {", ".join(student_names[:5])}{"..." if len(student_names) > 5 else ""} [IP: {get_client_ip(request)}]'
            )
            
            return JsonResponse({
                'success': True, 
                'message': f'Successfully approved {approved_count} clearance forms',
                'approved_count': approved_count
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON data'}, status=400)
        except Exception as e:
            print(f"Error in signatory_bulk_approve_clearance: {e}")
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)


@require_POST
@login_required  
def signatory_bulk_disapprove_clearance(request):
    """Bulk disapprove multiple clearance forms for Signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            clearance_ids = data.get('clearance_ids', [])
            pin = data.get('pin')
            reason = data.get('reason', 'Bulk disapproval')
            comment = data.get('comment', '')
            appointment_date = data.get('appointment_date')
            
            # Verify PIN first
            signatory_profile = getattr(request.user, 'signatory_profile', None)
            if not signatory_profile or not signatory_profile.pin_set:
                return JsonResponse({'error': 'PIN not set'}, status=400)
            
            if pin != signatory_profile.pin:
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            if not clearance_ids:
                return JsonResponse({'error': 'No clearance forms provided'}, status=400)
            
            clearance_forms = ClearanceForm.objects.filter(id__in=clearance_ids)
            
            if not clearance_forms.exists():
                return JsonResponse({'error': 'No clearance forms found'}, status=404)
            
            # Process bulk disapproval
            disapproved_count = 0
            student_names = []
            
            # Create remarks with reasons and appointment
            remarks_parts = [f"Reasons: {reason}"]
            if comment:
                remarks_parts.append(f"Comment: {comment}")
            if appointment_date:
                remarks_parts.append(f"Appointment: {appointment_date}")
            
            remarks = " | ".join(remarks_parts)
            
            for clearance in clearance_forms:
                try:
                    # Get or create the clearance signatory record
                    clearance_signatory, created = ClearanceSignatory.objects.get_or_create(
                        clearance=clearance,
                        signatory=request.user,
                        defaults={
                            'status': 'disapproved',
                            'role': signatory_profile.get_signatory_type_display(),
                            'remarks': remarks,
                            'ip_address': get_client_ip(request),
                            'seen_by_signatory': True
                        }
                    )
                    
                    # Only count if this is a new disapproval or update from pending
                    was_updated = False
                    if created:
                        was_updated = True
                    elif not created and clearance_signatory.status == 'pending':
                        clearance_signatory.status = 'disapproved'
                        clearance_signatory.remarks = remarks
                        clearance_signatory.ip_address = get_client_ip(request)
                        clearance_signatory.save()
                        was_updated = True
                    
                    # Only increment count and add name if actually updated
                    if was_updated:
                        disapproved_count += 1
                        student_names.append(clearance.student.get_full_name())
                        
                        # Log activity only for actually updated records
                        SignatoryActivityLog.objects.create(
                            signatory=request.user,
                            action_type='disapprove',
                            form_type='clearance',
                            form_id=clearance.id,
                            student_name=clearance.student.full_name,
                            ip_address=get_client_ip(request),
                            user_agent=request.META.get('HTTP_USER_AGENT', '')
                        )
                    
                    # Update clearance form status to disapproved
                    clearance.status = 'disapproved'
                    clearance.finalized_at = timezone.now()
                    clearance.save()
                    
                except Exception as e:
                    print(f"Error disapproving clearance {clearance.id}: {e}")
                    continue
            
            # Log bulk action in AuditLog
            AuditLog.objects.create(
                user=request.user,
                action_type='bulk_clearance_disapproval',
                description=f'Bulk disapproved {disapproved_count} clearance forms for students: {", ".join(student_names[:5])}{"..." if len(student_names) > 5 else ""} [IP: {get_client_ip(request)}]'
            )
            
            return JsonResponse({
                'success': True, 
                'message': f'Successfully disapproved {disapproved_count} clearance forms',
                'disapproved_count': disapproved_count
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON data'}, status=400)
        except Exception as e:
            print(f"Error in signatory_bulk_disapprove_clearance: {e}")
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)


@require_POST
@login_required
def signatory_set_pin(request):
    """Set PIN for signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        pin = request.POST.get('pin')
        confirm_pin = request.POST.get('confirm_pin')
        
        if not pin or not confirm_pin:
            return JsonResponse({'error': 'PIN and confirmation required'}, status=400)
        
        if pin != confirm_pin:
            return JsonResponse({'error': 'PINs do not match'}, status=400)
        
        if len(pin) < 6:
            return JsonResponse({'error': 'PIN must be at least 6 characters'}, status=400)
        
        # Get or create signatory profile
        signatory_profile, created = SignatoryProfile.objects.get_or_create(
            user=request.user,
            defaults={'signatory_type': 'dorm_supervisor'}  # Default type
        )
        
        # In a real implementation, you'd hash the PIN
        # For now, we'll store it as is (you should implement proper hashing)
        signatory_profile.pin = pin
        signatory_profile.pin_set = True
        signatory_profile.force_password_change = False
        signatory_profile.save()
        
        return JsonResponse({'success': True, 'message': 'PIN set successfully'})
        
    except Exception as e:
        print(f"Error in signatory_set_pin: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@require_POST
@login_required
def signatory_change_pin(request):
    """Change PIN for signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        current_pin = request.POST.get('currentPin')
        new_pin = request.POST.get('newPin')
        confirm_pin = request.POST.get('confirmPin')
        
        if not current_pin or not new_pin or not confirm_pin:
            return JsonResponse({'error': 'All PIN fields are required'}, status=400)
        
        if new_pin != confirm_pin:
            return JsonResponse({'error': 'New PIN and confirmation do not match'}, status=400)
        
        if len(new_pin) < 6:
            return JsonResponse({'error': 'New PIN must be at least 6 characters'}, status=400)
        
        # Get signatory profile
        try:
            signatory_profile = SignatoryProfile.objects.get(user=request.user)
        except SignatoryProfile.DoesNotExist:
            return JsonResponse({'error': 'Signatory profile not found'}, status=404)
        
        # Verify current PIN
        if not signatory_profile.pin:
            return JsonResponse({'error': 'No PIN is currently set. Please contact administrator.'}, status=400)
        
        # For now, direct comparison (should implement proper hashing in production)
        if signatory_profile.pin != current_pin:
            return JsonResponse({'error': 'Current PIN is incorrect'}, status=400)
        
        # Update to new PIN
        signatory_profile.pin = new_pin
        signatory_profile.save()
        
        return JsonResponse({'success': True, 'message': 'PIN changed successfully'})
        
    except Exception as e:
        print(f"Error in signatory_change_pin: {e}")
        return JsonResponse({'error': 'An error occurred while changing PIN'}, status=500)


@require_POST
@login_required
def signatory_change_password(request):
    """Change password for signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        current_password = request.POST.get('current_password')
        new_password = request.POST.get('new_password')
        confirm_password = request.POST.get('confirm_password')
        
        if not current_password or not new_password or not confirm_password:
            return JsonResponse({'error': 'All password fields required'}, status=400)
        
        if new_password != confirm_password:
            return JsonResponse({'error': 'New passwords do not match'}, status=400)
        
        if len(new_password) < 8:
            return JsonResponse({'error': 'Password must be at least 8 characters'}, status=400)
        
        # Verify current password
        if not request.user.check_password(current_password):
            return JsonResponse({'error': 'Current password is incorrect'}, status=400)
        
        # Set new password
        request.user.set_password(new_password)
        request.user.save()
        
        # Update signatory profile
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        if signatory_profile:
            signatory_profile.force_password_change = False
            signatory_profile.save()
        
        return JsonResponse({'success': True, 'message': 'Password changed successfully'})
        
    except Exception as e:
        print(f"Error in signatory_change_password: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_clearance_filter_options(request):
    """Get filter options for signatory clearance"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        # Get unique values for filters
        courses = StudentProfile.objects.values_list('program', flat=True).distinct()
        years = StudentProfile.objects.values_list('year_level', flat=True).distinct()
        sections = ClearanceForm.objects.values_list('section', flat=True).distinct()
        
        return JsonResponse({
            'courses': list(courses),
            'years': list(years),
            'sections': list(sections)
        })
        
    except Exception as e:
        print(f"Error in signatory_clearance_filter_options: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@require_POST
@login_required
def signatory_verify_pin(request):
    """Verify PIN for signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        pin = request.POST.get('pin')
        
        if not pin:
            return JsonResponse({'error': 'PIN required'}, status=400)
        
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        if not signatory_profile or not signatory_profile.pin_set:
            return JsonResponse({'error': 'PIN not set'}, status=400)
        
        # Verify PIN (in production, implement proper hashing)
        if pin == signatory_profile.pin:
            return JsonResponse({'success': True})
        else:
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
    except Exception as e:
        print(f"Error in signatory_verify_pin: {e}")
        return JsonResponse({'error': str(e)}, status=500)


@login_required
def signatory_check_setup_status(request):
    """Check if signatory needs first-time setup"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        signatory_profile = getattr(request.user, 'signatory_profile', None)
        
        # Check if setup is required
        requires_setup = (
            signatory_profile is None or 
            signatory_profile.force_password_change or 
            not signatory_profile.pin_set
        )
        
        return JsonResponse({'requires_setup': requires_setup})
        
    except Exception as e:
        print(f"Error in signatory_check_setup_status: {e}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def signatory_generate_auto_report(request):
    """Generate auto report for signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from datetime import datetime, timezone as dt_timezone, timedelta
        import pytz
        from django.template.loader import render_to_string
        from django.core.files.base import ContentFile
        import os
        
        # Get Philippine timezone
        ph_tz = pytz.timezone('Asia/Manila')
        now = datetime.now(ph_tz)
        
        # Get filter parameters
        report_type = request.POST.get('report_type', 'approved_forms')
        period_type = request.POST.get('period_type', 'weekly')
        
        # Calculate date range based on period
        if period_type == 'daily':
            start_date = now.date()
            end_date = now.date()
        elif period_type == 'weekly':
            # Get Monday of current week
            days_since_monday = now.weekday()
            start_date = now.date() - timedelta(days=days_since_monday)
            end_date = start_date + timedelta(days=6)
        else:  # monthly
            start_date = now.replace(day=1).date()
            end_date = (now.replace(day=1) + timedelta(days=32)).replace(day=1) - timedelta(days=1)
        
        # Get activity logs for this signatory
        activity_logs = SignatoryActivityLog.objects.filter(
            signatory=request.user,
            created_at__date__range=[start_date, end_date]
        )
        
        # Filter by report type
        if report_type == 'approved_forms':
            activity_logs = activity_logs.filter(action_type='approve')
        elif report_type == 'disapproved_forms':
            activity_logs = activity_logs.filter(action_type='disapprove')
        elif report_type == 'pending_forms':
            activity_logs = activity_logs.filter(action_type='view')
        
        # Generate PDF report
        context = {
            'signatory': request.user,
            'report_type': report_type,
            'period_type': period_type,
            'start_date': start_date,
            'end_date': end_date,
            'activity_logs': activity_logs,
            'total_count': activity_logs.count(),
        }
        
        # Render HTML template
        html_content = render_to_string('pdf/auto-generated-report.html', context)
        
        # Create file path with proper format
        filename = f"{report_type}_report_{start_date}.html"
        file_path = os.path.join('reports', filename)
        
        # Save report to database
        auto_report = AutoGeneratedReport.objects.create(
            report_type=report_type,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            file_path=file_path,
            created_by=request.user
        )
        
        # Save HTML content to file
        from django.conf import settings
        reports_dir = os.path.join(settings.MEDIA_ROOT, 'reports')
        os.makedirs(reports_dir, exist_ok=True)
        
        full_file_path = os.path.join(reports_dir, filename)
        with open(full_file_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        return JsonResponse({
            'success': True,
            'message': 'Report generated successfully',
            'report_id': str(auto_report.id),
            'file_path': file_path
        })
        
    except Exception as e:
        print(f"Error generating auto report: {e}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def signatory_generate_manual_report(request):
    """Manually generate report using UI filters"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)

    try:
        # Extract filter values
        report_type = request.POST.get('report_type', '')
        period_type = request.POST.get('period_type', '')
        from_date = request.POST.get('from_date')
        to_date = request.POST.get('to_date')

        ph_tz = pytz.timezone('Asia/Manila')
        now = datetime.now(ph_tz)
        if from_date and to_date:
            start_date = datetime.strptime(from_date, '%Y-%m-%d').date()
            end_date = datetime.strptime(to_date, '%Y-%m-%d').date()
        else:
            days_since_monday = now.weekday()
            start_date = now.date() - timedelta(days=days_since_monday)
            end_date = start_date + timedelta(days=6)

        activity_logs = SignatoryActivityLog.objects.filter(
            signatory=request.user,
            created_at__date__range=[start_date, end_date]
        )

        if report_type == 'approved_forms':
            activity_logs = activity_logs.filter(action_type='approve')
        elif report_type == 'disapproved_forms':
            activity_logs = activity_logs.filter(action_type='disapprove')
        elif report_type == 'pending_forms':
            activity_logs = activity_logs.filter(action_type='view')

        context = {
            'signatory': request.user,
            'report_type': report_type,
            'period_type': period_type,
            'start_date': start_date,
            'end_date': end_date,
            'activity_logs': activity_logs,
            'total_count': activity_logs.count(),
        }

        html_content = render_to_string('pdf/auto-generated-report.html', context)
        filename = f"{report_type}_manual_{start_date}.html"
        file_path = os.path.join('reports', filename)
        full_path = os.path.join(settings.MEDIA_ROOT, file_path)
        os.makedirs(os.path.dirname(full_path), exist_ok=True)
        with open(full_path, 'w', encoding='utf-8') as f:
            f.write(html_content)

        auto_report = AutoGeneratedReport.objects.create(
            report_type=report_type,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            file_path=file_path,
            created_by=request.user
        )

        return JsonResponse({
            'success': True,
            'message': 'Report generated successfully',
            'report_id': str(auto_report.id),
            'file_path': file_path
        })

    except Exception as e:
        print(f"Error generating manual report: {e}")
        return JsonResponse({'error': str(e)}, status=500)



@login_required
def signatory_download_report(request, report_id):
    """Download report for signatory"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Try to find in AutoGeneratedReport first
        try:
            report = AutoGeneratedReport.objects.get(
                id=report_id,
                created_by=request.user
            )
            file_path = report.file_path
            is_auto_report = True
        except AutoGeneratedReport.DoesNotExist:
            # Try to find in GeneratedReport (manual reports)
            report = GeneratedReport.objects.get(
                id=report_id,
                generated_by=request.user
            )
            file_path = report.file.name if hasattr(report, 'file') and report.file else None
            is_auto_report = False
        
        if not file_path:
            return JsonResponse({'error': 'Report file path not found'}, status=404)
        
        # Check if file exists
        from django.conf import settings
        import os
        full_file_path = os.path.join(settings.MEDIA_ROOT, file_path)
        
        if os.path.exists(full_file_path):
            if is_auto_report:
                # Auto-generated reports are HTML files
                try:
                    with open(full_file_path, 'r', encoding='utf-8') as f:
                        response = HttpResponse(f.read(), content_type='text/html')
                        response['Content-Disposition'] = f'inline; filename="signatory_report_{report_id}.html"'
                        return response
                except UnicodeDecodeError:
                    return JsonResponse({'error': 'Unable to read report file'}, status=500)
            else:
                # Manual reports are PDF files
                try:
                    with open(full_file_path, 'rb') as f:
                        response = HttpResponse(f.read(), content_type='application/pdf')
                        response['Content-Disposition'] = f'inline; filename="signatory_report_{report_id}.pdf"'
                        return response
                except Exception as e:
                    return JsonResponse({'error': f'Error reading PDF file: {str(e)}'}, status=500)
        else:
            return JsonResponse({'error': 'Report file not found'}, status=404)
    
    except (AutoGeneratedReport.DoesNotExist, GeneratedReport.DoesNotExist):
        return JsonResponse({'error': 'Report not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': f'Internal server error: {str(e)}'}, status=500)

@login_required
def signatory_reports_csv_export(request):
    """CSV export endpoint for signatory reports data"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        import csv
        from django.http import HttpResponse
        from datetime import datetime, timezone as dt_timezone, timedelta
        
        # Get same parameters as the main API
        from_date = request.GET.get('from_date', '')
        to_date = request.GET.get('to_date', '')
        form_status = request.GET.get('form_status', '')
        period_type = request.GET.get('period_type', '')
        search = request.GET.get('search', '').strip()
        
        # Get activity logs with same filtering as main API
        activity_logs = UserActivityLog.objects.filter(user_type='signatory')
        
        # Apply date filter
        if from_date:
            try:
                from_date_parsed = datetime.strptime(from_date, '%Y-%m-%d').date()
                activity_logs = activity_logs.filter(timestamp__date__gte=from_date_parsed)
            except ValueError:
                pass
                
        if to_date:
            try:
                to_date_parsed = datetime.strptime(to_date, '%Y-%m-%d').date()
                activity_logs = activity_logs.filter(timestamp__date__lte=to_date_parsed)
            except ValueError:
                pass
        
        # Apply form status filter
        if form_status and form_status != 'all_forms':
            if form_status == 'approved_forms':
                activity_logs = activity_logs.filter(action_type='approve')
            elif form_status == 'disapproved_forms':
                activity_logs = activity_logs.filter(action_type='disapprove')
            elif form_status == 'pending_forms':
                activity_logs = activity_logs.filter(action_type='view')
        
        # Apply search filter
        if search:
            activity_logs = activity_logs.filter(
                Q(student_name__icontains=search) |
                Q(form_type__icontains=search) |
                Q(action_type__icontains=search) |
                Q(signatory__icontains=search)
            )
        
        # Create CSV response
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = 'attachment; filename="signatory_reports.csv"'
        
        writer = csv.writer(response)
        writer.writerow(['Student Name', 'Form Type', 'Action Type', 'Signatory', 'Date', 'Time', 'IP Address'])
        
        for log in activity_logs.order_by('-timestamp'):
            writer.writerow([
                log.student_name or '',
                log.form_type or '',
                log.action_type or '',
                log.signatory or '',
                log.timestamp.strftime('%Y-%m-%d') if log.timestamp else '',
                log.timestamp.strftime('%H:%M:%S') if log.timestamp else '',
                log.ip_address or ''
            ])
        
        return response
        
    except Exception as e:
        logger.error(f"Error exporting signatory reports to CSV: {e}", exc_info=True)
        return JsonResponse({'error': 'Failed to export CSV'}, status=500)


@login_required  
def registrar_download_report(request, report_id):
    """Download report as PDF for registrar/admin"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    import logging
    logger = logging.getLogger(__name__)
    
    try:
        # Try AutoGeneratedReport first, then GeneratedReport
        report = None
        is_auto_report = False
        try:
            report = AutoGeneratedReport.objects.get(id=report_id)
            file_path = report.file_path
            is_auto_report = True
        except AutoGeneratedReport.DoesNotExist:
            try:
                report = GeneratedReport.objects.get(id=report_id)
                file_path = report.file.path if report.file else None
                is_auto_report = False
            except GeneratedReport.DoesNotExist:
                return JsonResponse({'error': 'Report not found'}, status=404)
        
        if not file_path:
            return JsonResponse({'error': 'Report file path not found'}, status=404)
        
        # Check if file exists
        from django.conf import settings
        import os
        
        if not os.path.isabs(file_path):
            full_file_path = os.path.join(settings.MEDIA_ROOT, file_path)
        else:
            full_file_path = file_path
        
        if not os.path.exists(full_file_path):
            return JsonResponse({'error': 'Report file not found'}, status=404)
        
        # Handle different file types based on source
        if is_auto_report:
            # AutoGeneratedReport files are HTML, read and convert to PDF
            with open(full_file_path, 'r', encoding='utf-8') as f:
                html_content = f.read()
        else:
            # GeneratedReport files are already PDFs, serve them directly
            with open(full_file_path, 'rb') as f:
                pdf_content = f.read()
            
            # Create PDF filename for direct PDF files
            report_type = getattr(report, 'report_type', 'report')
            date_str = report.created_at.strftime('%Y-%m-%d') if hasattr(report, 'created_at') else 'unknown'
            pdf_filename = f"{report_type}_{report.id}_{date_str}.pdf"
            
            # Return PDF response directly
            from django.http import HttpResponse
            response = HttpResponse(pdf_content, content_type='application/pdf')
            response['Content-Disposition'] = f'inline; filename="{pdf_filename}"'
            return response
        
        # Convert HTML to PDF using same engine logic as above
        def convert_html_to_pdf_for_download(html_content):
            try:
                import pdfkit
                
                options = {
                    'page-size': 'A4',
                    'margin-top': '1cm',
                    'margin-right': '1cm',
                    'margin-bottom': '1cm', 
                    'margin-left': '1cm',
                    'encoding': "UTF-8",
                    'no-outline': None,
                    'enable-local-file-access': None
                }
                
                wkhtmltopdf_paths = [
                    r'C:\Program Files\wkhtmltopdf\bin\wkhtmltopdf.exe',
                    r'C:\Program Files (x86)\wkhtmltopdf\bin\wkhtmltopdf.exe',
                    'wkhtmltopdf'
                ]
                
                config = None
                for path in wkhtmltopdf_paths:
                    if os.path.exists(path) or path == 'wkhtmltopdf':
                        config = pdfkit.configuration(wkhtmltopdf=path)
                        break
                
                pdf_content = pdfkit.from_string(html_content, False, options=options, configuration=config)
                return pdf_content, "wkhtmltopdf"
                
            except (ImportError, OSError, Exception):
                try:
                    from xhtml2pdf import pisa
                    import io
                    
                    pdf_buffer = io.BytesIO()
                    pisa_status = pisa.CreatePDF(html_content, dest=pdf_buffer)
                    
                    if not pisa_status.err:
                        return pdf_buffer.getvalue(), "xhtml2pdf"
                    else:
                        raise Exception(f"xhtml2pdf failed: {pisa_status.err}")
                        
                except ImportError:
                    raise Exception("No PDF engines available")
        
        # Convert to PDF
        try:
            pdf_content, engine_used = convert_html_to_pdf_for_download(html_content)
            
            # Create PDF filename
            report_type = getattr(report, 'report_type', 'report')
            date_str = report.created_at.strftime('%Y-%m-%d') if hasattr(report, 'created_at') else 'unknown'
            pdf_filename = f"{report_type}_{report.id}_{date_str}.pdf"
            
            # Return PDF response  
            from django.http import HttpResponse
            response = HttpResponse(pdf_content, content_type='application/pdf')
            response['Content-Disposition'] = f'attachment; filename="{pdf_filename}"'
            response['Content-Length'] = len(pdf_content)
            
            logger.info(f"Registrar report downloaded as PDF with {engine_used}: {pdf_filename}")
            return response
            
        except Exception as pdf_error:
            logger.error(f"PDF conversion failed: {pdf_error}")
            return JsonResponse({'error': 'PDF generation not available. Please install wkhtmltopdf or xhtml2pdf.'}, status=503)
        
    except Exception as e:
        logger.error(f"Error downloading registrar report: {e}", exc_info=True)
        return JsonResponse({'error': 'Internal server error'}, status=500)

@login_required
def signatory_generated_reports_list(request):
    """Get list of generated reports for signatory (includes both GeneratedReport and AutoGeneratedReport)"""
    if request.user.user_type != 'signatory':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get reports from both models since signatory saves to different models
        generated_reports = list(GeneratedReport.objects.filter(generated_by=request.user))
        auto_reports = list(AutoGeneratedReport.objects.filter(created_by=request.user))
        
        # Get filter parameters
        report_type_filter = request.GET.get('report_type', '')
        generation_type_filter = request.GET.get('generation_type', '')  # manual/auto
        
        # Combine and process both types of reports
        all_reports = []
        
        # Process GeneratedReport entries (these are typically from auto-generation or registrar manual reports)
        for report in generated_reports:
            if report_type_filter and report.report_type != report_type_filter:
                continue
            
            is_auto = report.generated_by is None
            if generation_type_filter == 'manual' and is_auto:
                continue
            elif generation_type_filter == 'auto' and not is_auto:
                continue
                
            all_reports.append({
                'model': 'GeneratedReport',
                'report': report,
                'is_auto': is_auto
            })
        
        # Process AutoGeneratedReport entries (these are typically manual reports from signatory/business manager)
        for report in auto_reports:
            if report_type_filter and report.report_type != report_type_filter:
                continue
            
            # AutoGeneratedReport with created_by are manual reports
            is_auto = False  # These are manual reports created by users
            if generation_type_filter == 'auto':
                continue  # Skip manual reports if filtering for auto only
                
            all_reports.append({
                'model': 'AutoGeneratedReport', 
                'report': report,
                'is_auto': is_auto
            })
        
        # Sort by creation date (most recent first)
        from django.utils import timezone
        from datetime import datetime, timezone as dt_timezone
        def get_creation_date(entry):
            report = entry['report']
            # AutoGeneratedReport uses 'generated_at', GeneratedReport uses 'created_at'
            if hasattr(report, 'generated_at'):
                return report.generated_at
            elif hasattr(report, 'created_at'):
                return report.created_at
            else:
                return datetime.min.replace(tzinfo=dt_timezone.utc)
        
        all_reports.sort(key=get_creation_date, reverse=True)
        
        reports = []
        
        for entry in all_reports:
            report = entry['report']
            model_type = entry['model']
            is_auto = entry['is_auto']
            
            # Get file information - different for each model type
            if model_type == 'GeneratedReport':
                file_size = report.size_bytes or 0
                exists = report.file_exists
                filename = report.file.name.split('/')[-1] if report.file else 'N/A'
            else:  # AutoGeneratedReport
                file_size = 0  # AutoGeneratedReport doesn't have size_bytes
                exists = bool(report.file_path and os.path.exists(os.path.join(settings.MEDIA_ROOT, report.file_path))) if hasattr(report, 'file_path') else False
                filename = os.path.basename(report.file_path) if hasattr(report, 'file_path') and report.file_path else 'N/A'
            
            download_url = f"/signatory/reports/download-report/{report.id}/" if exists else None
            
            # Format date range - different field names for each model
            date_range = 'N/A'
            start_date = 'N/A'
            end_date = 'N/A'
            
            if model_type == 'GeneratedReport':
                if hasattr(report, 'period_start') and hasattr(report, 'period_end') and report.period_start and report.period_end:
                    date_range = f"{report.period_start} to {report.period_end}"
                    start_date = str(report.period_start)
                    end_date = str(report.period_end)
            else:  # AutoGeneratedReport
                if hasattr(report, 'start_date') and hasattr(report, 'end_date') and report.start_date and report.end_date:
                    date_range = f"{report.start_date} to {report.end_date}"
                    start_date = str(report.start_date)
                    end_date = str(report.end_date)
            
            # Format report type display
            report_type_display = report.get_report_type_display() if hasattr(report, 'get_report_type_display') else (report.report_type.title() if hasattr(report, 'report_type') else 'Unknown')
            
            # Get creation date - AutoGeneratedReport uses 'generated_at', GeneratedReport uses 'created_at'
            if hasattr(report, 'generated_at'):
                created_at = report.generated_at
            elif hasattr(report, 'created_at'):
                created_at = report.created_at
            else:
                created_at = None
            generated_at = created_at.strftime('%Y-%m-%d %H:%M:%S') if created_at else 'N/A'
            
            # Get generated_by info
            if model_type == 'GeneratedReport':
                generated_by = report.generated_by.full_name if hasattr(report, 'generated_by') and report.generated_by else 'System (Auto)'
            else:  # AutoGeneratedReport
                generated_by = report.created_by.full_name if hasattr(report, 'created_by') and report.created_by else 'Unknown'
            
            reports.append({
                'id': str(report.id),
                'type': 'auto' if is_auto else 'manual',
                'report_type': report_type_display,
                'report_type_display': report_type_display,
                'period_type': 'Weekly' if is_auto else 'Custom',
                'period_type_display': 'Weekly' if is_auto else 'Custom',
                'filename': filename,
                'generated_at': generated_at,
                'date_range': date_range,
                'start_date': start_date,
                'end_date': end_date,
                'file_size': file_size,
                'exists': exists,
                'download_url': download_url,
                'generated_by': generated_by,
                'status': getattr(report, 'status', 'completed'),
                'notes': getattr(report, 'notes', '') or ''
            })
        
        return JsonResponse({
            'success': True,
            'reports': reports[:50]  # Limit to 50 most recent
        })
        
    except Exception as e:
        import traceback
        print(f"Error in signatory_generated_reports_list: {e}")
        traceback.print_exc()
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def signatory_profile(request):
    """Render the signatory profile page"""
    if getattr(request.user, "user_type", None) not in ["signatory", "admin"]:
        messages.error(request, "Access denied. You don't have permission to view this page.")
        return redirect("login")

    # Ensure profile exists
    profile, _ = SignatoryProfile.objects.get_or_create(user=request.user)

    # Split full name into first and last name (like your registrar view)
    full_name_parts = (request.user.full_name or "").split(" ", 1)
    first_name = full_name_parts[0] if full_name_parts else ""
    last_name = full_name_parts[1] if len(full_name_parts) > 1 else ""

    ctx = {
        "user": request.user,
        "signatory_profile": profile,
        "first_name": first_name,
        "last_name": last_name,
    }
    return render(request, "SIGNATORYPROFILE.html", ctx)

# ---------- DATA API ----------

@login_required
@require_http_methods(["GET"])
def signatory_profile_data_api(request):
    """Get current signatory profile data for the form."""
    if (getattr(request.user, "user_type", "") or "").lower() not in {"signatory", "admin"}:
        return JsonResponse({"error": "Access denied"}, status=403)

    profile, _ = SignatoryProfile.objects.get_or_create(user=request.user)

    # Name fallback: use full_name if present, otherwise first_name/last_name
    full_name = (getattr(request.user, "full_name", "") or "").strip()
    if full_name:
        parts = full_name.split(" ", 1)
        first_name = parts[0]
        last_name = parts[1] if len(parts) > 1 else ""
    else:
        first_name = getattr(request.user, "first_name", "") or ""
        last_name = getattr(request.user, "last_name", "") or ""

    # Build absolute URL for profile pic (avoids broken src in some setups)
    pic_url = profile.profile_picture_url
    if pic_url and pic_url.startswith("/"):
        pic_url = request.build_absolute_uri(pic_url)

    # Also return a display label for the signatory_type (nice for showing in UI)
    choices_dict = dict(SignatoryProfile.SIGNATORY_TYPES)
    position_key = profile.signatory_type or ""
    position_display = choices_dict.get(position_key, position_key)

    data = {
        "first_name": first_name,
        "last_name": last_name,
        "birthday": profile.birthdate.strftime("%Y-%m-%d") if profile.birthdate else "",
        "sex": profile.gender or "",
        "position": position_key,            # raw key (e.g., "registrar")
        "position_display": position_display,# human label (e.g., "Registrar")
        "department": profile.department or "",
        "address": profile.address or "",
        "email": request.user.email or "",
        "contact_number": getattr(request.user, "contact_number", "") or "",
        "profile_picture_url": pic_url,
        # Optional: provide choices so frontend can show a dropdown
        "signatory_type_choices": [{"key": k, "label": v} for k, v in SignatoryProfile.SIGNATORY_TYPES],
    }
    return JsonResponse({"success": True, "profile": data})


@login_required
@require_http_methods(["POST"])
def signatory_profile_update_api(request):
    """Update signatory profile + basic user fields."""
    if (getattr(request.user, "user_type", "") or "").lower() not in {"signatory", "admin"}:
        return JsonResponse({"error": "Access denied"}, status=403)

    try:
        data = json.loads(request.body or "{}")
    except Exception:
        return JsonResponse({"error": "Invalid JSON body"}, status=400)

    profile, _ = SignatoryProfile.objects.get_or_create(user=request.user)
    User = get_user_model()

    # ---- Name handling ----
    first = (data.get("firstName") or "").strip()
    last = (data.get("lastName") or "").strip()
    # Keep your existing pattern of storing in full_name; also set first/last if present
    if first or last:
        # Update separate name fields if the User model has them
        if hasattr(request.user, "first_name"):
            request.user.first_name = first
        if hasattr(request.user, "last_name"):
            request.user.last_name = last
        if first and last:
            setattr(request.user, "full_name", f"{first} {last}")
        elif first and not last:
            setattr(request.user, "full_name", first)
        elif last and not first:
            setattr(request.user, "full_name", last)

    # ---- Email (only check uniqueness if changed) ----
    new_email = (data.get("email") or "").strip()
    if not new_email:
        return JsonResponse({
            "error": "Email is required",
            "field_errors": {"signatory_profile_email": "Email is required"}
        }, status=400)

    if new_email.lower() != (request.user.email or "").lower():
        if User.objects.filter(~Q(pk=request.user.pk), email__iexact=new_email).exists():
            return JsonResponse({
                "error": "Email already in use",
                "field_errors": {"signatory_profile_email": "Email already in use"}
            }, status=400)
        request.user.email = new_email

    # Contact number (if present on your User model)
    if hasattr(request.user, "contact_number"):
        request.user.contact_number = (data.get("contactNumber") or "").strip()

    request.user.save()

    # ---- Profile fields ----
    # birthday -> birthdate
    bday = (data.get("birthday") or "").strip()
    if bday:
        try:
            profile.birthdate = datetime.fromisoformat(bday).date()
        except Exception:
            return JsonResponse({
                "error": "Invalid birthday format (YYYY-MM-DD)",
                "field_errors": {"signatory_profile_birthday": "Invalid date"}
            }, status=400)
    else:
        profile.birthdate = None

    # sex -> gender
    profile.gender = (data.get("sex") or "").strip() or None
    profile.department = (data.get("department") or "").strip() or None
    profile.address = (data.get("address") or "").strip() or None

    # position textbox -> signatory_type (accept key OR label, case-insensitive)
    incoming_pos = (data.get("position") or "").strip()
    if incoming_pos:
        choices = dict(SignatoryProfile.SIGNATORY_TYPES)             # key -> label
        reverse_map = {v.lower(): k for k, v in choices.items()}     # label -> key (lower)
        norm = incoming_pos.lower()
        if incoming_pos in choices:
            profile.signatory_type = incoming_pos
        elif norm in reverse_map:
            profile.signatory_type = reverse_map[norm]
        # else: ignore invalid input (keeps current)

    profile.save()

    # Return updated snapshot so the UI can refresh without a second GET
    pic_url = profile.profile_picture_url
    if pic_url and pic_url.startswith("/"):
        pic_url = request.build_absolute_uri(pic_url)

    return JsonResponse({
        "success": True,
        "message": "Profile updated successfully",
        "profile": {
            "first_name": first or getattr(request.user, "first_name", "") or "",
            "last_name": last or getattr(request.user, "last_name", "") or "",
            "birthday": profile.birthdate.strftime("%Y-%m-%d") if profile.birthdate else "",
            "sex": profile.gender or "",
            "position": profile.signatory_type or "",
            "position_display": dict(SignatoryProfile.SIGNATORY_TYPES).get(profile.signatory_type, profile.signatory_type),
            "department": profile.department or "",
            "address": profile.address or "",
            "email": request.user.email or "",
            "contact_number": getattr(request.user, "contact_number", "") or "",
            "profile_picture_url": pic_url,
        }
    })

# ---------- CHANGE PASSWORD API ----------

@login_required
@require_http_methods(["POST"])
def signatory_profile_change_password_api(request):
    """Change password for signatory"""
    if getattr(request.user, "user_type", None) not in ["signatory", "admin"]:
        return JsonResponse({"error": "Access denied"}, status=403)

    try:
        data = json.loads(request.body or "{}")
    except Exception:
        return JsonResponse({"error": "Invalid JSON body"}, status=400)

    old_password = data.get("old_password")
    new_password = data.get("new_password")

    if not old_password or not new_password:
        return JsonResponse({"error": "Both old and new passwords are required"}, status=400)
    if not request.user.check_password(old_password):
        return JsonResponse({"error": "Current password is incorrect"}, status=400)
    if len(new_password) < 8:
        return JsonResponse({"error": "New password must be at least 8 characters long"}, status=400)

    request.user.set_password(new_password)
    request.user.save()
    update_session_auth_hash(request, request.user)
    return JsonResponse({"success": True, "message": "Password changed successfully"})

# ---------- UPLOAD PICTURE API ----------

@login_required
@require_http_methods(["POST"])
def signatory_profile_upload_picture_api(request):
    """Upload signatory profile picture"""
    if getattr(request.user, "user_type", None) not in ["signatory", "admin"]:
        return JsonResponse({"error": "Access denied"}, status=403)

    if "profile_picture" not in request.FILES:
        return JsonResponse({"error": "No image file provided"}, status=400)

    f = request.FILES["profile_picture"]
    if not f.content_type.startswith("image/"):
        return JsonResponse({"error": "Please upload a valid image file"}, status=400)
    if f.size > 5 * 1024 * 1024:
        return JsonResponse({"error": "Image size should be less than 5MB"}, status=400)

    profile, _ = SignatoryProfile.objects.get_or_create(user=request.user)
    profile.profile_picture = f
    profile.save()

    return JsonResponse({
        "success": True,
        "message": "Profile picture uploaded successfully",
        "profile_picture_url": profile.profile_picture_url,
    })

# ========================================
# BUSINESS MANAGER VIEWS
# ========================================

def is_business_manager(user):
    """Check if user is a Business Manager"""
    return (
        user.user_type == 'business_manager' or 
        (user.user_type == 'signatory' and 
         hasattr(user, 'signatory_profile') and 
         user.signatory_profile.signatory_type == 'business_manager')
    )

@login_required
def business_manager_dashboard(request):
    """Business Manager Dashboard"""
    if not is_business_manager(request.user):
        return redirect('login')
    return render(request, 'BUSINESSMDASHBOARD.html')

@login_required
def business_manager_clearance(request):
    """Business Manager Clearance Management - mirrors registrar clearance functionality"""
    if not is_business_manager(request.user):
        return redirect('login')
    
    # Get clearance forms with related data (same as registrar)
    clearance_forms = ClearanceForm.objects.select_related('student', 'student__profile').prefetch_related('signatories').all()
    
    # Get unique values for filters from StudentProfile (same as registrar)
    courses = clearance_forms.values_list('student__profile__program', flat=True).distinct()
    years = clearance_forms.values_list('student__profile__year_level', flat=True).distinct()
    # Get sections from ClearanceForm model
    sections = clearance_forms.values_list('section', flat=True).distinct()
    
    context = {
        'clearance_forms': clearance_forms,
        'courses': courses,
        'years': years,
        'sections': sections,
    }
    
    return render(request, 'BUSINESSMCLEARANCE.html', context)

@login_required
def business_manager_enrollment(request):
    """Business Manager Enrollment Management"""
    if not is_business_manager(request.user):
        return redirect('login')
    return render(request, 'BUSINESSMENROLLMENT.html')

@login_required
def business_manager_graduation(request):
    """Business Manager Graduation Management"""
    if not is_business_manager(request.user):
        return redirect('login')
    return render(request, 'BUSINESSMGRADUATION.html')

@login_required
def business_manager_bulk_approve_graduation(request):
    """Bulk approve multiple graduation forms for Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            graduation_ids = data.get('graduation_ids', [])
            pin = data.get('pin')
            comment = data.get('remarks', '')
            
            # Verify PIN first
            if not verify_bm_pin_helper(request.user, pin):
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            if not graduation_ids:
                return JsonResponse({'error': 'No graduation forms provided'}, status=400)
            
            graduation_forms = GraduationForm.objects.filter(id__in=graduation_ids)
            
            if not graduation_forms.exists():
                return JsonResponse({'error': 'No graduation forms found'}, status=404)
            
            # Process bulk approval
            approved_count = 0
            student_names = []
            
            for graduation in graduation_forms:
                try:
                    # Create or update business manager signatory (same as individual approval)
                    business_signatory, created = GraduationSignatory.objects.get_or_create(
                        graduation=graduation,
                        signatory=request.user,
                        role='business_manager',
                        defaults={'status': 'pending'}
                    )
                    
                    if business_signatory.status == 'approved':
                        continue  # Skip if already approved
                    
                    # Update status
                    business_signatory.status = 'approved'
                    business_signatory.remarks = comment
                    business_signatory.ip_address = get_client_ip(request)
                    business_signatory.save()
                    
                    approved_count += 1
                    student_names.append(graduation.user.get_full_name())
                    
                    # Create individual notification for the student
                    Notification.objects.create(
                        recipient=graduation.user,
                        message=f"Your graduation form has been approved by Business Manager with remarks: {comment}" if comment else "Your graduation form has been approved by Business Manager",
                        notification_type='graduation_approved',
                        priority='normal'
                    )
                    
                    # Log activity
                    ActivityLog.objects.create(
                        user=request.user,
                        action=f'Approved graduation form for {graduation.user.get_full_name()}',
                        model_affected='GraduationForm',
                        record_id=str(graduation.id),
                        ip_address=get_client_ip(request)
                    )
                    
                except Exception as e:
                    print(f"Error approving graduation {graduation.id}: {str(e)}")
                    continue
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully approved {approved_count} graduation form(s): {", ".join(student_names)}'
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON data'}, status=400)
        except Exception as e:
            print(f"Bulk approve error: {str(e)}")
            return JsonResponse({'error': 'Failed to process bulk approval'}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def business_manager_bulk_disapprove_graduation(request):
    """Bulk disapprove multiple graduation forms for Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            graduation_ids = data.get('graduation_ids', [])
            pin = data.get('pin')
            remarks = data.get('remarks', '')
            appointment_date = data.get('appointment_date')
            
            # Verify PIN first
            if not verify_bm_pin_helper(request.user, pin):
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            if not graduation_ids:
                return JsonResponse({'error': 'No graduation forms provided'}, status=400)
            
            if not remarks:
                return JsonResponse({'error': 'Disapproval reason is required'}, status=400)
                
            graduation_forms = GraduationForm.objects.filter(id__in=graduation_ids)
            
            if not graduation_forms.exists():
                return JsonResponse({'error': 'No graduation forms found'}, status=404)
            
            # Process bulk disapproval
            disapproved_count = 0
            student_names = []
            
            for graduation in graduation_forms:
                try:
                    # Create or update business manager signatory (same as individual disapproval)
                    business_signatory, created = GraduationSignatory.objects.get_or_create(
                        graduation=graduation,
                        signatory=request.user,
                        role='business_manager',
                        defaults={'status': 'pending'}
                    )
                    
                    if business_signatory.status == 'disapproved':
                        continue  # Skip if already disapproved
                    
                    # Update status
                    business_signatory.status = 'disapproved'
                    business_signatory.remarks = remarks
                    business_signatory.ip_address = get_client_ip(request)
                    business_signatory.save()
                    
                    disapproved_count += 1
                    student_names.append(graduation.user.get_full_name())
                    
                    # Create individual notification for the student
                    Notification.objects.create(
                        recipient=graduation.user,
                        message=f"Your graduation form has been disapproved by Business Manager. Reason: {remarks}",
                        notification_type='graduation_disapproved',
                        priority='high'
                    )
                    
                    # Create calendar event for appointment if date provided
                    if appointment_date:
                        try:
                            appointment_datetime = datetime.strptime(appointment_date, '%Y-%m-%d').replace(hour=9, minute=0)
                            CalendarEvent.objects.create(
                                title=f"Business Manager Appointment - {graduation.user.get_full_name()}",
                                description=f"Appointment regarding disapproved graduation form. Reason: {remarks}",
                                start_time=appointment_datetime,
                                end_time=appointment_datetime + timedelta(hours=1),
                                created_by=request.user,
                                event_type='appointment'
                            )
                        except ValueError:
                            pass  # Skip if date format is invalid
                    
                    # Log activity
                    ActivityLog.objects.create(
                        user=request.user,
                        action=f'Disapproved graduation form for {graduation.user.get_full_name()} - {remarks}',
                        model_affected='GraduationForm',
                        record_id=str(graduation.id),
                        ip_address=get_client_ip(request)
                    )
                    
                except Exception as e:
                    print(f"Error disapproving graduation {graduation.id}: {str(e)}")
                    continue
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully disapproved {disapproved_count} graduation form(s): {", ".join(student_names)}'
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON data'}, status=400)
        except Exception as e:
            print(f"Bulk disapprove error: {str(e)}")
            return JsonResponse({'error': 'Failed to process bulk disapproval'}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def business_manager_graduation_data_api(request):
    """API endpoint to get graduation data for the business manager - MATCHES REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get all graduation forms with related data
        graduation_forms = GraduationForm.objects.select_related('user').all().order_by('-created_at')
        
        data = []
        for form in graduation_forms:
            business_signatory = form.signatories.filter(role='business_manager').first()
            registrar_signatory = form.signatories.filter(role='registrar').first()
            dean_signatory = form.signatories.filter(role='dean').first()
            president_signatory = form.signatories.filter(role='president').first()
            
            # Determine overall status based on all required signatories (including president)
            all_signatories = form.signatories.all()
            roles_required = {'dean', 'business_manager', 'registrar', 'president'}
            statuses = {s.role: s.status for s in all_signatories}
            
            # Overall status logic: only "pending" or "completed"
            if roles_required.issubset(statuses.keys()) and all(statuses.get(role, 'pending') == 'approved' for role in roles_required):
                status = 'completed'
                # Use the latest timestamp among all approvals for completed status
                timestamps = []
                for signatory in [dean_signatory, business_signatory, registrar_signatory, president_signatory]:
                    if signatory and signatory.status == 'approved':
                        timestamps.append(signatory.updated_at)
                overall_timestamp = max(timestamps).astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if timestamps else None
            else:
                status = 'pending'
                overall_timestamp = None
            
            # Get section from enrollment forms
            enrollment_form = EnrollmentForm.objects.filter(user=form.user).first()
            section = enrollment_form.section if enrollment_form else 'N/A'
            
            graduation_data = {
                'id': str(form.id),
                'student_name': form.user.full_name,
                'course': form.user.profile.program if hasattr(form.user, 'profile') else 'N/A',
                'year': form.user.profile.year_level if hasattr(form.user, 'profile') else 'N/A',
                'section': section,
                'id_number': form.user.profile.student_number if hasattr(form.user, 'profile') else 'N/A',
                'grad_appno': form.grad_appno or 'N/A',
                'date_submitted': form.created_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p'),
                'pdf_file': 'Graduation_Form.pdf',
                'dean_status': dean_signatory.status if dean_signatory else 'pending',
                'dean_timestamp': dean_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if dean_signatory and dean_signatory.status != 'pending' else '',
                'business_status': business_signatory.status if business_signatory else 'pending',
                'business_timestamp': business_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if business_signatory and business_signatory.status != 'pending' else '',
                'business_remarks': business_signatory.remarks if business_signatory else '',
                'registrar_status': registrar_signatory.status if registrar_signatory else 'pending',
                'registrar_timestamp': registrar_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if registrar_signatory and registrar_signatory.status != 'pending' else '',
                'registrar_remarks': registrar_signatory.remarks if registrar_signatory else '',
                'president_status': president_signatory.status if president_signatory else 'pending',
                'president_timestamp': president_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if president_signatory and president_signatory.status != 'pending' else '',
                'president_remarks': president_signatory.remarks if president_signatory else '',
                'overall_status': status,
                'overall_timestamp': overall_timestamp,
            }
            data.append(graduation_data)
        
        return JsonResponse({'data': data})
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_graduation_approve(request):
    """Approve a graduation form - Business Manager endpoint"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        graduation_id = data.get('graduation_id')
        pin = data.get('pin')
        comment = data.get('comment', '')
        
        if not graduation_id or not pin:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Verify PIN using the centralized helper function
        if not verify_bm_pin_helper(request.user, pin):
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get graduation form
        graduation = GraduationForm.objects.get(id=graduation_id)
        
        # Create or update business manager signatory
        business_signatory, created = GraduationSignatory.objects.get_or_create(
            graduation=graduation,
            signatory=request.user,
            role='business_manager',
            defaults={'status': 'pending'}
        )
        
        if business_signatory.status == 'approved':
            return JsonResponse({'error': 'Graduation form has already been approved'}, status=400)
        
        # Update status
        business_signatory.status = 'approved'
        business_signatory.remarks = comment
        business_signatory.ip_address = get_client_ip(request)
        business_signatory.save()
        
        # Send individual approval notification to student
        try:
            from landing.notification_service import NotificationService
            NotificationService.notify_form_approval(
                form_instance=graduation,
                form_type='graduation',
                signatory_user=request.user,
                remarks=comment
            )
        except Exception as e:
            print(f"Error sending approval notification: {e}")
        
        # Check if all required signatories approved and update graduation status
        required_roles = ['dean', 'business_manager', 'registrar', 'president']
        all_signatories = GraduationSignatory.objects.filter(graduation=graduation)
        
        # Check if we have all required roles and all are approved
        signatory_roles = set(sig.role for sig in all_signatories)
        required_roles_set = set(required_roles)
        
        if (signatory_roles >= required_roles_set and 
            all_signatories.count() >= 4 and 
            all(s.status == 'approved' for s in all_signatories)):
            graduation.status = 'approved'
            graduation.save()
            
            # Send notifications for completed graduation
            try:
                from landing.notification_service import NotificationService
                NotificationService.notify_graduation_completed(graduation.user, graduation)
                NotificationService.notify_admin_form_completed('graduation', graduation.user.full_name)
            except Exception as e:
                print(f"Error sending graduation completion notifications: {e}")
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_approval',
            description=f'Business Manager approved graduation form {graduation_id} for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Graduation form approved successfully'
        })
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_graduation_disapprove(request):
    """Disapprove a graduation form - Business Manager endpoint"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        graduation_id = data.get('graduation_id')
        pin = data.get('pin')
        reasons = data.get('reasons', [])
        appointment_date = data.get('appointment_date')
        comment = data.get('comment', '')
        
        if not graduation_id or not pin:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Verify PIN using the centralized helper function
        if not verify_bm_pin_helper(request.user, pin):
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get graduation form
        graduation = GraduationForm.objects.get(id=graduation_id)
        
        # Create or update business manager signatory
        business_signatory, created = GraduationSignatory.objects.get_or_create(
            graduation=graduation,
            signatory=request.user,
            role='business_manager',
            defaults={'status': 'pending'}
        )
        
        if business_signatory.status == 'disapproved':
            return JsonResponse({'error': 'Graduation form has already been disapproved'}, status=400)
        
        # Update status
        business_signatory.status = 'disapproved'
        business_signatory.remarks = f"Reasons: {', '.join(reasons)}. Appointment: {appointment_date}. {comment}"
        business_signatory.ip_address = get_client_ip(request)
        business_signatory.save()
        
        # Send notification to student
        try:
            from landing.notification_service import NotificationService
            notification_service = NotificationService()
            notification_service.handle_form_disapproval(
                form=graduation,
                form_type='graduation',
                disapproval_reasons=reasons,
                settlement_instructions=comment,
                appointment_date=appointment_date
            )
        except Exception as e:
            print(f"Error sending business manager graduation disapproval notification: {e}")
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_disapproval',
            description=f'Business Manager disapproved graduation form {graduation_id} for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Graduation form disapproved successfully'
        })
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_graduation_delete(request, graduation_id):
    """Delete a graduation form - Business Manager endpoint"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'DELETE':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        graduation = GraduationForm.objects.get(id=graduation_id)
        student_name = graduation.user.full_name
        
        # Delete the graduation form
        graduation.delete()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_deletion',
            description=f'Business Manager deleted graduation form {graduation_id} for {student_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Graduation form deleted successfully'
        })
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_graduation_bulk_delete(request):
    """Bulk delete graduation forms - Business Manager endpoint"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        graduation_ids = data.get('graduation_ids', [])
        
        if not graduation_ids:
            return JsonResponse({'error': 'No graduation forms selected'}, status=400)
        
        # Get all graduation forms to delete
        graduations = GraduationForm.objects.filter(id__in=graduation_ids)
        deleted_count = len(graduations)
        student_names = [g.user.full_name for g in graduations]
        
        # Delete all forms
        graduations.delete()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_bulk_deletion',
            description=f'Business Manager bulk deleted {deleted_count} graduation forms for: {", ".join(student_names)} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({
            'success': True,
            'message': f'Successfully deleted {deleted_count} graduation forms'
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_graduation_edit_status(request):
    """Edit graduation form status from disapproved back to approved - Business Manager endpoint"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        data = json.loads(request.body)
        graduation_id = data.get('graduation_id')
        pin = data.get('pin')
        comment = data.get('comment', '')
        
        if not graduation_id or not pin:
            return JsonResponse({'error': 'Missing required fields'}, status=400)
        
        # Verify PIN using the centralized helper function
        if not verify_bm_pin_helper(request.user, pin):
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get graduation form
        graduation = GraduationForm.objects.get(id=graduation_id)
        
        # Get business manager signatory
        business_signatory = graduation.signatories.filter(role='business_manager').first()
        
        if not business_signatory:
            return JsonResponse({'error': 'Business manager signatory record not found'}, status=404)
        
        if business_signatory.status != 'disapproved':
            return JsonResponse({'error': 'Only disapproved graduation forms can be edited'}, status=400)
        
        # Update status back to approved
        business_signatory.status = 'approved'
        business_signatory.remarks = f"Status changed from disapproved to approved. {comment}"
        business_signatory.ip_address = get_client_ip(request)
        business_signatory.save()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='graduation_status_edit',
            description=f'Business Manager changed graduation form {graduation_id} status from disapproved to approved for {graduation.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Graduation form status updated to approved'
        })
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_graduation_preview_print(request):
    """Return printable HTML fragment for graduation preview modal - Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    graduation_ids = request.GET.get('ids', '').split(',')
    if not graduation_ids or graduation_ids == ['']:
        return JsonResponse({'error': 'No graduation IDs provided'}, status=400)
    
    # Filter out empty IDs
    graduation_ids = [id.strip() for id in graduation_ids if id.strip()]
    if not graduation_ids:
        return JsonResponse({'error': 'No valid graduation IDs provided'}, status=400)
    
    graduation_forms = []
    
    # Efficiently fetch all graduations
    graduations = GraduationForm.objects.select_related(
        'user', 'user__profile'
    ).filter(id__in=graduation_ids)
    
    for graduation_form in graduations:
        try:
            graduation_forms.append({
                'graduation': graduation_form,
                'student': graduation_form.user,
                'profile': graduation_form.user.profile,
            })
        except Exception as e:
            continue  # Skip problematic graduations
    
    # Check if any graduations were found
    if not graduation_forms:
        return JsonResponse({'error': 'No valid graduation forms found for the provided IDs'}, status=400)
    
    context = {
        'graduation_forms': graduation_forms,
        'is_preview': True,  # Flag to indicate this is for preview
    }
    
    return render(request, 'pdf/pdf-graduation.html', context)

@login_required
def business_manager_graduation_view(request, graduation_id):
    """View a graduation form in modal - Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        graduation = GraduationForm.objects.get(id=graduation_id)
        profile = getattr(graduation.user, 'profile', None)
        
        # Populate the form with actual data using the same context as registrar
        context = {
            'graduation': graduation,
            'user': graduation.user,
            'profile': profile,
            'today': date.today().strftime('%Y-%m-%d')
        }
        
        # Return the modal-specific graduation form template (without HTML document structure)
        return render(request, 'pdf/pdf-graduation-modal.html', context)
        
    except GraduationForm.DoesNotExist:
        return JsonResponse({'error': 'Graduation form not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def student_enrollment_pdf(request):
    """Student PDF download for enrollment forms"""
    if request.user.user_type != 'student':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    enrollment_ids = request.GET.get('ids', '').split(',')
    enrollment_ids = [eid.strip() for eid in enrollment_ids if eid.strip()]
    download_mode = request.GET.get('download', 'false').lower() == 'true'
    
    if not enrollment_ids:
        return JsonResponse({'error': 'No enrollment IDs provided'}, status=400)
    
    try:
        # Efficiently fetch enrollments with related data
        enrollments = EnrollmentForm.objects.select_related(
            'user', 'user__profile'
        ).filter(id__in=enrollment_ids, user=request.user)
        
        enrollment_forms = []
        for enrollment_form in enrollments:
            enrollment_forms.append({
                'enrollment': enrollment_form,
                'student': enrollment_form.user,
                'profile': enrollment_form.user.profile,
            })
        
        if not enrollment_forms:
            return JsonResponse({'error': 'No valid enrollment forms found'}, status=400)
        
        context = {
            'enrollment_forms': enrollment_forms,
            'today': date.today().strftime('%Y-%m-%d')
        }
        
        # Return the enrollment form template (same as we used for signatory)
        return render(request, 'pdf/pdf-enrollment.html', context)
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_credential_request(request):
    """Business Manager Credential Request Management"""
    if not is_business_manager(request.user):
        return redirect('login')
    return render(request, 'BUSINESSMCREDREQ.html')

@login_required
def business_manager_bulk_approve_credential(request):
    """Bulk approve multiple credential requests for Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            credential_ids = data.get('credential_ids', [])
            pin = data.get('pin')
            comment = data.get('remarks', '')
            
            # Verify PIN first
            if not verify_bm_pin_helper(request.user, pin):
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            if not credential_ids:
                return JsonResponse({'error': 'No credential requests provided'}, status=400)
            
            credential_requests = DocumentRequest.objects.filter(id__in=credential_ids)
            
            if not credential_requests.exists():
                return JsonResponse({'error': 'No credential requests found'}, status=404)
            
            # Process bulk approval
            approved_count = 0
            student_names = []
            
            for credential in credential_requests:
                try:
                    # Update business manager status
                    credential.business_manager_status = 'approved'
                    credential.business_manager_timestamp = timezone.now()
                    credential.business_manager_comment = comment
                    credential.save()
                    
                    approved_count += 1
                    student_names.append(credential.requester.get_full_name())
                    
                    # Create individual notification for the student
                    Notification.objects.create(
                        recipient=credential.requester,
                        message=f"Your credential request has been approved by Business Manager with remarks: {comment}" if comment else "Your credential request has been approved by Business Manager",
                        notification_type='credential_approved',
                        priority='normal'
                    )
                    
                    # Log activity
                    ActivityLog.objects.create(
                        user=request.user,
                        action=f'Approved credential request for {credential.requester.get_full_name()}',
                        model_affected='DocumentRequest',
                        record_id=str(credential.id),
                        ip_address=get_client_ip(request)
                    )
                    
                except Exception as e:
                    print(f"Error approving credential {credential.id}: {str(e)}")
                    continue
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully approved {approved_count} credential request(s): {", ".join(student_names)}'
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON data'}, status=400)
        except Exception as e:
            print(f"Bulk approve error: {str(e)}")
            return JsonResponse({'error': 'Failed to process bulk approval'}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def business_manager_bulk_disapprove_credential(request):
    """Bulk disapprove multiple credential requests for Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            credential_ids = data.get('credential_ids', [])
            pin = data.get('pin')
            remarks = data.get('remarks', '')
            appointment_date = data.get('appointment_date')
            
            # Verify PIN first
            if not verify_bm_pin_helper(request.user, pin):
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            if not credential_ids:
                return JsonResponse({'error': 'No credential requests provided'}, status=400)
            
            if not remarks:
                return JsonResponse({'error': 'Disapproval reason is required'}, status=400)
                
            credential_requests = DocumentRequest.objects.filter(id__in=credential_ids)
            
            if not credential_requests.exists():
                return JsonResponse({'error': 'No credential requests found'}, status=404)
            
            # Process bulk disapproval
            disapproved_count = 0
            student_names = []
            
            for credential in credential_requests:
                try:
                    # Update business manager status
                    credential.business_manager_status = 'disapproved'
                    credential.business_manager_timestamp = timezone.now()
                    credential.business_manager_comment = remarks
                    credential.save()
                    
                    disapproved_count += 1
                    student_names.append(credential.requester.get_full_name())
                    
                    # Create individual notification for the student
                    Notification.objects.create(
                        recipient=credential.requester,
                        message=f"Your credential request has been disapproved by Business Manager. Reason: {remarks}",
                        notification_type='credential_disapproved',
                        priority='high'
                    )
                    
                    # Create calendar event for appointment if date provided
                    if appointment_date:
                        try:
                            appointment_datetime = datetime.strptime(appointment_date, '%Y-%m-%d').replace(hour=9, minute=0)
                            CalendarEvent.objects.create(
                                title=f"Business Manager Appointment - {credential.requester.get_full_name()}",
                                description=f"Appointment regarding disapproved credential request. Reason: {remarks}",
                                start_time=appointment_datetime,
                                end_time=appointment_datetime + timedelta(hours=1),
                                created_by=request.user,
                                event_type='appointment'
                            )
                        except ValueError:
                            pass  # Skip if date format is invalid
                    
                    # Log activity
                    ActivityLog.objects.create(
                        user=request.user,
                        action=f'Disapproved credential request for {credential.requester.get_full_name()} - {remarks}',
                        model_affected='DocumentRequest',
                        record_id=str(credential.id),
                        ip_address=get_client_ip(request)
                    )
                    
                except Exception as e:
                    print(f"Error disapproving credential {credential.id}: {str(e)}")
                    continue
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully disapproved {disapproved_count} credential request(s): {", ".join(student_names)}'
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON data'}, status=400)
        except Exception as e:
            print(f"Bulk disapprove error: {str(e)}")
            return JsonResponse({'error': 'Failed to process bulk disapproval'}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def business_manager_approve_credential(request):
    """Approve a credential request as business manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        credential_id = data.get('credential_id')
        pin = data.get('pin', '')
        comment = data.get('comment', '')
        
        if not credential_id:
            return JsonResponse({'error': 'Credential ID is required'}, status=400)
        
        if not pin:
            return JsonResponse({'error': 'PIN is required'}, status=400)
        
        # Verify PIN
        if not verify_bm_pin_helper(request.user, pin):
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get document request
        doc_request = DocumentRequest.objects.get(id=credential_id)
        
        # Update business manager status
        doc_request.business_manager_status = 'approved'
        doc_request.business_manager_timestamp = timezone.now()
        doc_request.business_manager_comment = comment
        doc_request.save()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='credential_approve',
            description=f'Business Manager approved credential request {credential_id} for {doc_request.requester.full_name} [IP: {get_client_ip(request)}]'
        )
        
        # Log activity for reports
        BusinessManagerActivityLog.objects.create(
            business_manager=request.user,
            action_type='approve',
            form_type='credential',
            form_id=doc_request.id,
            student_name=doc_request.requester.full_name,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        return JsonResponse({'success': True, 'message': 'Credential request approved successfully'})
        
    except DocumentRequest.DoesNotExist:
        return JsonResponse({'error': 'Credential request not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_disapprove_credential(request):
    """Disapprove a credential request as business manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        credential_id = data.get('credential_id')
        pin = data.get('pin', '')
        reasons = data.get('reasons', [])
        comment = data.get('comment', '')
        appointment_date = data.get('appointment_date', '')
        
        if not credential_id:
            return JsonResponse({'error': 'Credential ID is required'}, status=400)
        
        if not pin:
            return JsonResponse({'error': 'PIN is required'}, status=400)
            
        if not reasons:
            return JsonResponse({'error': 'Reasons are required'}, status=400)
            
        if not appointment_date:
            return JsonResponse({'error': 'Appointment date is required'}, status=400)
        
        # Verify PIN
        if not verify_bm_pin_helper(request.user, pin):
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get document request
        doc_request = DocumentRequest.objects.get(id=credential_id)
        
        # Update business manager status
        doc_request.business_manager_status = 'disapproved'
        doc_request.business_manager_timestamp = timezone.now()
        doc_request.business_manager_comment = f"Reasons: {', '.join(reasons)}. Appointment: {appointment_date}. {comment}"
        doc_request.save()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='credential_disapproval',
            description=f'Business Manager disapproved credential request {credential_id} for {doc_request.requester.full_name} [IP: {get_client_ip(request)}]'
        )
        
        # Log activity for reports
        BusinessManagerActivityLog.objects.create(
            business_manager=request.user,
            action_type='disapprove',
            form_type='credential',
            form_id=doc_request.id,
            student_name=doc_request.requester.full_name,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        return JsonResponse({'success': True, 'message': 'Credential request disapproved successfully'})
        
    except DocumentRequest.DoesNotExist:
        return JsonResponse({'error': 'Credential request not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_edit_credential_status(request):
    """Edit credential request status from disapproved back to approved - Business Manager endpoint"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        credential_id = data.get('credential_id')
        pin = data.get('pin', '')
        comment = data.get('comment', '')
        
        if not credential_id:
            return JsonResponse({'error': 'Credential ID is required'}, status=400)
        
        if not pin:
            return JsonResponse({'error': 'PIN is required'}, status=400)
        
        # Verify PIN
        if not verify_bm_pin_helper(request.user, pin):
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get document request
        doc_request = DocumentRequest.objects.get(id=credential_id)
        
        # Can only edit if currently disapproved
        if doc_request.business_manager_status != 'disapproved':
            return JsonResponse({'error': 'Can only edit disapproved credential requests'}, status=400)
        
        # Update status back to approved
        doc_request.business_manager_status = 'approved'
        doc_request.business_manager_timestamp = timezone.now()
        doc_request.business_manager_comment = comment
        doc_request.save()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='credential_edit_status',
            description=f'Business Manager changed credential status from disapproved to approved for {doc_request.requester.full_name} [IP: {get_client_ip(request)}]'
        )
        
        # Log activity for reports
        BusinessManagerActivityLog.objects.create(
            business_manager=request.user,
            action_type='approve',
            form_type='credential',
            form_id=doc_request.id,
            student_name=doc_request.requester.full_name,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        return JsonResponse({'success': True, 'message': 'Credential status updated successfully'})
        
    except DocumentRequest.DoesNotExist:
        return JsonResponse({'error': 'Credential request not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_preview_print_credential(request):
    """Return printable HTML fragment for credential preview modal - Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    credential_ids = request.GET.get('ids', '').split(',')
    if not credential_ids or credential_ids == ['']:
        return JsonResponse({'error': 'No credential IDs provided'}, status=400)
    
    # Filter out empty IDs
    credential_ids = [id.strip() for id in credential_ids if id.strip()]
    if not credential_ids:
        return JsonResponse({'error': 'No valid credential IDs provided'}, status=400)
    
    credential_requests = []
    
    # Fetch all credential requests
    documents = DocumentRequest.objects.select_related('requester').filter(id__in=credential_ids)
    
    for doc_request in documents:
        try:
            credential_requests.append({
                'document': doc_request,
                'requester': doc_request.requester,
            })
        except Exception as e:
            continue  # Skip problematic documents
    
    # Check if any documents were found
    if not credential_requests:
        return JsonResponse({'error': 'No credential requests found'}, status=404)
    
    context = {
        'credential_requests': credential_requests,
        'print_date': timezone.now().strftime('%B %d, %Y at %I:%M %p'),
        'printed_by': request.user.full_name,
    }
    
    return render(request, 'pdf/credential-request.html', context)

@login_required
def business_manager_delete_credential(request, credential_id):
    """Delete single credential request - Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'DELETE':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        doc_request = DocumentRequest.objects.get(id=credential_id)
        requester_name = doc_request.requester.full_name
        
        # Delete the document request
        doc_request.delete()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='credential_delete',
            description=f'Business Manager deleted credential request for {requester_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({'success': True, 'message': 'Credential request deleted successfully'})
        
    except DocumentRequest.DoesNotExist:
        return JsonResponse({'error': 'Credential request not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_bulk_delete_credential(request):
    """Bulk delete credential requests - Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        credential_ids = data.get('credential_ids', [])
        
        if not credential_ids:
            return JsonResponse({'error': 'No credential IDs provided'}, status=400)
        
        # Delete the credential requests
        deleted_count = 0
        for doc_id in credential_ids:
            try:
                doc_request = DocumentRequest.objects.get(id=doc_id)
                requester_name = doc_request.requester.full_name
                doc_request.delete()
                deleted_count += 1
                
                # Log the action
                AuditLog.objects.create(
                    user=request.user,
                    action_type='credential_delete',
                    description=f'Business Manager bulk deleted credential request for {requester_name} [IP: {get_client_ip(request)}]'
                )
            except DocumentRequest.DoesNotExist:
                continue
        
        return JsonResponse({
            'success': True,
            'message': f'Successfully deleted {deleted_count} credential request(s)',
            'deleted_count': deleted_count
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_reports(request):
    """Business Manager Reports"""
    if not is_business_manager(request.user):
        return redirect('login')
    return render(request, 'BUSINESSMREPORTS.html')

@login_required
def business_manager_reports_data_api(request):
    """API endpoint to get reports data for business manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get filter parameters
        from_date = request.GET.get('from_date', '')
        to_date = request.GET.get('to_date', '')
        form_status = request.GET.get('form_status', '')
        period_type = request.GET.get('period_type', '')
        
        # Get activity logs for this business manager
        activity_logs = BusinessManagerActivityLog.objects.filter(
            business_manager=request.user
        )
        
        # Apply date filters
        if from_date:
            activity_logs = activity_logs.filter(created_at__date__gte=from_date)
        
        if to_date:
            activity_logs = activity_logs.filter(created_at__date__lte=to_date)
        
        # Apply form status filter
        if form_status:
            if form_status == 'approve':
                activity_logs = activity_logs.filter(action_type='approve')
            elif form_status == 'disapprove':
                activity_logs = activity_logs.filter(action_type='disapprove')
            elif form_status == 'view':
                activity_logs = activity_logs.filter(action_type='view')
        
        # Apply period filter
        if period_type:
            from datetime import datetime, timezone as dt_timezone, timedelta
            now = timezone.now()
            
            if period_type == 'day':
                start_date = now - timedelta(days=1)
            elif period_type == 'week':
                start_date = now - timedelta(weeks=1)
            elif period_type == 'month':
                start_date = now - timedelta(days=30)
            else:
                start_date = None
            
            if start_date:
                activity_logs = activity_logs.filter(created_at__gte=start_date)
        
        # Format the reports data for BusinessManagerActivityLog
        reports_data = []
        for log in activity_logs:
            # Get student's course info
            course = "N/A"
            try:
                if log.form_type == 'clearance':
                    form = ClearanceForm.objects.get(id=log.form_id)
                    course = form.student.profile.program if hasattr(form.student, 'profile') else "N/A"
                elif log.form_type == 'enrollment':
                    form = EnrollmentForm.objects.get(id=log.form_id)
                    course = form.student.profile.program if hasattr(form.student, 'profile') else "N/A"
                elif log.form_type == 'graduation':
                    form = GraduationForm.objects.get(id=log.form_id)
                    course = form.student.profile.program if hasattr(form.student, 'profile') else "N/A"
                elif log.form_type == 'credential':
                    form = DocumentRequest.objects.get(id=log.form_id)
                    course = form.requester.profile.program if hasattr(form.requester, 'profile') else "N/A"
            except Exception:
                course = "N/A"
            
            reports_data.append({
                'student_name': log.student_name,
                'course': course,
                'form_type': log.form_type.title(),
                'action_type': log.action_type.title(),
                'business_manager': log.business_manager.full_name,
                'date': log.created_at.strftime('%Y-%m-%d'),
                'time': log.created_at.strftime('%H:%M:%S'),
                'ip_address': log.ip_address or 'N/A',
            })
        
        return JsonResponse({
            'success': True,
            'reports': reports_data
        })
    
    except Exception as e:
        print(f"Error in business_manager_reports_data_api: {str(e)}")
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)

@login_required
def business_manager_generated_reports_list(request):
    """API endpoint to get list of generated reports for business manager (includes both GeneratedReport and AutoGeneratedReport)"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get reports from both models since business manager saves to different models
        generated_reports = list(GeneratedReport.objects.filter(generated_by=request.user))
        auto_reports = list(AutoGeneratedReport.objects.filter(created_by=request.user))
        
        # Get filter parameters
        report_type_filter = request.GET.get('report_type', '')
        generation_type_filter = request.GET.get('generation_type', '')  # manual/auto
        
        # Combine and process both types of reports
        all_reports = []
        
        # Process GeneratedReport entries (these are typically from auto-generation or registrar manual reports)
        for report in generated_reports:
            if report_type_filter and report.report_type != report_type_filter:
                continue
            
            is_auto = report.generated_by is None
            if generation_type_filter == 'manual' and is_auto:
                continue
            elif generation_type_filter == 'auto' and not is_auto:
                continue
                
            all_reports.append({
                'model': 'GeneratedReport',
                'report': report,
                'is_auto': is_auto
            })
        
        # Process AutoGeneratedReport entries (these are typically manual reports from signatory/business manager)
        for report in auto_reports:
            if report_type_filter and report.report_type != report_type_filter:
                continue
            
            # AutoGeneratedReport with created_by are manual reports
            is_auto = False  # These are manual reports created by users
            if generation_type_filter == 'auto':
                continue  # Skip manual reports if filtering for auto only
                
            all_reports.append({
                'model': 'AutoGeneratedReport', 
                'report': report,
                'is_auto': is_auto
            })
        
        # Sort by creation date (most recent first)
        from django.utils import timezone
        from datetime import datetime, timezone as dt_timezone
        def get_creation_date(entry):
            report = entry['report']
            # AutoGeneratedReport uses 'generated_at', GeneratedReport uses 'created_at'
            if hasattr(report, 'generated_at'):
                return report.generated_at
            elif hasattr(report, 'created_at'):
                return report.created_at
            else:
                return datetime.min.replace(tzinfo=dt_timezone.utc)
        
        all_reports.sort(key=get_creation_date, reverse=True)
        
        reports = []
        
        for entry in all_reports:
            report = entry['report']
            model_type = entry['model']
            is_auto = entry['is_auto']
            
            # Get file information - different for each model type
            if model_type == 'GeneratedReport':
                file_size = report.size_bytes or 0
                exists = report.file_exists
                filename = report.file.name.split('/')[-1] if report.file else 'N/A'
            else:  # AutoGeneratedReport
                file_size = 0  # AutoGeneratedReport doesn't have size_bytes
                exists = bool(report.file_path and os.path.exists(os.path.join(settings.MEDIA_ROOT, report.file_path))) if hasattr(report, 'file_path') else False
                filename = os.path.basename(report.file_path) if hasattr(report, 'file_path') and report.file_path else 'N/A'
            
            download_url = f"/business-manager/reports/download-report/{report.id}/" if exists else None
            
            # Format date range - different field names for each model
            date_range = 'N/A'
            start_date = 'N/A'
            end_date = 'N/A'
            
            if model_type == 'GeneratedReport':
                if hasattr(report, 'period_start') and hasattr(report, 'period_end') and report.period_start and report.period_end:
                    date_range = f"{report.period_start} to {report.period_end}"
                    start_date = str(report.period_start)
                    end_date = str(report.period_end)
            else:  # AutoGeneratedReport
                if hasattr(report, 'start_date') and hasattr(report, 'end_date') and report.start_date and report.end_date:
                    date_range = f"{report.start_date} to {report.end_date}"
                    start_date = str(report.start_date)
                    end_date = str(report.end_date)
            
            # Format report type display
            report_type_display = report.get_report_type_display() if hasattr(report, 'get_report_type_display') else (report.report_type.title() if hasattr(report, 'report_type') else 'Unknown')
            
            # Get creation date - AutoGeneratedReport uses 'generated_at', GeneratedReport uses 'created_at'
            if hasattr(report, 'generated_at'):
                created_at = report.generated_at
            elif hasattr(report, 'created_at'):
                created_at = report.created_at
            else:
                created_at = None
            generated_at = created_at.strftime('%Y-%m-%d %H:%M:%S') if created_at else 'N/A'
            
            # Get generated_by info
            if model_type == 'GeneratedReport':
                generated_by = report.generated_by.full_name if hasattr(report, 'generated_by') and report.generated_by else 'System (Auto)'
            else:  # AutoGeneratedReport
                generated_by = report.created_by.full_name if hasattr(report, 'created_by') and report.created_by else 'Unknown'
            
            reports.append({
                'id': str(report.id),
                'type': 'auto' if is_auto else 'manual',
                'report_type': report_type_display,
                'report_type_display': report_type_display,
                'period_type': 'Weekly' if is_auto else 'Custom',
                'period_type_display': 'Weekly' if is_auto else 'Custom',
                'filename': filename,
                'generated_at': generated_at,
                'date_range': date_range,
                'start_date': start_date,
                'end_date': end_date,
                'file_size': file_size,
                'exists': exists,
                'download_url': download_url,
                'generated_by': generated_by,
                'status': getattr(report, 'status', 'completed'),
                'notes': getattr(report, 'notes', '') or ''
            })
        
        return JsonResponse({
            'success': True,
            'reports': reports[:50]  # Limit to 50 most recent
        })
    
    except Exception as e:
        print(f"Error in business_manager_generated_reports_list: {e}")
        import traceback
        traceback.print_exc()
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)

@login_required
def business_manager_generate_auto_report(request):
    """Generate auto report for business manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from datetime import datetime, timezone as dt_timezone, timedelta
        import pytz
        from django.template.loader import render_to_string
        from django.core.files.base import ContentFile
        import os
        
        # Get Philippine timezone
        ph_tz = pytz.timezone('Asia/Manila')
        now = datetime.now(ph_tz)
        
        # Get filter parameters
        report_type = request.POST.get('report_type', 'approved_forms')
        period_type = request.POST.get('period_type', 'weekly')
        
        # Calculate date range based on period
        if period_type == 'daily':
            start_date = now.date()
            end_date = now.date()
        elif period_type == 'weekly':
            # Get Monday of current week
            days_since_monday = now.weekday()
            start_date = now.date() - timedelta(days=days_since_monday)
            end_date = start_date + timedelta(days=6)
        else:  # monthly
            start_date = now.replace(day=1).date()
            end_date = (now.replace(day=1) + timedelta(days=32)).replace(day=1) - timedelta(days=1)
        
        # Get activity logs for business manager actions
        activity_logs = BusinessManagerActivityLog.objects.filter(
            business_manager=request.user,
            created_at__date__range=[start_date, end_date]
        )
        
        # Filter by report type
        if report_type == 'approved_forms':
            activity_logs = activity_logs.filter(action_type='approve')
        elif report_type == 'disapproved_forms':
            activity_logs = activity_logs.filter(action_type='disapprove')
        elif report_type == 'pending_forms':
            activity_logs = activity_logs.filter(action_type='view')
        
        # Generate PDF report
        context = {
            'business_manager': request.user,
            'report_type': report_type,
            'period_type': period_type,
            'start_date': start_date,
            'end_date': end_date,
            'activity_logs': activity_logs,
            'total_count': activity_logs.count(),
        }
        
        # Render HTML template
        html_content = render_to_string('pdf/auto-generated-report.html', context)
        
        # Create file path with proper format
        filename = f"bm_{report_type}_report_{start_date}.html"
        file_path = os.path.join('business_manager_reports', filename)
        
        # Save report to database
        auto_report = AutoGeneratedReport.objects.create(
            report_type=report_type,
            period_type=period_type,
            start_date=start_date,
            end_date=end_date,
            file_path=file_path,
            created_by=request.user
        )
        
        # Save HTML content to file
        from django.conf import settings
        reports_dir = os.path.join(settings.MEDIA_ROOT, 'business_manager_reports')
        os.makedirs(reports_dir, exist_ok=True)
        
        full_file_path = os.path.join(reports_dir, filename)
        with open(full_file_path, 'w', encoding='utf-8') as f:
            f.write(html_content)
        
        return JsonResponse({
            'success': True,
            'message': 'Report generated successfully',
            'report_id': str(auto_report.id),
            'file_path': file_path
        })
        
    except Exception as e:
        print(f"Error generating auto report: {e}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_generate_manual_report(request):
    """Generate manual report for business manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        report_type = request.POST.get('report_type', '')
        period_type = request.POST.get('period_type', '')
        from_date = request.POST.get('from_date', '')
        to_date = request.POST.get('to_date', '')
        
        # Generate the report based on current filtered data
        activity_logs = BusinessManagerActivityLog.objects.filter(
            business_manager=request.user
        )
        
        # Apply filters
        if from_date:
            from datetime import datetime, timezone as dt_timezone
            start_date = datetime.strptime(from_date, '%Y-%m-%d').date()
            activity_logs = activity_logs.filter(created_at__date__gte=start_date)
        
        if to_date:
            from datetime import datetime, timezone as dt_timezone
            end_date = datetime.strptime(to_date, '%Y-%m-%d').date()
            activity_logs = activity_logs.filter(created_at__date__lte=end_date)
        
        if report_type:
            if report_type == 'approved_forms':
                activity_logs = activity_logs.filter(action_type='approve')
            elif report_type == 'disapproved_forms':
                activity_logs = activity_logs.filter(action_type='disapprove')
            elif report_type == 'pending_forms':
                activity_logs = activity_logs.filter(action_type='view')
        
        # Create the report record
        from datetime import datetime, timezone as dt_timezone
        from django.utils import timezone
        
        # Map report types to match model choices
        mapped_report_type = 'approved_forms' if report_type == 'approved_forms' else \
                           'disapproved_forms' if report_type == 'disapproved_forms' else \
                           'pending_forms' if report_type == 'pending_forms' else 'approved_forms'
        
        # Map period type to match model choices  
        mapped_period_type = 'daily' if period_type == 'day' else \
                           'weekly' if period_type == 'week' else \
                           'monthly' if period_type == 'month' else 'weekly'
        
        # Set default dates if not provided
        default_start = datetime.strptime(from_date, '%Y-%m-%d').date() if from_date else timezone.now().date()
        default_end = datetime.strptime(to_date, '%Y-%m-%d').date() if to_date else timezone.now().date()
        
        # Create context for template rendering (same as signatory)
        context = {
            'business_manager': request.user,
            'report_type': mapped_report_type,
            'period_type': mapped_period_type,
            'start_date': default_start,
            'end_date': default_end,
            'activity_logs': activity_logs,
            'total_count': activity_logs.count(),
        }
        
        # Generate HTML report content using same template as signatory
        from django.template.loader import render_to_string
        report_html = render_to_string('pdf/auto-generated-report.html', context)
        
        # Save to file
        import os
        from django.conf import settings
        
        timestamp = timezone.now().strftime('%Y%m%d_%H%M%S')
        report_dir = os.path.join(settings.MEDIA_ROOT, 'business_manager_reports', str(request.user.id))
        os.makedirs(report_dir, exist_ok=True)
        
        report_filename = f"{timestamp}.html"
        report_file_path = os.path.join(report_dir, report_filename)
        
        with open(report_file_path, 'w', encoding='utf-8') as f:
            f.write(report_html)
        
        # Create report record with relative path
        relative_path = f"business_manager_reports/{request.user.id}/{report_filename}"
        
        report = AutoGeneratedReport.objects.create(
            created_by=request.user,
            report_type=mapped_report_type,
            period_type=mapped_period_type,
            start_date=default_start,
            end_date=default_end,
            file_path=relative_path
        )
        
        return JsonResponse({
            'success': True,
            'message': f'Report generated successfully with {activity_logs.count()} records'
        })
    
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)

@login_required
def business_manager_download_report(request, report_id):
    """Download generated report for business manager"""
    if not is_business_manager(request.user):
        return redirect('login')
    
    try:
        # Try to find in AutoGeneratedReport first
        try:
            report = AutoGeneratedReport.objects.get(
                id=report_id,
                created_by=request.user
            )
            file_path = report.file_path
            is_auto_report = True
        except AutoGeneratedReport.DoesNotExist:
            # Try to find in GeneratedReport (manual reports)
            report = GeneratedReport.objects.get(
                id=report_id,
                generated_by=request.user
            )
            file_path = report.file.name if hasattr(report, 'file') and report.file else None
            is_auto_report = False
        
        if not file_path:
            return HttpResponse("Report file path not found", status=404)
        
        # Check if file exists
        from django.conf import settings
        import os
        full_file_path = os.path.join(settings.MEDIA_ROOT, file_path)
        
        if os.path.exists(full_file_path):
            if is_auto_report:
                # Auto-generated reports are HTML files
                try:
                    with open(full_file_path, 'r', encoding='utf-8') as f:
                        response = HttpResponse(f.read(), content_type='text/html')
                        response['Content-Disposition'] = f'inline; filename="bm_report_{report_id}.html"'
                        return response
                except UnicodeDecodeError:
                    return HttpResponse("Unable to read report file", status=500)
            else:
                # Manual reports are PDF files
                try:
                    with open(full_file_path, 'rb') as f:
                        response = HttpResponse(f.read(), content_type='application/pdf')
                        response['Content-Disposition'] = f'inline; filename="bm_report_{report_id}.pdf"'
                        return response
                except Exception as e:
                    return HttpResponse(f"Error reading PDF file: {str(e)}", status=500)
        else:
            return HttpResponse("Report file not found", status=404)
    
    except (AutoGeneratedReport.DoesNotExist, GeneratedReport.DoesNotExist):
        return HttpResponse("Report not found", status=404)
    except Exception as e:
        return HttpResponse(f"Error: {str(e)}", status=500)

def generate_business_manager_report_html(activity_logs, report, user):
    """Generate HTML content for business manager report"""
    html_content = f"""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Business Manager Report</title>
        <style>
            body {{ font-family: Arial, sans-serif; margin: 20px; }}
            .header {{ text-align: center; margin-bottom: 30px; }}
            .report-info {{ margin-bottom: 20px; }}
            table {{ width: 100%; border-collapse: collapse; }}
            th, td {{ border: 1px solid #ddd; padding: 8px; text-align: left; }}
            th {{ background-color: #f2f2f2; }}
            .text-center {{ text-align: center; }}
        </style>
    </head>
    <body>
        <div class="header">
            <h1>Business Manager Activity Report</h1>
            <h3>Generated by: {user.full_name}</h3>
        </div>
        <div class="report-info">
            <p><strong>Report Type:</strong> {report.get_report_type_display()}</p>
            <p><strong>Period:</strong> {report.get_period_type_display()}</p>
            <p><strong>Date Range:</strong> {report.start_date or 'N/A'} to {report.end_date or 'N/A'}</p>
            <p><strong>Generated:</strong> {report.generated_at.strftime('%Y-%m-%d %H:%M:%S')}</p>
            <p><strong>Total Records:</strong> {activity_logs.count()}</p>
        </div>
        <table>
            <thead>
                <tr>
                    <th>User</th>
                    <th>Role</th>
                    <th>Action</th>
                    <th>Description</th>
                    <th>Date</th>
                    <th>Time</th>
                    <th>IP Address</th>
                </tr>
            </thead>
            <tbody>
    """
    
    for log in activity_logs:
        html_content += f"""
                <tr>
                    <td>{user.full_name}</td>
                    <td>Business Manager</td>
                    <td>{log.action_type or 'N/A'}</td>
                    <td>{f"{log.action_type.title()} {log.form_type} form for {log.student_name}"}</td>
                    <td>{log.created_at.strftime('%Y-%m-%d')}</td>
                    <td>{log.created_at.strftime('%H:%M:%S')}</td>
                    <td>{getattr(log, 'ip_address', 'N/A')}</td>
                </tr>
        """
    
    html_content += """
            </tbody>
        </table>
    </body>
    </html>
    """
    
    return html_content

@login_required
def business_manager_reports_csv_export(request):
    """CSV export endpoint for business manager reports data"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        import csv
        from django.http import HttpResponse
        from datetime import datetime, timezone as dt_timezone, timedelta
        
        # Get same parameters as the main API
        from_date = request.GET.get('from_date', '')
        to_date = request.GET.get('to_date', '')
        form_status = request.GET.get('form_status', '')
        period_type = request.GET.get('period_type', '')
        search = request.GET.get('search', '').strip()
        
        # Get activity logs with same filtering as main API
        activity_logs = BusinessManagerActivityLog.objects.filter(
            business_manager=request.user
        ).order_by('-created_at')
        
        # Apply date filters
        if from_date:
            try:
                from_date_obj = datetime.strptime(from_date, '%Y-%m-%d').date()
                activity_logs = activity_logs.filter(created_at__date__gte=from_date_obj)
            except ValueError:
                pass
        
        if to_date:
            try:
                to_date_obj = datetime.strptime(to_date, '%Y-%m-%d').date()
                activity_logs = activity_logs.filter(created_at__date__lte=to_date_obj)
            except ValueError:
                pass
        
        # Apply period filter
        if period_type:
            today = timezone.now().date()
            if period_type == 'day':
                activity_logs = activity_logs.filter(created_at__date=today)
            elif period_type == 'week':
                week_ago = today - timedelta(days=7)
                activity_logs = activity_logs.filter(created_at__date__gte=week_ago)
            elif period_type == 'month':
                month_ago = today - timedelta(days=30)
                activity_logs = activity_logs.filter(created_at__date__gte=month_ago)
        
        # Apply form status filter
        if form_status:
            if form_status == 'approve':
                activity_logs = activity_logs.filter(action_type='approve')
            elif form_status == 'disapprove':
                activity_logs = activity_logs.filter(action_type='disapprove')
            elif form_status == 'view':
                activity_logs = activity_logs.filter(action_type='view')
        
        # Apply search filter
        if search:
            from django.db.models import Q
            activity_logs = activity_logs.filter(
                Q(action_type__icontains=search) |
                Q(student_name__icontains=search)
            )
        
        # Create CSV response
        response = HttpResponse(content_type='text/csv')
        response['Content-Disposition'] = f'attachment; filename="business_manager_reports_{timezone.now().strftime("%Y%m%d_%H%M%S")}.csv"'
        
        writer = csv.writer(response)
        
        # Write header
        writer.writerow([
            'Date',
            'Time', 
            'Action',
            'Student Name',
            'IP Address'
        ])
        
        # Write data
        for log in activity_logs:
            writer.writerow([
                log.created_at.strftime('%Y-%m-%d'),
                log.created_at.strftime('%H:%M:%S'),
                log.action_type or 'N/A',
                log.student_name or 'N/A',
                log.ip_address or 'N/A'
            ])
        
        return response
        
    except Exception as e:
        print(f"Error in CSV export: {e}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_profile(request):
    """Business Manager Profile - MIRRORS REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        messages.error(request, "Access denied. You don't have permission to view this page.")
        return redirect('login')
    
    # Get or create business manager profile
    from landing.models import BusinessManagerProfile
    bm_profile, created = BusinessManagerProfile.objects.get_or_create(
        user=request.user,
        defaults={'position': 'Business Manager'}
    )
    
    # Split full name into first and last name
    full_name_parts = request.user.full_name.split(' ', 1)
    first_name = full_name_parts[0] if full_name_parts else ''
    last_name = full_name_parts[1] if len(full_name_parts) > 1 else ''
    
    context = {
        'user': request.user,
        'business_manager_profile': bm_profile,
        'first_name': first_name,
        'last_name': last_name,
    }
    
    return render(request, 'BUSINESSMPROFILE.html', context)

@login_required
def business_manager_profile_data_api(request):
    """API endpoint to get business manager profile data - MIRRORS REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from landing.models import BusinessManagerProfile
        bm_profile, created = BusinessManagerProfile.objects.get_or_create(
            user=request.user,
            defaults={'position': 'Business Manager'}
        )
        
        # Split full name into first and last name
        full_name_parts = request.user.full_name.split(' ', 1)
        first_name = full_name_parts[0] if full_name_parts else ''
        last_name = full_name_parts[1] if len(full_name_parts) > 1 else ''
        
        profile_data = {
            'first_name': first_name,
            'last_name': last_name,
            'birthdate': bm_profile.birthdate.strftime('%Y-%m-%d') if bm_profile.birthdate else None,
            'gender': bm_profile.gender,
            'position': bm_profile.position,
            'department': bm_profile.department,
            'address': bm_profile.address,
            'email': request.user.email,
            'contact_number': request.user.contact_number,
            'office_location': bm_profile.office_location,
            'office_hours': bm_profile.office_hours,
            'bio': bm_profile.bio,
            'profile_picture_url': bm_profile.profile_picture_url
        }
        
        return JsonResponse({
            'success': True,
            'profile': profile_data
        })
        
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_profile_update_api(request):
    """API endpoint to update business manager profile - MIRRORS REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            import json
            data = json.loads(request.body)
            
            from landing.models import BusinessManagerProfile
            bm_profile, created = BusinessManagerProfile.objects.get_or_create(
                user=request.user,
                defaults={'position': 'Business Manager'}
            )
            
            # Update user fields
            if data.get('firstName') and data.get('lastName'):
                request.user.full_name = f"{data['firstName']} {data['lastName']}"
            
            if data.get('email'):
                request.user.email = data['email']
            
            if data.get('contactNumber'):
                request.user.contact_number = data['contactNumber']
            
            request.user.save()
            
            # Update business manager profile fields
            if data.get('birthdate'):
                bm_profile.birthdate = data['birthdate']
            
            if data.get('gender'):
                bm_profile.gender = data['gender']
            
            if data.get('position'):
                bm_profile.position = data['position']
            
            if data.get('department'):
                bm_profile.department = data['department']
            
            if data.get('address'):
                bm_profile.address = data['address']
            
            if data.get('officeLocation'):
                bm_profile.office_location = data['officeLocation']
            
            if data.get('officeHours'):
                bm_profile.office_hours = data['officeHours']
            
            if data.get('bio'):
                bm_profile.bio = data['bio']
            
            bm_profile.save()
            
            return JsonResponse({
                'success': True,
                'message': 'Profile updated successfully'
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def business_manager_profile_change_password_api(request):
    """API endpoint to change business manager password - MIRRORS REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            import json
            data = json.loads(request.body)
            
            old_password = data.get('old_password')
            new_password = data.get('new_password')
            
            if not old_password or not new_password:
                return JsonResponse({'error': 'Both old and new passwords are required'}, status=400)
            
            # Verify old password
            if not request.user.check_password(old_password):
                return JsonResponse({'error': 'Current password is incorrect'}, status=400)
            
            # Validate new password
            if len(new_password) < 8:
                return JsonResponse({'error': 'New password must be at least 8 characters long'}, status=400)
            
            # Set new password
            request.user.set_password(new_password)
            request.user.save()
            
            return JsonResponse({
                'success': True,
                'message': 'Password changed successfully'
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def business_manager_profile_upload_picture_api(request):
    """API endpoint to upload business manager profile picture - MIRRORS REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            from landing.models import BusinessManagerProfile
            bm_profile, created = BusinessManagerProfile.objects.get_or_create(
                user=request.user,
                defaults={'position': 'Business Manager'}
            )
            
            if 'profile_picture' not in request.FILES:
                return JsonResponse({'error': 'No image file provided'}, status=400)
            
            profile_picture = request.FILES['profile_picture']
            
            # Validate file type
            if not profile_picture.content_type.startswith('image/'):
                return JsonResponse({'error': 'Please upload a valid image file'}, status=400)
            
            # Validate file size (max 5MB)
            if profile_picture.size > 5 * 1024 * 1024:
                return JsonResponse({'error': 'Image size should be less than 5MB'}, status=400)
            
            # Save the image
            bm_profile.profile_picture = profile_picture
            bm_profile.save()
            
            return JsonResponse({
                'success': True,
                'message': 'Profile picture uploaded successfully',
                'profile_picture_url': bm_profile.profile_picture_url
            })
            
        except Exception as e:
            return JsonResponse({'error': str(e)}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def business_manager_messages(request):
    """Business Manager Messages"""
    if not is_business_manager(request.user):
        return redirect('login')
    return render(request, 'BUSINESSMMESSAGES.html')

@login_required
def business_manager_dashboard_data_api(request):
    """API endpoint to get new clearance forms data for business manager dashboard"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        print(f"Business Manager Dashboard API called by user: {request.user.username} (type: {request.user.user_type})")
        
        # Get query parameters for filtering
        purpose_filter = request.GET.get('purpose', '')
        course_filter = request.GET.get('course', '')
        year_filter = request.GET.get('year', '')
        section_filter = request.GET.get('section', '')
        search_query = request.GET.get('search', '')
        
        print(f"Filters: purpose={purpose_filter}, course={course_filter}, year={year_filter}, section={section_filter}, search={search_query}")
        
        # Get new clearance forms for business manager (not seen by business manager)
        new_clearances = ClearanceSignatory.objects.filter(
            signatory__signatory_profile__signatory_type='business_manager',
            status='pending',
            seen_by_signatory=False
        ).select_related(
            'clearance__student__profile',
            'clearance'
        )
        
        print(f"Found {new_clearances.count()} pending clearances for business manager")
        
        # Apply filters
        if purpose_filter:
            new_clearances = new_clearances.filter(clearance__clearance_type=purpose_filter.lower())
        
        if course_filter:
            new_clearances = new_clearances.filter(clearance__student__profile__program__icontains=course_filter)
        
        if year_filter:
            new_clearances = new_clearances.filter(clearance__student__profile__year_level=year_filter)
        
        if section_filter:
            new_clearances = new_clearances.filter(clearance__section__icontains=section_filter)
        
        if search_query:
            new_clearances = new_clearances.filter(
                Q(clearance__student__full_name__icontains=search_query) |
                Q(clearance__student__profile__student_number__icontains=search_query) |
                Q(clearance__student__profile__program__icontains=search_query)
            )
        
        # Prepare data for response
        clearance_data = []
        for clearance_signatory in new_clearances:
            try:
                student = clearance_signatory.clearance.student
                student_profile = getattr(student, 'profile', None)
                
                clearance_data.append({
                'id': str(clearance_signatory.id),
                'clearance_id': str(clearance_signatory.clearance.id),
                'student_name': student.full_name,
                'student_number': student_profile.student_number if student_profile else 'N/A',
                'course': student_profile.program if student_profile else 'N/A',
                'year': student_profile.year_level if student_profile else 'N/A',
                'section': clearance_signatory.clearance.section or 'N/A',
                'purpose': clearance_signatory.clearance.clearance_type.title(),
                'date_submitted': clearance_signatory.clearance.submitted_at.strftime('%B %d, %Y'),
                'semester': clearance_signatory.clearance.semester,
                'academic_year': clearance_signatory.clearance.academic_year or 'N/A',
            })
            except Exception as e:
                print(f"Error processing clearance {clearance_signatory.id}: {e}")
                continue
        
        # Get count of new clearances
        new_clearances_count = new_clearances.count()
        
        return JsonResponse({
            'success': True,
            'data': clearance_data,
            'count': new_clearances_count,
            'message': f'There are {new_clearances_count} new clearance form{"s" if new_clearances_count != 1 else ""} waiting for approval'
        })
        
    except Exception as e:
        print(f"Error in business_manager_dashboard_data_api: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)

@login_required
def business_manager_clearance_data_api(request):
    """API endpoint to get clearance data for business manager (mirrors registrar functionality)"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        # Get all clearance forms - business manager should see all clearances (same as registrar)
        clearances = ClearanceForm.objects.all().select_related(
            'student__profile'
        ).prefetch_related('signatories')
        
        # Get query parameters for filtering and sorting
        course_filter = request.GET.get('course', '')
        year_filter = request.GET.get('year', '')
        section_filter = request.GET.get('section', '')
        status_filter = request.GET.get('status', '')
        search_query = request.GET.get('search', '')
        sort_by = request.GET.get('sort', 'created_at')
        sort_order = request.GET.get('order', 'desc')
        
        # Apply filters (same as registrar)
        if course_filter and course_filter not in ['Filter by Course', '']:
            clearances = clearances.filter(student__profile__program__icontains=course_filter)
        
        if year_filter and year_filter not in ['Filter by Year', '']:
            clearances = clearances.filter(student__profile__year_level=year_filter)
        
        if section_filter and section_filter not in ['Filter by Section', '']:
            clearances = clearances.filter(section__icontains=section_filter)
        
        if search_query:
            clearances = clearances.filter(
                Q(student__full_name__icontains=search_query) |
                Q(student__profile__student_number__icontains=search_query) |
                Q(student__profile__program__icontains=search_query)
            )
        
        # Dynamic sorting
        valid_sort_fields = {
            'created_at': 'submitted_at',  # Map created_at to submitted_at since created_at doesn't exist
            'submitted_at': 'submitted_at',
            'student_name': 'student__full_name',
            'student_number': 'student__profile__student_number',
            'program': 'student__profile__program',
            'year_level': 'student__profile__year_level',
            'status': 'status'
        }
        
        # Default to submitted_at if invalid sort field
        sort_field = valid_sort_fields.get(sort_by, 'submitted_at')
        
        # Apply sorting direction
        if sort_order.lower() == 'asc':
            clearances = clearances.order_by(sort_field)
        else:
            clearances = clearances.order_by(f'-{sort_field}')
        
        # Prepare data for response (same format as registrar)
        clearance_data = []
        for clearance in clearances:
            try:
                student = clearance.student
                student_profile = getattr(student, 'profile', None)
                
                # Get ALL signatory statuses for this clearance (same as registrar)
                signatory_statuses = {}
                for signatory_record in clearance.signatories.all():
                    try:
                        if hasattr(signatory_record.signatory, 'signatory_profile') and signatory_record.signatory.signatory_profile:
                            signatory_type = signatory_record.signatory.signatory_profile.signatory_type
                        else:
                            # Handle admin/registrar users
                            if signatory_record.signatory.user_type in ['admin', 'registrar']:
                                signatory_type = 'registrar'
                            else:
                                continue
                        
                        status_info = {
                            'status': signatory_record.status,
                            'timestamp': signatory_record.updated_at.strftime('%B %d, %Y %I:%M %p') if signatory_record.updated_at else None,
                            'comment': signatory_record.comment or ''
                        }
                        
                        signatory_statuses[signatory_type] = status_info
                    except Exception as e:
                        print(f"Error processing signatory record: {e}")
                        continue
                
                # Calculate overall clearance status based on signatory approvals
                # Check if all signatories have approved
                all_approved = True
                required_signatories = ['dorm_supervisor', 'canteen_concessionaire', 'library_director', 
                                      'scholarship_director', 'it_director', 'student_affairs', 
                                      'cashier', 'business_manager', 'registrar', 'academic_dean']
                
                for req_type in required_signatories:
                    if req_type not in signatory_statuses or signatory_statuses[req_type]['status'] != 'approved':
                        all_approved = False
                        break
                
                overall_status = 'completed' if all_approved else 'pending'
                
                # Apply status filter if specified
                if status_filter and status_filter not in ['Filter by Status', '']:
                    if status_filter.lower() == 'cleared' and overall_status != 'completed':
                        continue
                    elif status_filter.lower() == 'pending' and overall_status != 'pending':
                        continue
                    elif status_filter.lower() == 'disapproved' and not any(
                        status.get('status') == 'disapproved' for status in signatory_statuses.values()
                    ):
                        continue
                
                clearance_data.append({
                    'id': str(clearance.id),
                    'student_name': student.full_name,
                    'student_number': student_profile.student_number if student_profile else 'N/A',
                    'course': student_profile.program if student_profile else 'N/A',
                    'year': student_profile.year_level if student_profile else 'N/A',
                    'section': clearance.section or 'N/A',
                    'date_submitted': clearance.submitted_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%B %d, %Y'),
                    'signatory_statuses': signatory_statuses,
                    'overall_status': overall_status
                })
            except Exception as e:
                print(f"Error processing clearance {clearance.id}: {e}")
                continue
        
        return JsonResponse({
            'success': True,
            'data': clearance_data
        })
        
    except Exception as e:
        print(f"Error in business_manager_clearance_data_api: {e}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_clearance_filter_options(request):
    """Get filter options for business manager clearance"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        # Get unique values for filters
        courses = StudentProfile.objects.values_list('program', flat=True).distinct()
        years = StudentProfile.objects.values_list('year_level', flat=True).distinct()
        sections = ClearanceForm.objects.values_list('section', flat=True).distinct()
        
        return JsonResponse({
            'courses': list(courses),
            'years': list(years),
            'sections': list(sections)
        })
        
    except Exception as e:
        print(f"Error in business_manager_clearance_filter_options: {e}")
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def business_manager_mark_clearance_seen(request):
    """API endpoint to mark clearance forms as seen by business manager - MIRROR SIGNATORY FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        
        # Check if it's multiple clearances
        clearance_signatory_ids_json = request.POST.get('clearance_signatory_ids')
        clearance_signatory_id = request.POST.get('clearance_signatory_id')
        
        if clearance_signatory_ids_json:
            # Handle multiple clearances (bulk marking)
            try:
                clearance_signatory_ids = json.loads(clearance_signatory_ids_json)
                
                # Find business manager signatory records for these clearances  
                updated_count = ClearanceSignatory.objects.filter(
                    id__in=clearance_signatory_ids,
                    signatory__signatory_profile__signatory_type='business_manager'
                ).update(seen_by_signatory=True)
                
                return JsonResponse({
                    'success': True,
                    'message': f'{updated_count} clearance forms marked as seen'
                })
                
            except json.JSONDecodeError:
                return JsonResponse({'error': 'Invalid JSON format for clearance signatory IDs'}, status=400)
                
        elif clearance_signatory_id:
            # Handle single clearance (manual marking)
            clearance_signatory = ClearanceSignatory.objects.get(
                id=clearance_signatory_id,
                signatory__signatory_profile__signatory_type='business_manager'
            )
            
            clearance_signatory.seen_by_signatory = True
            clearance_signatory.save()
            
            return JsonResponse({
                'success': True,
                'message': 'Clearance form marked as seen'
            })
        else:
            return JsonResponse({'error': 'Either clearance_signatory_id or clearance_signatory_ids is required'}, status=400)
        
    except ClearanceSignatory.DoesNotExist:
        return JsonResponse({'error': 'Clearance form not found'}, status=404)
    except Exception as e:
        print(f"Error in business_manager_mark_clearance_seen: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)

@login_required
def business_manager_get_clearance_details(request, clearance_id):
    """API endpoint to get detailed clearance data for business manager viewing - MIRROR SIGNATORY FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        # Get the clearance form
        clearance = ClearanceForm.objects.select_related(
            'student__profile'
        ).get(id=clearance_id)
        
        # Get all signatory statuses for this clearance
        signatory_statuses = ClearanceSignatory.objects.filter(
            clearance=clearance
        ).select_related('signatory__signatory_profile')
        
        # Create a mapping of signatory types to their statuses
        signatory_data = {}
        print(f"Processing {signatory_statuses.count()} signatory records for clearance {clearance_id}")
        
        # Group signatories by type to handle duplicates
        signatory_groups = {}
        for signatory_record in signatory_statuses:
            # Safely get signatory type
            try:
                signatory_type = signatory_record.signatory.signatory_profile.signatory_type
                print(f"Found signatory type: {signatory_type} for user: {signatory_record.signatory.username}")
                # Map the signatory type to the correct key used in the frontend
                signatory_type_mapping = {
                    'library_director': 'director_of_library_&_information',
                    'scholarship_director': 'director_of_scholarship',
                    'it_director': 'information_technology',
                    'student_affairs': 'dean_of_student_affairs',
                    'registrar': 'registrar'
                }
                mapped_type = signatory_type_mapping.get(signatory_type, signatory_type)
                print(f"Mapped type: {mapped_type}")
            except Exception as e:
                print(f"Error processing signatory record: {e}")
                # If signatory_profile doesn't exist, this might be a registrar (admin) user
                if signatory_record.signatory.user_type in ['admin', 'registrar']:
                    mapped_type = 'registrar'
                    print(f"User is admin/registrar, using mapped_type: {mapped_type}")
                else:
                    continue
                    
            # Store signatory data with most recent status
            if mapped_type not in signatory_groups or signatory_record.updated_at > signatory_groups[mapped_type]['updated_at']:
                signatory_groups[mapped_type] = {
                    'status': signatory_record.status,
                    'timestamp': signatory_record.updated_at,
                    'comment': signatory_record.comment or signatory_record.remarks or '',
                    'signatory_name': signatory_record.signatory.full_name,
                    'updated_at': signatory_record.updated_at
                }
        
        # Format the data for the response
        for signatory_type, data in signatory_groups.items():
            signatory_data[signatory_type] = {
                'status': data['status'],
                'timestamp': data['timestamp'].strftime('%B %d, %Y %I:%M %p') if data['timestamp'] else None,
                'comment': data['comment'],
                'signatory_name': data['signatory_name']
            }
        
        # Prepare the response data
        student = clearance.student
        student_profile = getattr(student, 'profile', None)
        
        response_data = {
            'id': str(clearance.id),
            'student_name': student.full_name,
            'student_number': student_profile.student_number if student_profile else 'N/A',
            'course': student_profile.program if student_profile else 'N/A',
            'year': student_profile.year_level if student_profile else 'N/A',
            'section': clearance.section or 'N/A',
            'purpose': clearance.clearance_type.title(),
            'semester': clearance.semester,
            'academic_year': clearance.academic_year or 'N/A',
            'date_submitted': clearance.submitted_at.strftime('%B %d, %Y'),
            'signatory_statuses': signatory_data,
            'overall_status': 'completed' if len([s for s in signatory_data.values() if s['status'] == 'approved']) >= 10 else 'pending'
        }
        
        return JsonResponse({
            'success': True,
            'data': response_data
        })
        
    except ClearanceForm.DoesNotExist:
        return JsonResponse({'error': 'Clearance form not found'}, status=404)
    except Exception as e:
        print(f"Error in business_manager_get_clearance_details: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)

@login_required
def business_manager_calendar_events_api(request):
    """API endpoint to get calendar events for business manager - MIRROR SIGNATORY FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        from landing.models import CalendarEvent
        from datetime import datetime, timezone as dt_timezone, date, timedelta
        
        # Get events for the next 7 days
        today = date.today()
        next_week = today + timedelta(days=7)
        
        calendar_events = CalendarEvent.objects.filter(
            start_date__gte=today,
            start_date__lte=next_week
        ).order_by('start_date', 'start_time')[:10]
        
        events_data = []
        for event in calendar_events:
            events_data.append({
                'id': str(event.id),
                'title': event.title,
                'description': event.description or '',
                'time': event.display_time,
                'color': event.color,
                'date': event.start_date.strftime('%Y-%m-%d'),
                'event_type': event.event_type
            })
        
        return JsonResponse({
            'success': True,
            'events': events_data
        })
        
    except Exception as e:
        print(f"Error in business_manager_calendar_events_api: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)

@login_required
def business_manager_add_calendar_event(request):
    """API endpoint to add calendar event for business manager - MIRROR SIGNATORY FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        from landing.models import CalendarEvent
        from datetime import datetime, timezone as dt_timezone
        
        # Get form data
        title = request.POST.get('title')
        description = request.POST.get('description', '')
        start_date = request.POST.get('start_date')
        start_time = request.POST.get('start_time', '')
        end_date = request.POST.get('end_date', '')
        end_time = request.POST.get('end_time', '')
        event_type = request.POST.get('event_type', 'event')
        color = request.POST.get('color', 'blue')
        is_all_day = request.POST.get('is_all_day') == 'on'
        
        if not title or not start_date:
            return JsonResponse({'error': 'Title and start date are required'}, status=400)
        
        # Create the event
        event = CalendarEvent.objects.create(
            title=title,
            description=description,
            start_date=datetime.strptime(start_date, '%Y-%m-%d').date(),
            start_time=datetime.strptime(start_time, '%H:%M').time() if start_time else None,
            end_date=datetime.strptime(end_date, '%Y-%m-%d').date() if end_date else None,
            end_time=datetime.strptime(end_time, '%H:%M').time() if end_time else None,
            event_type=event_type,
            color=color,
            is_all_day=is_all_day,
            created_by=request.user
        )
        
        # Create Google Calendar URL
        google_calendar_url = f"https://calendar.google.com/calendar/render?action=TEMPLATE&text={title}"
        if description:
            google_calendar_url += f"&details={description}"
        google_calendar_url += f"&dates={start_date.replace('-', '')}"
        if start_time:
            google_calendar_url += f"T{start_time.replace(':', '')}00"
        google_calendar_url += f"/{end_date.replace('-', '') if end_date else start_date.replace('-', '')}"
        if end_time:
            google_calendar_url += f"T{end_time.replace(':', '')}00"
        
        return JsonResponse({
            'success': True,
            'event_id': str(event.id),
            'google_calendar_url': google_calendar_url,
            'message': 'Event added successfully! Click the link to add it to Google Calendar.'
        })
        
    except Exception as e:
        print(f"Error in business_manager_add_calendar_event: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)

@login_required
def business_manager_approve_clearance(request):
    """API endpoint to approve clearance for business manager - MIRROR SIGNATORY FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        clearance_id = data.get('clearance_id')
        pin = data.get('pin')
        comment = data.get('comment', '')
        
        if not clearance_id:
            return JsonResponse({'error': 'Clearance ID is required'}, status=400)
        
        if not pin:
            return JsonResponse({'error': 'PIN is required'}, status=400)
        
        # Verify PIN
        if not verify_bm_pin_helper(request.user, pin):
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Use safe signatory record handler
        clearance_signatory = get_or_update_signatory_record(
            clearance_id=clearance_id,
            signatory=request.user,
            status='approved',
            comment=comment,
            ip_address=get_client_ip(request)
        )
        
        # Send approval notification to student
        try:
            from landing.notification_service import NotificationService
            NotificationService.notify_form_approval(
                form_instance=clearance_signatory.clearance,
                form_type='clearance',
                signatory_user=request.user,
                remarks=comment or ''
            )
        except Exception as e:
            print(f"Error sending business manager approval notification: {e}")
        
        # Check if all signatories approved and update clearance status
        all_signatories = ClearanceSignatory.objects.filter(clearance_id=clearance_id)
        all_approved = all_signatories.exists() and all(s.status == 'approved' for s in all_signatories)
        if all_approved:
            clearance_form = clearance_signatory.clearance
            clearance_form.status = 'approved'
            clearance_form.finalized_at = timezone.now()
            clearance_form.save()
        
        # Log activity
        BusinessManagerActivityLog.objects.create(
            business_manager=request.user,
            action_type='approve',
            form_type='clearance',
            form_id=clearance_id,
            student_name=clearance_signatory.clearance.student.full_name,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Clearance approved successfully'
        })
        
    except ClearanceForm.DoesNotExist:
        return JsonResponse({'error': 'Clearance form not found'}, status=404)
    except Exception as e:
        import traceback
        print(f"Error in business_manager_approve_clearance: {e}")
        print(f"Full traceback: {traceback.format_exc()}")
        return JsonResponse({'error': f'Internal server error: {str(e)}'}, status=500)

@login_required
def business_manager_disapprove_clearance(request):
    """API endpoint to disapprove clearance for business manager - MIRROR SIGNATORY FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        clearance_id = data.get('clearance_id')
        pin = data.get('pin')
        reasons = data.get('reasons', [])
        comment = data.get('comment', '')
        appointment_date = data.get('appointment_date', '')
        
        if not clearance_id:
            return JsonResponse({'error': 'Clearance ID is required'}, status=400)
        
        if not pin:
            return JsonResponse({'error': 'PIN is required'}, status=400)
            
        if not reasons:
            return JsonResponse({'error': 'At least one reason must be selected'}, status=400)
        
        # Verify PIN
        if not verify_bm_pin_helper(request.user, pin):
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Create remarks with reasons and appointment
        remarks_parts = [f"Reasons: {', '.join(reasons)}"]
        if comment:
            remarks_parts.append(f"Comment: {comment}")
        if appointment_date:
            remarks_parts.append(f"Appointment scheduled: {appointment_date}")
        
        final_remarks = "\n".join(remarks_parts)
        
        # Use safe signatory record handler
        clearance_signatory = get_or_update_signatory_record(
            clearance_id=clearance_id,
            signatory=request.user,
            status='disapproved',
            comment=final_remarks,
            ip_address=get_client_ip(request)
        )
        
        # Send notification to student
        try:
            from landing.notification_service import NotificationService
            notification_service = NotificationService()
            notification_service.handle_form_disapproval(
                form=clearance_signatory.clearance,
                form_type='clearance',
                disapproval_reasons=reasons,
                settlement_instructions=comment,
                appointment_date=appointment_date
            )
        except Exception as e:
            print(f"Error sending business manager disapproval notification: {e}")
            import traceback
            print(f"Full traceback: {traceback.format_exc()}")
        
        # Log activity
        BusinessManagerActivityLog.objects.create(
            business_manager=request.user,
            action_type='disapprove',
            form_type='clearance',
            form_id=clearance_id,
            student_name=clearance_signatory.clearance.student.full_name,
            ip_address=get_client_ip(request),
            user_agent=request.META.get('HTTP_USER_AGENT', '')
        )
        
        return JsonResponse({
            'success': True,
            'message': 'Clearance disapproved successfully'
        })
        
    except ClearanceForm.DoesNotExist:
        return JsonResponse({'error': 'Clearance form not found'}, status=404)
    except Exception as e:
        print(f"Error in business_manager_disapprove_clearance: {e}")
        return JsonResponse({'error': 'Internal server error'}, status=500)

def business_manager_delete_clearance(request, clearance_id):
    """Delete a single clearance form"""
    if request.method != 'DELETE':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        clearance = ClearanceForm.objects.get(id=clearance_id)
        clearance.delete()
        return JsonResponse({'success': True, 'message': 'Clearance deleted successfully'})
    except ClearanceForm.DoesNotExist:
        return JsonResponse({'error': 'Clearance form not found'}, status=404)
    except Exception as e:
        print(f"Error deleting clearance: {e}")
        return JsonResponse({'error': 'Failed to delete clearance'}, status=500)

def business_manager_bulk_delete_clearance(request):
    """Bulk delete clearance forms"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        clearance_ids = data.get('clearance_ids', [])
        
        if not clearance_ids:
            return JsonResponse({'error': 'No clearance IDs provided'}, status=400)
        
        deleted_count = ClearanceForm.objects.filter(id__in=clearance_ids).delete()[0]
        
        return JsonResponse({
            'success': True,
            'message': f'Successfully deleted {deleted_count} clearance(s)',
            'deleted_count': deleted_count
        })
    except Exception as e:
        print(f"Error in bulk delete: {e}")
        return JsonResponse({'error': 'Failed to delete clearances'}, status=500)

@login_required
def business_manager_bulk_approve_clearance(request):
    """Bulk approve multiple clearance forms for Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            clearance_ids = data.get('clearance_ids', [])
            pin = data.get('pin')
            comment = data.get('comment', '')
            
            # Verify PIN first
            if not verify_bm_pin_helper(request.user, pin):
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            if not clearance_ids:
                return JsonResponse({'error': 'No clearance forms provided'}, status=400)
            
            clearance_forms = ClearanceForm.objects.filter(id__in=clearance_ids)
            
            if not clearance_forms.exists():
                return JsonResponse({'error': 'No clearance forms found'}, status=404)
            
            # Process bulk approval
            approved_count = 0
            student_names = []
            
            for clearance in clearance_forms:
                try:
                    # Create or update business manager signatory
                    signatory, created = ClearanceSignatory.objects.get_or_create(
                        clearance=clearance,
                        signatory=request.user,
                        role='business_manager',
                        defaults={
                            'status': 'approved',
                            'remarks': comment,
                            'ip_address': get_client_ip(request)
                        }
                    )
                    
                    if not created:
                        signatory.status = 'approved'
                        signatory.remarks = comment
                        signatory.ip_address = get_client_ip(request)
                        signatory.save()
                    
                    approved_count += 1
                    student_names.append(clearance.student.get_full_name())
                    
                    # Send individual notification to student
                    Notification.objects.create(
                        user=clearance.student,
                        title="Clearance Approved",
                        message=f"Your clearance form has been approved by the Business Manager.",
                        notification_type='success'
                    )
                    
                    # Log activity
                    ActivityLog.objects.create(
                        user=request.user,
                        action='BULK_APPROVE_CLEARANCE',
                        description=f'Bulk approved clearance for {clearance.student.get_full_name()}',
                        ip_address=get_client_ip(request)
                    )
                    
                except Exception as e:
                    print(f"Error approving clearance {clearance.id}: {e}")
                    continue
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully approved {approved_count} clearance(s)',
                'approved_count': approved_count,
                'student_names': student_names
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON data'}, status=400)
        except Exception as e:
            print(f"Bulk approve error: {e}")
            return JsonResponse({'error': 'Failed to approve clearances'}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def business_manager_bulk_disapprove_clearance(request):
    """Bulk disapprove multiple clearance forms for Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            clearance_ids = data.get('clearance_ids', [])
            pin = data.get('pin')
            reason = data.get('reason', 'Bulk disapproval')
            comment = data.get('comment', '')
            appointment_date = data.get('appointment_date')
            
            # Verify PIN first
            if not verify_bm_pin_helper(request.user, pin):
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            if not clearance_ids:
                return JsonResponse({'error': 'No clearance forms provided'}, status=400)
            
            clearance_forms = ClearanceForm.objects.filter(id__in=clearance_ids)
            
            if not clearance_forms.exists():
                return JsonResponse({'error': 'No clearance forms found'}, status=404)
            
            # Process bulk disapproval
            disapproved_count = 0
            student_names = []
            
            for clearance in clearance_forms:
                try:
                    # Create or update business manager signatory
                    signatory, created = ClearanceSignatory.objects.get_or_create(
                        clearance=clearance,
                        signatory=request.user,
                        role='business_manager',
                        defaults={
                            'status': 'disapproved',
                            'remarks': f"{reason}. {comment}".strip(),
                            'ip_address': get_client_ip(request)
                        }
                    )
                    
                    if not created:
                        signatory.status = 'disapproved'
                        signatory.remarks = f"{reason}. {comment}".strip()
                        signatory.ip_address = get_client_ip(request)
                        signatory.save()
                    
                    disapproved_count += 1
                    student_names.append(clearance.student.get_full_name())
                    
                    # Create appointment notification if date provided
                    appointment_message = ""
                    if appointment_date:
                        appointment_message = f" Please visit on {appointment_date} to resolve the issues."
                        
                        # Create appointment event
                        CalendarEvent.objects.create(
                            title=f"Clearance Appointment - {clearance.student.get_full_name()}",
                            description=f"Appointment for clearance disapproval resolution. Reason: {reason}",
                            start_date=appointment_date,
                            created_by=request.user
                        )
                    
                    # Send individual notification to student
                    Notification.objects.create(
                        user=clearance.student,
                        title="Clearance Disapproved",
                        message=f"Your clearance form has been disapproved by the Business Manager. Reason: {reason}.{appointment_message}",
                        notification_type='error'
                    )
                    
                    # Log activity
                    ActivityLog.objects.create(
                        user=request.user,
                        action='BULK_DISAPPROVE_CLEARANCE',
                        description=f'Bulk disapproved clearance for {clearance.student.get_full_name()}. Reason: {reason}',
                        ip_address=get_client_ip(request)
                    )
                    
                except Exception as e:
                    print(f"Error disapproving clearance {clearance.id}: {e}")
                    continue
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully disapproved {disapproved_count} clearance(s)',
                'disapproved_count': disapproved_count,
                'student_names': student_names
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON data'}, status=400)
        except Exception as e:
            print(f"Bulk disapprove error: {e}")
            return JsonResponse({'error': 'Failed to disapprove clearances'}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

def business_manager_preview_print_clearance(request):
    """Return printable HTML fragment for preview modal - MATCHES REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    clearance_ids = request.GET.get('ids', '').split(',')
    if not clearance_ids or clearance_ids == ['']:
        return JsonResponse({'error': 'No clearance IDs provided'}, status=400)
    
    # Filter out empty IDs
    clearance_ids = [id.strip() for id in clearance_ids if id.strip()]
    if not clearance_ids:
        return JsonResponse({'error': 'No valid clearance IDs provided'}, status=400)
    
    clearance_forms = []
    
    # Efficiently fetch all clearances with their signatories
    clearances = ClearanceForm.objects.select_related(
        'student', 'student__profile'
    ).prefetch_related(
        'signatories__signatory__signatory_profile',
        'student__enrollment_forms'
    ).filter(id__in=clearance_ids)
    
    for clearance_form in clearances:
        try:
            # Get enrollment form for section
            enrollment_form = clearance_form.student.enrollment_forms.first()
            
            # Process signatory statuses with live data
            signatories = {}
            clearance_signatories = clearance_form.signatories.all()
            
            # Group signatories by type to handle duplicates
            signatory_groups = {}
            for clearance_signatory in clearance_signatories:
                # Get signatory type from profile
                try:
                    signatory_type = clearance_signatory.signatory.signatory_profile.signatory_type
                except:
                    # Fallback for users without profile
                    if clearance_signatory.signatory.user_type == 'admin':
                        signatory_type = 'registrar'
                    else:
                        signatory_type = 'unknown'
                
                # Group by signatory type
                if signatory_type not in signatory_groups:
                    signatory_groups[signatory_type] = []
                signatory_groups[signatory_type].append(clearance_signatory)
            
            # Process each signatory group
            for signatory_type, signatory_list in signatory_groups.items():
                if len(signatory_list) == 1:
                    # Single signatory of this type
                    clearance_signatory = signatory_list[0]
                    signatories[signatory_type] = {
                        'name': clearance_signatory.signatory.full_name,
                        'status': clearance_signatory.status,
                        'timestamp': clearance_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if clearance_signatory.updated_at else None,
                        'comment': clearance_signatory.remarks or clearance_signatory.comment
                    }
                else:
                    # Multiple signatories of the same type - choose the best one
                    approved_signatories = [s for s in signatory_list if s.status == 'approved']
                    if approved_signatories:
                        # Use the first approved one
                        best_signatory = approved_signatories[0]
                    else:
                        # Use the most recently updated one
                        best_signatory = max(signatory_list, key=lambda s: s.updated_at or clearance_signatory.clearance.created_at)
                    
                    signatories[signatory_type] = {
                        'name': best_signatory.signatory.full_name,
                        'status': best_signatory.status,
                        'timestamp': best_signatory.updated_at.strftime('%Y-%m-%d %H:%M') if best_signatory.updated_at else None,
                        'comment': best_signatory.remarks or best_signatory.comment
                    }
            
            clearance_forms.append({
                'clearance': clearance_form,
                'student': clearance_form.student,
                'profile': clearance_form.student.profile,
                'enrollment': enrollment_form,
                'signatories': clearance_signatories,  # Use the actual queryset
            })
        except Exception as e:
            continue  # Skip problematic clearances
    
    # Check if any clearances were found
    if not clearance_forms:
        return JsonResponse({'error': 'No valid clearance forms found for the provided IDs'}, status=400)
    
    context = {
        'clearance_forms': clearance_forms,
        'is_preview': True,  # Flag to indicate this is for preview
    }
    
    return render(request, 'pdf/pdf-clearance-preview.html', context)


def business_manager_verify_pin(request):
    """Verify business manager PIN"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        pin = data.get('pin', '')
        
        if not pin:
            return JsonResponse({'error': 'PIN is required'}, status=400)
        
        if verify_bm_pin_helper(request.user, pin):
            return JsonResponse({'success': True})
        else:
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
    except Exception as e:
        print(f"Error verifying business manager PIN: {e}")
        return JsonResponse({'error': 'Server error'}, status=500)

def verify_bm_pin_helper(user, pin):
    """Verify business manager PIN"""
    try:
        # Check if user has a business manager profile with PIN set
        if hasattr(user, 'business_manager_profile') and user.business_manager_profile:
            if user.business_manager_profile.pin_set and user.business_manager_profile.pin:
                import hashlib
                hashed_pin = hashlib.sha256(pin.encode()).hexdigest()
                if user.business_manager_profile.pin == hashed_pin:
                    return True
                # Return False if PIN doesn't match
                return False
        
        # Check if user has a signatory profile with business_manager type (legacy support)
        if hasattr(user, 'signatory_profile') and user.signatory_profile and user.signatory_profile.signatory_type == 'business_manager':
            if user.signatory_profile.pin_set and user.signatory_profile.pin:
                import hashlib
                hashed_pin = hashlib.sha256(pin.encode()).hexdigest()
                if user.signatory_profile.pin == hashed_pin:
                    return True
                # Return False if PIN doesn't match
                return False
        
        # Temporary fallback for testing - DEFAULT PIN: "123456"
        # This will be removed when proper business manager PIN setup is implemented
        if user.user_type in ['admin', 'registrar'] or is_business_manager(user):
            import hashlib
            default_pin_hash = hashlib.sha256("123456".encode()).hexdigest()
            test_pin_hash = hashlib.sha256(pin.encode()).hexdigest()
            return test_pin_hash == default_pin_hash
            
        return False
    except Exception as e:
        print(f"Error in verify_bm_pin_helper: {e}")
        return False

@login_required
def business_manager_check_setup_status(request):
    """Check if business manager needs first-time setup"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        business_manager_profile = getattr(request.user, 'business_manager_profile', None)
        
        # Check if setup is required
        requires_setup = (
            business_manager_profile is None or 
            business_manager_profile.force_password_change or 
            not business_manager_profile.pin_set
        )
        
        return JsonResponse({'requires_setup': requires_setup})
    except Exception as e:
        print(f"Error checking business manager setup status: {e}")
        return JsonResponse({'error': 'Server error'}, status=500)

@login_required
def business_manager_set_pin(request):
    """Set PIN for business manager first-time setup"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
        
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        pin = request.POST.get('pin', '').strip()
        confirm_pin = request.POST.get('confirm_pin', '').strip()
        
        # Validation
        if not pin:
            return JsonResponse({'error': 'PIN is required'}, status=400)
        
        if len(pin) < 6:
            return JsonResponse({'error': 'PIN must be at least 6 characters'}, status=400)
            
        if pin != confirm_pin:
            return JsonResponse({'error': 'PINs do not match'}, status=400)
        
        # Get or create business manager profile
        business_manager_profile, created = BusinessManagerProfile.objects.get_or_create(
            user=request.user
        )
        
        # Hash and set the PIN
        import hashlib
        hashed_pin = hashlib.sha256(pin.encode()).hexdigest()
        business_manager_profile.pin = hashed_pin
        business_manager_profile.pin_set = True
        business_manager_profile.save()
        
        return JsonResponse({'success': True})
        
    except Exception as e:
        print(f"Error setting business manager PIN: {e}")
        return JsonResponse({'error': 'Server error'}, status=500)

@login_required
def business_manager_change_pin(request):
    """Change PIN for business manager"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
        
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        current_pin = request.POST.get('currentPin')
        new_pin = request.POST.get('newPin')
        confirm_pin = request.POST.get('confirmPin')
        
        if not current_pin or not new_pin or not confirm_pin:
            return JsonResponse({'error': 'All PIN fields are required'}, status=400)
        
        if new_pin != confirm_pin:
            return JsonResponse({'error': 'New PIN and confirmation do not match'}, status=400)
        
        if len(new_pin) < 6:
            return JsonResponse({'error': 'New PIN must be at least 6 characters'}, status=400)
        
        # Get business manager profile
        try:
            business_manager_profile = BusinessManagerProfile.objects.get(user=request.user)
        except BusinessManagerProfile.DoesNotExist:
            return JsonResponse({'error': 'Business Manager profile not found'}, status=404)
        
        # Verify current PIN
        if not business_manager_profile.pin:
            return JsonResponse({'error': 'No PIN is currently set. Please contact administrator.'}, status=400)
        
        # Hash current PIN to compare
        import hashlib
        hashed_current_pin = hashlib.sha256(current_pin.encode()).hexdigest()
        if business_manager_profile.pin != hashed_current_pin:
            return JsonResponse({'error': 'Current PIN is incorrect'}, status=400)
        
        # Update to new PIN (hashed)
        hashed_new_pin = hashlib.sha256(new_pin.encode()).hexdigest()
        business_manager_profile.pin = hashed_new_pin
        business_manager_profile.save()
        
        return JsonResponse({'success': True, 'message': 'PIN changed successfully'})
        
    except Exception as e:
        print(f"Error in business_manager_change_pin: {e}")
        return JsonResponse({'error': 'An error occurred while changing PIN'}, status=500)

@login_required
def business_manager_change_password(request):
    """Change password for business manager first-time setup"""
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
        
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Unauthorized'}, status=403)
    
    try:
        current_password = request.POST.get('current_password', '')
        new_password = request.POST.get('new_password', '')
        confirm_password = request.POST.get('confirm_password', '')
        
        # Validation
        if not current_password or not new_password or not confirm_password:
            return JsonResponse({'error': 'All password fields are required'}, status=400)
        
        if new_password != confirm_password:
            return JsonResponse({'error': 'New passwords do not match'}, status=400)
            
        if len(new_password) < 8:
            return JsonResponse({'error': 'New password must be at least 8 characters'}, status=400)
        
        # Check current password
        from django.contrib.auth import authenticate
        if not authenticate(username=request.user.username, password=current_password):
            return JsonResponse({'error': 'Current password is incorrect'}, status=400)
        
        # Update password
        request.user.set_password(new_password)
        request.user.save()
        
        # Update business manager profile to mark password as changed
        business_manager_profile, created = BusinessManagerProfile.objects.get_or_create(
            user=request.user
        )
        business_manager_profile.force_password_change = False
        business_manager_profile.save()
        
        return JsonResponse({'success': True})
        
    except Exception as e:
        print(f"Error changing business manager password: {e}")
        return JsonResponse({'error': 'Server error'}, status=500)

def get_client_ip(request):
    """Get client IP address"""
    x_forwarded_for = request.META.get('HTTP_X_FORWARDED_FOR')
    if x_forwarded_for:
        ip = x_forwarded_for.split(',')[0]
    else:
        ip = request.META.get('REMOTE_ADDR')
    return ip

# =============================================
# BUSINESS MANAGER ENROLLMENT FUNCTIONS
# =============================================

@login_required
def business_manager_bulk_approve_enrollment(request):
    """Bulk approve multiple enrollment forms for Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            enrollment_ids = data.get('enrollment_ids', [])
            pin = data.get('pin')
            comment = data.get('remarks', '')
            
            # Verify PIN first
            if not verify_bm_pin_helper(request.user, pin):
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            if not enrollment_ids:
                return JsonResponse({'error': 'No enrollment forms provided'}, status=400)
            
            enrollment_forms = EnrollmentForm.objects.filter(id__in=enrollment_ids)
            
            if not enrollment_forms.exists():
                return JsonResponse({'error': 'No enrollment forms found'}, status=404)
            
            # Process bulk approval
            approved_count = 0
            student_names = []
            
            for enrollment in enrollment_forms:
                try:
                    # Create or update business manager signatory record
                    business_signatory, created = EnrollmentSignatory.objects.get_or_create(
                        enrollment=enrollment,
                        signatory=request.user,
                        role='business_manager',
                        defaults={'status': 'approved', 'remarks': comment, 'ip_address': get_client_ip(request)}
                    )
                    
                    if not created:
                        business_signatory.status = 'approved'
                        business_signatory.remarks = comment
                        business_signatory.ip_address = get_client_ip(request)
                        business_signatory.save()
                    
                    approved_count += 1
                    student_names.append(enrollment.user.get_full_name())
                    
                    # Create individual notification for the student
                    Notification.objects.create(
                        recipient=enrollment.user,
                        message=f"Your enrollment form has been approved by Business Manager with remarks: {comment}" if comment else "Your enrollment form has been approved by Business Manager",
                        notification_type='enrollment_approved',
                        priority='normal'
                    )
                    
                    # Log activity
                    ActivityLog.objects.create(
                        user=request.user,
                        action=f'Approved enrollment form for {enrollment.user.get_full_name()}',
                        model_affected='EnrollmentForm',
                        record_id=str(enrollment.id),
                        ip_address=get_client_ip(request)
                    )
                    
                except Exception as e:
                    print(f"Error approving enrollment {enrollment.id}: {str(e)}")
                    continue
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully approved {approved_count} enrollment form(s): {", ".join(student_names)}'
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON data'}, status=400)
        except Exception as e:
            print(f"Bulk approve error: {str(e)}")
            return JsonResponse({'error': 'Failed to process bulk approval'}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def business_manager_bulk_disapprove_enrollment(request):
    """Bulk disapprove multiple enrollment forms for Business Manager"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method == 'POST':
        try:
            data = json.loads(request.body)
            enrollment_ids = data.get('enrollment_ids', [])
            pin = data.get('pin')
            remarks = data.get('remarks', '')
            appointment_date = data.get('appointment_date')
            
            # Verify PIN first
            if not verify_bm_pin_helper(request.user, pin):
                return JsonResponse({'error': 'Invalid PIN'}, status=400)
            
            if not enrollment_ids:
                return JsonResponse({'error': 'No enrollment forms provided'}, status=400)
            
            if not remarks:
                return JsonResponse({'error': 'Disapproval reason is required'}, status=400)
                
            enrollment_forms = EnrollmentForm.objects.filter(id__in=enrollment_ids)
            
            if not enrollment_forms.exists():
                return JsonResponse({'error': 'No enrollment forms found'}, status=404)
            
            # Process bulk disapproval
            disapproved_count = 0
            student_names = []
            
            for enrollment in enrollment_forms:
                try:
                    # Create or update business manager signatory record
                    business_signatory, created = EnrollmentSignatory.objects.get_or_create(
                        enrollment=enrollment,
                        signatory=request.user,
                        role='business_manager',
                        defaults={'status': 'disapproved', 'remarks': remarks, 'ip_address': get_client_ip(request)}
                    )
                    
                    if not created:
                        business_signatory.status = 'disapproved'
                        business_signatory.remarks = remarks
                        business_signatory.ip_address = get_client_ip(request)
                        business_signatory.save()
                    
                    disapproved_count += 1
                    student_names.append(enrollment.user.get_full_name())
                    
                    # Create individual notification for the student
                    Notification.objects.create(
                        recipient=enrollment.user,
                        message=f"Your enrollment form has been disapproved by Business Manager. Reason: {remarks}",
                        notification_type='enrollment_disapproved',
                        priority='high'
                    )
                    
                    # Create calendar event for appointment if date provided
                    if appointment_date:
                        try:
                            appointment_datetime = datetime.strptime(appointment_date, '%Y-%m-%d').replace(hour=9, minute=0)
                            CalendarEvent.objects.create(
                                title=f"Business Manager Appointment - {enrollment.user.get_full_name()}",
                                description=f"Appointment regarding disapproved enrollment form. Reason: {remarks}",
                                start_time=appointment_datetime,
                                end_time=appointment_datetime + timedelta(hours=1),
                                created_by=request.user,
                                event_type='appointment'
                            )
                        except ValueError:
                            pass  # Skip if date format is invalid
                    
                    # Log activity
                    ActivityLog.objects.create(
                        user=request.user,
                        action=f'Disapproved enrollment form for {enrollment.user.get_full_name()} - {remarks}',
                        model_affected='EnrollmentForm',
                        record_id=str(enrollment.id),
                        ip_address=get_client_ip(request)
                    )
                    
                except Exception as e:
                    print(f"Error disapproving enrollment {enrollment.id}: {str(e)}")
                    continue
            
            return JsonResponse({
                'success': True,
                'message': f'Successfully disapproved {disapproved_count} enrollment form(s): {", ".join(student_names)}'
            })
            
        except json.JSONDecodeError:
            return JsonResponse({'error': 'Invalid JSON data'}, status=400)
        except Exception as e:
            print(f"Bulk disapprove error: {str(e)}")
            return JsonResponse({'error': 'Failed to process bulk disapproval'}, status=500)
    
    return JsonResponse({'error': 'Method not allowed'}, status=405)

@login_required
def business_manager_enrollment_data_api(request):
    """API endpoint to get enrollment data for the business manager - MATCHES REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        # Get all enrollment forms with related data
        enrollment_forms = EnrollmentForm.objects.select_related('user').all().order_by('-created_at')
        
        data = []
        for form in enrollment_forms:
            # Get signatory statuses - check both signatory records and direct form fields
            dean_signatory = form.signatories.filter(role='dean').first()
            business_signatory = form.signatories.filter(role='business_manager').first()
            registrar_signatory = form.signatories.filter(role='registrar').first()
            
            # Get business manager status from signatory record
            business_status = business_signatory.status if business_signatory else 'pending'
            business_timestamp = business_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if business_signatory and business_signatory.status != 'pending' else ''
            
            # Determine overall status based on all required signatories
            all_signatories = form.signatories.all()
            roles_required = {'dean', 'business_manager', 'registrar'}
            statuses = {s.role: s.status for s in all_signatories}
            
            if roles_required.issubset(statuses.keys()) and all(statuses[role] == 'approved' for role in roles_required):
                status = 'approved'
            elif any(status == 'disapproved' for status in statuses.values()):
                status = 'disapproved'
            else:
                status = 'pending'
            
            enrollment_data = {
                'id': str(form.id),
                'student_name': form.user.full_name,
                'course': form.course,
                'year': form.year,
                'section': form.section,
                'id_number': form.user.profile.student_number if hasattr(form.user, 'profile') else 'N/A',
                'date_submitted': form.created_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p'),
                'pdf_file': 'Enrollment_Form.pdf',  # Placeholder
                'dean_status': dean_signatory.status if dean_signatory else 'pending',
                'dean_timestamp': dean_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if dean_signatory and dean_signatory.status != 'pending' else '',
                'business_status': business_status,
                'business_timestamp': business_timestamp,
                'registrar_status': registrar_signatory.status if registrar_signatory else 'pending',
                'registrar_timestamp': registrar_signatory.updated_at.astimezone(pytz.timezone('Asia/Manila')).strftime('%Y-%m-%d %I:%M %p') if registrar_signatory and registrar_signatory.status != 'pending' else '',
                'overall_status': status,
                'dean_remarks': dean_signatory.remarks if dean_signatory else '',
                'business_remarks': business_signatory.remarks if business_signatory else '',
                'registrar_remarks': registrar_signatory.remarks if registrar_signatory else '',
            }
            data.append(enrollment_data)
        
        return JsonResponse({'data': data})
    
    except Exception as e:
        print(f"Error in business_manager_enrollment_data_api: {e}")
        return JsonResponse({'error': 'Failed to fetch enrollment data'}, status=500)

@login_required 
def business_manager_approve_enrollment(request):
    """Approve enrollment form as business manager - MATCHES REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        enrollment_id = data.get('enrollment_id')
        pin = data.get('pin', '')
        remarks = data.get('remarks', '')
        
        if not enrollment_id:
            return JsonResponse({'error': 'Enrollment ID is required'}, status=400)
        
        if not pin:
            return JsonResponse({'error': 'PIN is required'}, status=400)
        
        # Verify PIN
        if not verify_bm_pin_helper(request.user, pin):
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get enrollment form
        enrollment_form = EnrollmentForm.objects.get(id=enrollment_id)
        
        # Get or create business manager signatory record
        business_signatory, created = EnrollmentSignatory.objects.get_or_create(
            enrollment=enrollment_form,
            signatory=request.user,
            role='business_manager',
            defaults={'status': 'approved', 'remarks': remarks, 'ip_address': get_client_ip(request)}
        )
        
        if not created:
            business_signatory.status = 'approved'
            business_signatory.remarks = remarks
            business_signatory.ip_address = get_client_ip(request)
            business_signatory.save()
        
        # Send individual approval notification to student
        try:
            from landing.notification_service import NotificationService
            NotificationService.notify_form_approval(
                form_instance=enrollment_form,
                form_type='enrollment',
                signatory_user=request.user,
                remarks=remarks
            )
        except Exception as e:
            print(f"Error sending approval notification: {e}")
        
        # Check if all required signatories approved and update enrollment status
        required_roles = ['business_manager', 'registrar', 'dean']
        all_signatories = EnrollmentSignatory.objects.filter(enrollment=enrollment_form)
        
        # Check if we have all required roles and all are approved
        signatory_roles = set(sig.role for sig in all_signatories)
        required_roles_set = set(required_roles)
        
        if (signatory_roles >= required_roles_set and 
            all_signatories.count() >= 4 and 
            all(s.status == 'approved' for s in all_signatories)):
            enrollment_form.status = 'approved'
            enrollment_form.save()
            
            # Send notifications for completed enrollment
            try:
                from landing.notification_service import NotificationService
                NotificationService.notify_enrollment_completed(enrollment_form.user, enrollment_form)
                NotificationService.notify_admin_form_completed('enrollment', enrollment_form.user.full_name)
            except Exception as notif_error:
                print(f"Error sending completion notification: {notif_error}")
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='enrollment_approve',
            description=f'Business Manager approved enrollment form {enrollment_id} for {enrollment_form.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({'success': True, 'message': 'Enrollment form approved successfully'})
        
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment form not found'}, status=404)
    except Exception as e:
        print(f"Error approving enrollment: {e}")
        return JsonResponse({'error': 'Failed to approve enrollment form'}, status=500)

@login_required
def business_manager_disapprove_enrollment(request):
    """Disapprove enrollment form as business manager - MATCHES REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        enrollment_id = data.get('enrollment_id')
        pin = data.get('pin', '')
        remarks = data.get('remarks', '')
        
        if not enrollment_id:
            return JsonResponse({'error': 'Enrollment ID is required'}, status=400)
        
        if not pin:
            return JsonResponse({'error': 'PIN is required'}, status=400)
            
        if not remarks:
            return JsonResponse({'error': 'Remarks are required for disapproval'}, status=400)
        
        # Verify PIN
        if not verify_bm_pin_helper(request.user, pin):
            return JsonResponse({'error': 'Invalid PIN'}, status=400)
        
        # Get enrollment form
        enrollment_form = EnrollmentForm.objects.get(id=enrollment_id)
        
        # Get or create business manager signatory record
        business_signatory, created = EnrollmentSignatory.objects.get_or_create(
            enrollment=enrollment_form,
            signatory=request.user,
            role='business_manager',
            defaults={'status': 'disapproved', 'remarks': remarks, 'ip_address': get_client_ip(request)}
        )
        
        if not created:
            business_signatory.status = 'disapproved'
            business_signatory.remarks = remarks
            business_signatory.ip_address = get_client_ip(request)
            business_signatory.save()
        
        # Send notification to student
        try:
            from landing.notification_service import NotificationService
            notification_service = NotificationService()
            notification_service.handle_form_disapproval(
                form=enrollment_form,
                form_type='enrollment',
                disapproval_reasons=[],
                settlement_instructions=remarks,
                appointment_date=None
            )
        except Exception as e:
            print(f"Error sending business manager enrollment disapproval notification: {e}")
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='enrollment_disapprove',
            description=f'Business Manager disapproved enrollment form {enrollment_id} for {enrollment_form.user.full_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({'success': True, 'message': 'Enrollment form disapproved'})
        
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment form not found'}, status=404)
    except Exception as e:
        print(f"Error disapproving enrollment: {e}")
        return JsonResponse({'error': 'Failed to disapprove enrollment form'}, status=500)

@login_required
def business_manager_delete_enrollment(request, enrollment_id):
    """Delete single enrollment form - MATCHES REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'DELETE':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        enrollment_form = EnrollmentForm.objects.get(id=enrollment_id)
        student_name = enrollment_form.user.full_name
        
        # Delete the form
        enrollment_form.delete()
        
        # Log the action
        AuditLog.objects.create(
            user=request.user,
            action_type='enrollment_delete',
            description=f'Business Manager deleted enrollment form {enrollment_id} for {student_name} [IP: {get_client_ip(request)}]'
        )
        
        return JsonResponse({'success': True, 'message': 'Enrollment form deleted successfully'})
        
    except EnrollmentForm.DoesNotExist:
        return JsonResponse({'error': 'Enrollment form not found'}, status=404)
    except Exception as e:
        print(f"Error deleting enrollment: {e}")
        return JsonResponse({'error': 'Failed to delete enrollment form'}, status=500)

@login_required
def business_manager_bulk_delete_enrollment(request):
    """Bulk delete enrollment forms - MATCHES REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    if request.method != 'POST':
        return JsonResponse({'error': 'Method not allowed'}, status=405)
    
    try:
        import json
        data = json.loads(request.body)
        enrollment_ids = data.get('enrollment_ids', [])
        
        if not enrollment_ids:
            return JsonResponse({'error': 'No enrollment IDs provided'}, status=400)
        
        deleted_count = 0
        for enrollment_id in enrollment_ids:
            try:
                enrollment_form = EnrollmentForm.objects.get(id=enrollment_id)
                student_name = enrollment_form.user.full_name
                
                # Delete the form
                enrollment_form.delete()
                deleted_count += 1
                
                # Log the action
                AuditLog.objects.create(
                    user=request.user,
                    action_type='enrollment_bulk_delete',
                    description=f'Business Manager bulk deleted enrollment form {enrollment_id} for {student_name} [IP: {get_client_ip(request)}]'
                )
                
            except EnrollmentForm.DoesNotExist:
                continue
        
        return JsonResponse({
            'success': True, 
            'message': f'Successfully deleted {deleted_count} enrollment form{"s" if deleted_count != 1 else ""}'
        })
        
    except Exception as e:
        print(f"Error in bulk delete enrollment: {e}")
        return JsonResponse({'error': 'Failed to delete enrollment forms'}, status=500)

@login_required
def business_manager_preview_print_enrollment(request):
    """Return printable HTML fragment for enrollment preview modal - MATCHES REGISTRAR FUNCTIONALITY"""
    if not is_business_manager(request.user):
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    enrollment_ids = request.GET.get('ids', '').split(',')
    if not enrollment_ids or enrollment_ids == ['']:
        return JsonResponse({'error': 'No enrollment IDs provided'}, status=400)
    
    # Filter out empty IDs
    enrollment_ids = [id.strip() for id in enrollment_ids if id.strip()]
    if not enrollment_ids:
        return JsonResponse({'error': 'No valid enrollment IDs provided'}, status=400)
    
    enrollment_forms = []
    
    # Efficiently fetch all enrollments
    enrollments = EnrollmentForm.objects.select_related('user').prefetch_related('signatories').filter(id__in=enrollment_ids)
    
    for enrollment_form in enrollments:
        try:
            student = enrollment_form.user
            profile = getattr(student, 'profile', None) or getattr(student, 'alumni_profile', None)
            
            enrollment_forms.append({
                'enrollment': enrollment_form,
                'student': student,
                'profile': profile,
                'signatories': enrollment_form.signatories.all(),
            })
        except Exception as e:
            continue  # Skip problematic enrollments
    
    # Check if any enrollments were found
    if not enrollment_forms:
        return JsonResponse({'error': 'No valid enrollment forms found for the provided IDs'}, status=400)
    
    context = {
        'enrollment_forms': enrollment_forms,
        'is_preview': True,  # Flag to indicate this is for preview
    }
    
    return render(request, 'pdf/pdf-enrollment.html', context)


# ========================================
# SIMPLE GOOGLE OAUTH INTEGRATION
# ========================================

import requests
import secrets
from urllib.parse import urlencode
from django.conf import settings
from django.contrib.auth import login as auth_login
from django.contrib import messages

def google_oauth_login(request):
    """Simple Google OAuth login without allauth"""
    user_type = request.GET.get('state', 'student')
    
    # Store user type in session
    request.session['oauth_user_type'] = user_type
    
    # Generate state parameter for security
    state = secrets.token_urlsafe(32)
    request.session['oauth_state'] = state
    
    # Build Google OAuth URL
    google_auth_url = 'https://accounts.google.com/o/oauth2/v2/auth'
    
    # Use configured redirect URI if available, otherwise build dynamically
    if hasattr(settings, 'GOOGLE_OAUTH_REDIRECT_URI') and settings.GOOGLE_OAUTH_REDIRECT_URI:
        redirect_uri = settings.GOOGLE_OAUTH_REDIRECT_URI
    else:
        redirect_uri = request.build_absolute_uri('/google-callback/')
    
    # Debug: Print the redirect URI to console
    print(f"DEBUG: Google OAuth redirect_uri: {redirect_uri}")
    
    params = {
        'client_id': settings.GOOGLE_CLIENT_ID,
        'redirect_uri': redirect_uri,
        'scope': 'openid email profile',
        'response_type': 'code',
        'state': f"{state}_{user_type}",  # Include user type in state
    }
    
    auth_url = f"{google_auth_url}?{urlencode(params)}"
    print(f"DEBUG: Full Google OAuth URL: {auth_url}")
    return redirect(auth_url)

def google_oauth_callback(request):
    """Handle Google OAuth callback"""
    print(f"DEBUG: Google OAuth callback called")
    print(f"DEBUG: Request URL: {request.build_absolute_uri()}")
    print(f"DEBUG: Request GET params: {dict(request.GET)}")
    
    code = request.GET.get('code')
    state = request.GET.get('state', '')
    error = request.GET.get('error')
    
    print(f"DEBUG: code={code}")
    print(f"DEBUG: state={state}")
    print(f"DEBUG: error={error}")
    
    if error:
        print(f"DEBUG: OAuth error detected: {error}")
        messages.error(request, f"Google authentication failed: {error}")
        return redirect('login')
    
    if not code:
        print(f"DEBUG: No authorization code received")
        messages.error(request, "No authorization code received from Google")
        return redirect('login')
    
    try:
        print(f"DEBUG: Entering try block")
        # Parse state to get user type
        if '_' in state:
            oauth_state, user_type = state.rsplit('_', 1)
        else:
            oauth_state = state
            user_type = request.session.get('oauth_user_type', 'student')
        
        print(f"DEBUG: Parsed oauth_state={oauth_state}, user_type={user_type}")
        
        # Verify state parameter
        expected_state = request.session.get('oauth_state')
        print(f"DEBUG: expected_state={expected_state}")
        
        if oauth_state != expected_state:
            print(f"DEBUG: State parameter mismatch!")
            messages.error(request, "Invalid state parameter")
            return redirect('login')
        
        # Exchange code for access token
        token_url = 'https://oauth2.googleapis.com/token'
        
        # Use the same redirect URI logic as in the login function
        if hasattr(settings, 'GOOGLE_OAUTH_REDIRECT_URI') and settings.GOOGLE_OAUTH_REDIRECT_URI:
            redirect_uri = settings.GOOGLE_OAUTH_REDIRECT_URI
        else:
            redirect_uri = request.build_absolute_uri('/google-callback/')
        
        # Try method 1: Basic Authentication (recommended by Google)
        import base64
        
        # Encode client credentials for Basic Auth
        credentials = f"{settings.GOOGLE_CLIENT_ID}:{settings.GOOGLE_CLIENT_SECRET}"
        encoded_credentials = base64.b64encode(credentials.encode()).decode()
        
        token_data = {
            'code': code,
            'grant_type': 'authorization_code',
            'redirect_uri': redirect_uri,
        }
        
        headers = {
            'Authorization': f'Basic {encoded_credentials}',
            'Content-Type': 'application/x-www-form-urlencoded'
        }
        
        print(f"DEBUG: Making token request to Google with Basic Auth...")
        print(f"DEBUG: client_id={settings.GOOGLE_CLIENT_ID}")
        print(f"DEBUG: client_secret={'*' * (len(settings.GOOGLE_CLIENT_SECRET) - 4) + settings.GOOGLE_CLIENT_SECRET[-4:]}")
        print(f"DEBUG: redirect_uri={redirect_uri}")
        
        token_response = requests.post(token_url, data=token_data, headers=headers)
        
        # If Basic Auth fails, try the original method
        if token_response.status_code == 401:
            print(f"DEBUG: Basic Auth failed, trying with credentials in body...")
            token_data_with_creds = {
                'client_id': settings.GOOGLE_CLIENT_ID,
                'client_secret': settings.GOOGLE_CLIENT_SECRET,
                'code': code,
                'grant_type': 'authorization_code',
                'redirect_uri': redirect_uri,
            }
            token_response = requests.post(token_url, data=token_data_with_creds)
        token_json = token_response.json()
        print(f"DEBUG: Token response status: {token_response.status_code}")
        print(f"DEBUG: Token response: {token_json}")
        
        if 'access_token' not in token_json:
            print(f"DEBUG: No access token in response")
            messages.error(request, "Failed to obtain access token from Google")
            return redirect('login')
        
        # Get user info from Google
        user_info_url = 'https://www.googleapis.com/oauth2/v2/userinfo'
        user_info_response = requests.get(
            user_info_url,
            headers={'Authorization': f"Bearer {token_json['access_token']}"}
        )
        user_info = user_info_response.json()
        
        if 'email' not in user_info:
            messages.error(request, "Failed to get user information from Google")
            return redirect('login')
        
        # Create or get user
        email = user_info['email']
        name = user_info.get('name', '')
        
        try:
            user = User.objects.get(email=email)
            # Update existing user
            user.user_type = user_type
            user.is_google_account = True
            if name and not user.full_name:
                user.full_name = name
            user.save()
        except User.DoesNotExist:
            # Create new user
            user = User.objects.create_user(
                username=email,
                email=email,
                full_name=name,
                user_type=user_type,
                is_google_account=True
            )
        
        # Create profile if needed
        if user_type == 'student' and not hasattr(user, 'profile'):
            create_student_profile_from_google(user, user_info)
        elif user_type == 'alumni' and not hasattr(user, 'alumni_profile'):
            create_alumni_profile_from_google(user, user_info)
        
        # Login user
        print(f"DEBUG: Logging in user: {user.email}")
        auth_login(request, user)
        messages.success(request, f"Successfully logged in as {user_type}")
        
        print(f"DEBUG: Redirecting to dashboard...")
        return redirect('/dashboard/')
        
    except Exception as e:
        print(f"DEBUG: Exception in callback: {str(e)}")
        import traceback
        traceback.print_exc()
        messages.error(request, f"Authentication error: {str(e)}")
        return redirect('login')

def create_student_profile_from_google(user, extra_data):
    """Create a student profile for Google-authenticated users"""
    try:
        # Check if profile already exists
        if hasattr(user, 'profile'):
            return
        
        # Create StudentProfile with minimal required data
        # The user will need to complete their profile later
        StudentProfile.objects.create(
            user=user,
            student_number=f"GOOGLE_{user.id}",  # Temporary student number
            program="To be set",  # Will be updated by user
            year_level=1,  # Default value
            # Other fields can be filled later by the user
        )
    except Exception as e:
        print(f"Error creating student profile: {e}")

def create_alumni_profile_from_google(user, extra_data):
    """Create an alumni profile for Google-authenticated users"""
    try:
        # Check if profile already exists
        if hasattr(user, 'alumni_profile'):
            return
        
        # Create AlumniProfile
        AlumniProfile.objects.create(
            user=user,
            alumni_id=f"GOOGLE_{user.id}",  # Temporary alumni ID
            course_graduated="To be set",  # Will be updated by user
            year_graduated="2024",  # Default year, can be updated
        )
    except Exception as e:
        print(f"Error creating alumni profile: {e}")

# Old allauth-based functions removed

# Old allauth adapter removed - using simple OAuth now

@login_required
def check_profile_completion(request):
    """Check if user needs to complete their profile"""
    needs_completion = request.user.needs_profile_completion()
    return JsonResponse({'needs_completion': needs_completion})

@login_required
@require_POST
def complete_profile(request):
    """Complete user profile with submitted data"""
    try:
        user = request.user
        
        # Get user type from form (user can now select this)
        user_type = request.POST.get('user_type', 'student').strip()
        
        # Update user type if it has changed
        if user.user_type != user_type:
            user.user_type = user_type
            user.save()
        
        # Get form data
        id_number = request.POST.get('id_number', '').strip()
        program = request.POST.get('program', '').strip()
        year_info = request.POST.get('year_info', '').strip()
        gender = request.POST.get('gender', '').strip()
        birthdate = request.POST.get('birthdate', '').strip()
        address = request.POST.get('address', '').strip()
        contact_number = request.POST.get('contact_number', '').strip()
        is_graduating = request.POST.get('is_graduating', 'false').lower() == 'true'
        profile_picture = request.FILES.get('profile_picture')
        
        # Validate required fields
        if not all([id_number, program, year_info, gender, birthdate, address]):
            return JsonResponse({
                'success': False, 
                'message': 'All required fields must be filled.'
            })
        
        # Update contact number if provided
        if contact_number:
            user.contact_number = contact_number
            user.save()
        
        # Parse birthdate
        try:
            from datetime import datetime, timezone as dt_timezone
            birthdate_obj = datetime.strptime(birthdate, '%Y-%m-%d').date()
        except ValueError:
            return JsonResponse({
                'success': False, 
                'message': 'Invalid birthdate format.'
            })
        
        if user_type == 'student':
            # Update or create student profile
            try:
                profile = user.profile
                profile.student_number = id_number
                profile.program = program
                profile.year_level = int(year_info)
                profile.gender = gender
                profile.birthdate = birthdate_obj
                profile.address = address
                profile.is_graduating = is_graduating
                if profile_picture:
                    profile.profile_picture = profile_picture
                profile.save()
            except:
                # Create new profile if doesn't exist
                profile_data = {
                    'user': user,
                    'student_number': id_number,
                    'program': program,
                    'year_level': int(year_info),
                    'gender': gender,
                    'birthdate': birthdate_obj,
                    'address': address,
                    'is_graduating': is_graduating
                }
                if profile_picture:
                    profile_data['profile_picture'] = profile_picture
                StudentProfile.objects.create(**profile_data)
        
        elif user_type == 'alumni':
            # Update or create alumni profile
            try:
                profile = user.alumni_profile
                profile.alumni_id = id_number
                profile.course_graduated = program
                profile.year_graduated = year_info
                profile.gender = gender
                profile.birthdate = birthdate_obj
                profile.address = address
                if profile_picture:
                    profile.profile_picture = profile_picture
                profile.save()
            except:
                # Create new profile if doesn't exist
                profile_data = {
                    'user': user,
                    'alumni_id': id_number,
                    'course_graduated': program,
                    'year_graduated': year_info,
                    'gender': gender,
                    'birthdate': birthdate_obj,
                    'address': address
                }
                if profile_picture:
                    profile_data['profile_picture'] = profile_picture
                AlumniProfile.objects.create(**profile_data)
        
        # Determine redirect URL based on user type
        if user_type == 'alumni':
            redirect_url = '/dashboard/'  # Alumni still use the same dashboard, just with different permissions
        else:
            redirect_url = '/dashboard/'  # Students use the student dashboard
        
        return JsonResponse({
            'success': True,
            'message': 'Profile completed successfully!',
            'redirect_url': redirect_url,
            'user_type': user_type
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'message': f'Error completing profile: {str(e)}'
        })

# --------------------
# MESSAGING SYSTEM
# --------------------

@login_required
def get_conversations(request):
    """Get all conversations for the current user"""
    from landing.models import Conversation
    
    user = request.user
    conversations = Conversation.objects.filter(
        Q(participant_1=user) | Q(participant_2=user)
    ).order_by('-updated_at')
    
    conversations_data = []
    for conv in conversations:
        other_user = conv.get_other_participant(user)
        last_message = conv.get_last_message()
        
        # Count unread messages
        unread_count = conv.messages.filter(
            sender=other_user,
            is_read=False
        ).count()
        
        conversations_data.append({
            'id': str(conv.id),
            'other_user': {
                'id': str(other_user.id),
                'name': other_user.full_name,
                'user_type': other_user.get_user_type_display(),
                'profile_picture': get_user_profile_picture(other_user),
            },
            'last_message': {
                'content': last_message.content if last_message else '',
                'sent_at': last_message.sent_at.isoformat() if last_message else '',
                'sender_name': last_message.sender.full_name if last_message else '',
                'is_own_message': last_message.sender == user if last_message else False,
                'message_type': last_message.message_type if last_message else 'text',
            } if last_message else None,
            'unread_count': unread_count,
            'updated_at': conv.updated_at.isoformat(),
        })
    
    return JsonResponse({
        'success': True,
        'conversations': conversations_data
    })

@login_required 
def get_conversation_messages(request, conversation_id):
    """Get messages for a specific conversation"""
    from landing.models import Conversation, Message
    
    try:
        conversation = Conversation.objects.filter(
            id=conversation_id
        ).filter(
            Q(participant_1=request.user) | Q(participant_2=request.user)
        ).get()
    except Conversation.DoesNotExist:
        return JsonResponse({'success': False, 'message': 'Conversation not found'})
    
    # Mark messages as read
    unread_messages = conversation.messages.filter(
        is_read=False
    ).exclude(sender=request.user)
    
    for message in unread_messages:
        message.mark_as_read()
    
    # Get messages
    messages = conversation.messages.order_by('sent_at')
    messages_data = []
    
    for msg in messages:
        messages_data.append({
            'id': str(msg.id),
            'content': msg.content,
            'message_type': msg.message_type,
            'file_attachment': msg.file_attachment.url if msg.file_attachment else None,
            'file_name': msg.file_name,
            'file_size_formatted': msg.file_size_formatted,
            'sender': {
                'id': str(msg.sender.id),
                'name': msg.sender.full_name,
                'profile_picture': get_user_profile_picture(msg.sender),
            },
            'is_own_message': msg.sender == request.user,
            'sent_at': msg.sent_at.isoformat(),
            'is_read': msg.is_read,
            'read_at': msg.read_at.isoformat() if msg.read_at else None,
        })
    
    return JsonResponse({
        'success': True,
        'messages': messages_data,
        'conversation': {
            'id': str(conversation.id),
            'other_user': {
                'id': str(conversation.get_other_participant(request.user).id),
                'name': conversation.get_other_participant(request.user).full_name,
                'user_type': conversation.get_other_participant(request.user).get_user_type_display(),
                'profile_picture': get_user_profile_picture(conversation.get_other_participant(request.user)),
            }
        }
    })

@login_required
@require_POST
def send_message(request):
    """Send a message in a conversation"""
    from landing.models import Conversation, Message
    
    conversation_id = request.POST.get('conversation_id')
    content = request.POST.get('content', '').strip()
    file_attachment = request.FILES.get('file_attachment')
    
    if not conversation_id:
        return JsonResponse({'success': False, 'message': 'Conversation ID required'})
    
    if not content and not file_attachment:
        return JsonResponse({'success': False, 'message': 'Message content or file required'})
    
    try:
        conversation = Conversation.objects.filter(
            id=conversation_id
        ).filter(
            Q(participant_1=request.user) | Q(participant_2=request.user)
        ).get()
    except Conversation.DoesNotExist:
        return JsonResponse({'success': False, 'message': 'Conversation not found'})
    
    # Determine message type
    message_type = 'text'
    file_name = None
    file_size = None
    
    if file_attachment:
        file_name = file_attachment.name
        file_size = file_attachment.size
        
        # Determine if it's an image
        if file_attachment.content_type.startswith('image/'):
            message_type = 'image'
        else:
            message_type = 'file'
    
    # Create message
    message = Message.objects.create(
        conversation=conversation,
        sender=request.user,
        message_type=message_type,
        content=content,
        file_attachment=file_attachment,
        file_name=file_name,
        file_size=file_size
    )
    
    # Update conversation timestamp
    conversation.save()  # This triggers updated_at
    
    return JsonResponse({
        'success': True,
        'message': {
            'id': str(message.id),
            'content': message.content,
            'message_type': message.message_type,
            'file_attachment': message.file_attachment.url if message.file_attachment else None,
            'file_name': message.file_name,
            'file_size_formatted': message.file_size_formatted,
            'sender': {
                'id': str(message.sender.id),
                'name': message.sender.full_name,
                'profile_picture': get_user_profile_picture(message.sender),
            },
            'is_own_message': True,
            'sent_at': message.sent_at.isoformat(),
            'is_read': message.is_read,
        }
    })

@login_required
def get_users_for_new_conversation(request):
    """Get users that the current user can start conversations with"""
    user = request.user
    
    # Business rule: Only registrar, business_manager, and signatories can start conversations
    can_initiate = user.user_type in ['admin', 'business_manager', 'signatory']
    
    if not can_initiate:
        return JsonResponse({
            'success': False,
            'message': 'You do not have permission to start new conversations'
        })
    
    # Get all users except self
    users = User.objects.exclude(id=user.id).order_by('full_name')
    
    users_data = []
    for u in users:
        users_data.append({
            'id': str(u.id),
            'name': u.full_name,
            'user_type': u.get_user_type_display(),
            'profile_picture': get_user_profile_picture(u),
            'email': u.email,
        })
    
    return JsonResponse({
        'success': True,
        'users': users_data,
        'can_initiate': can_initiate
    })

@login_required
@require_POST  
def start_conversation(request):
    """Start a new conversation with a user"""
    from landing.models import Conversation
    
    user = request.user
    other_user_id = request.POST.get('user_id')
    initial_message = request.POST.get('message', '').strip()
    
    # Business rule: Only registrar, business_manager, and signatories can start conversations
    can_initiate = user.user_type in ['admin', 'business_manager', 'signatory']
    
    if not can_initiate:
        return JsonResponse({
            'success': False,
            'message': 'You do not have permission to start conversations'
        })
    
    if not other_user_id:
        return JsonResponse({'success': False, 'message': 'User ID required'})
        
    try:
        other_user = User.objects.get(id=other_user_id)
    except User.DoesNotExist:
        return JsonResponse({'success': False, 'message': 'User not found'})
    
    if other_user == user:
        return JsonResponse({'success': False, 'message': 'Cannot start conversation with yourself'})
    
    # Check if conversation already exists
    existing_conv = Conversation.objects.filter(
        Q(participant_1=user, participant_2=other_user) |
        Q(participant_1=other_user, participant_2=user)
    ).first()
    
    if existing_conv:
        return JsonResponse({
            'success': True,
            'conversation_id': str(existing_conv.id),
            'message': 'Conversation already exists'
        })
    
    # Create new conversation
    conversation = Conversation.objects.create(
        participant_1=user,
        participant_2=other_user,
        initiated_by=user
    )
    
    # Send initial message if provided
    if initial_message:
        from landing.models import Message
        Message.objects.create(
            conversation=conversation,
            sender=user,
            content=initial_message
        )
    
    return JsonResponse({
        'success': True,
        'conversation_id': str(conversation.id),
        'message': 'Conversation started successfully'
    })

def get_user_profile_picture(user):
    """Helper function to get user profile picture URL"""
    try:
        if user.user_type == 'student' and hasattr(user, 'profile'):
            return user.profile.profile_picture_url
        elif user.user_type == 'alumni' and hasattr(user, 'alumni_profile'):
            return user.alumni_profile.profile_picture_url
        elif user.user_type == 'signatory' and hasattr(user, 'signatory_profile'):
            return user.signatory_profile.profile_picture_url if user.signatory_profile.profile_picture else '/static/images/default-profile.png'
        elif user.user_type == 'business_manager' and hasattr(user, 'business_manager_profile'):
            return user.business_manager_profile.profile_picture_url if user.business_manager_profile.profile_picture else '/static/images/default-profile.png'
    except:
        pass
    return '/static/images/default-profile.png'

# ==============================================================================
# NOTIFICATION SYSTEM UTILITIES
# ==============================================================================

def create_notification(user, title, message):
    """Create a new notification for a user"""
    from landing.models import Notification
    notification = Notification.objects.create(
        user=user,
        title=title,
        message=message
    )
    return notification

def get_user_notifications(user, limit=10):
    """Get notifications for a user"""
    from landing.models import Notification
    return Notification.objects.filter(user=user).order_by('-created_at')[:limit]

def get_unread_notification_count(user):
    """Get count of unread notifications for a user"""
    from landing.models import Notification
    return Notification.objects.filter(user=user, is_read=False).count()

def mark_notification_as_read(notification_id, user):
    """Mark a specific notification as read"""
    from landing.models import Notification
    try:
        notification = Notification.objects.get(id=notification_id, user=user)
        notification.is_read = True
        notification.save()
        return True
    except Notification.DoesNotExist:
        return False

def mark_all_notifications_as_read(user):
    """Mark all notifications as read for a user"""
    from landing.models import Notification
    Notification.objects.filter(user=user, is_read=False).update(is_read=True)

@login_required
def get_notifications_api(request):
    """API endpoint to get user notifications"""
    notifications = get_user_notifications(request.user)
    notification_data = []
    
    for notification in notifications:
        notification_data.append({
            'id': str(notification.id),
            'title': notification.title,
            'message': notification.message,
            'is_read': notification.is_read,
            'created_at': notification.created_at.strftime('%Y-%m-%d %H:%M:%S'),
            'time_ago': time_since(notification.created_at),
        })
    
    return JsonResponse({
        'notifications': notification_data,
        'unread_count': get_unread_notification_count(request.user)
    })

@login_required
def mark_notification_read_api(request, notification_id):
    """API endpoint to mark a notification as read"""
    if request.method == 'POST':
        success = mark_notification_as_read(notification_id, request.user)
        return JsonResponse({'success': success})
    return JsonResponse({'error': 'Invalid method'}, status=405)

@login_required
def mark_all_notifications_read_api(request):
    """API endpoint to mark all notifications as read"""
    if request.method == 'POST':
        mark_all_notifications_as_read(request.user)
        return JsonResponse({'success': True})
    return JsonResponse({'error': 'Invalid method'}, status=405)

def time_since(datetime_obj):
    """Helper function to get human readable time difference"""
    now = timezone.now()
    diff = now - datetime_obj
    
    if diff.days > 0:
        return f"{diff.days} day{'s' if diff.days > 1 else ''} ago"
    elif diff.seconds > 3600:
        hours = diff.seconds // 3600
        return f"{hours} hour{'s' if hours > 1 else ''} ago"
    elif diff.seconds > 60:
        minutes = diff.seconds // 60
        return f"{minutes} minute{'s' if minutes > 1 else ''} ago"
    else:
        return "Just now"


# ============================================================================
# ENHANCED NOTIFICATION SYSTEM
# ============================================================================

@login_required
def get_notifications_enhanced_api(request):
    """Enhanced API endpoint to get user notifications with filtering and pagination"""
    try:
        from landing.notification_service import NotificationUtils
        
        # Get query parameters
        page = int(request.GET.get('page', 1))
        limit = int(request.GET.get('limit', 20))
        unread_only = request.GET.get('unread_only', 'false').lower() == 'true'
        notification_type = request.GET.get('type', None)
        priority = request.GET.get('priority', None)
        
        # Calculate offset
        offset = (page - 1) * limit
        
        # Get notifications
        from landing.models import Notification
        queryset = Notification.objects.filter(user=request.user).order_by('-created_at')
        
        if unread_only:
            queryset = queryset.filter(is_read=False)
        
        if notification_type:
            queryset = queryset.filter(notification_type=notification_type)
            
        if priority:
            queryset = queryset.filter(priority=priority)
        
        # Get total count
        total_count = queryset.count()
        
        # Get paginated results
        notifications = queryset.order_by('-created_at')[offset:offset + limit]
        
        notification_data = []
        for notification in notifications:
            notification_data.append({
                'id': str(notification.id),
                'title': notification.title,
                'message': notification.message,
                'notification_type': notification.notification_type,
                'priority': notification.priority,
                'form_type': notification.form_type,
                'form_id': str(notification.form_id) if notification.form_id else None,
                'action_required': notification.action_required,
                'action_deadline': notification.action_deadline.isoformat() if notification.action_deadline else None,
                'is_read': notification.is_read,
                'read_at': notification.read_at.isoformat() if notification.read_at else None,
                'created_at': notification.created_at.strftime('%Y-%m-%d %H:%M:%S'),
                'time_ago': time_since(notification.created_at),
                'extra_data': notification.extra_data or {}
            })
        
        # Get unread count
        unread_count = NotificationUtils.get_unread_count(request.user)
        
        return JsonResponse({
            'success': True,
            'notifications': notification_data,
            'total_count': total_count,
            'unread_count': unread_count,
            'page': page,
            'limit': limit,
            'has_more': total_count > (offset + limit)
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


@login_required
def notification_preferences_api(request):
    """API endpoint to get and update notification preferences"""
    from landing.models import NotificationPreference
    
    try:
        if request.method == 'GET':
            # Get user preferences
            prefs, created = NotificationPreference.objects.get_or_create(user=request.user)
            
            return JsonResponse({
                'success': True,
                'preferences': {
                    'email_on_form_approved': prefs.email_on_form_approved,
                    'email_on_form_disapproved': prefs.email_on_form_disapproved,
                    'email_on_document_ready': prefs.email_on_document_ready,
                    'email_on_clearance_completed': prefs.email_on_clearance_completed,
                    'email_daily_digest': prefs.email_daily_digest,
                    'notify_form_submissions': prefs.notify_form_submissions,
                    'notify_status_changes': prefs.notify_status_changes,
                    'notify_document_updates': prefs.notify_document_updates,
                    'notify_system_alerts': prefs.notify_system_alerts,
                    'digest_frequency': prefs.digest_frequency,
                    'digest_time': prefs.digest_time.strftime('%H:%M') if prefs.digest_time else '18:00'
                }
            })
            
        elif request.method == 'POST':
            # Update preferences
            import json
            data = json.loads(request.body)
            
            prefs, created = NotificationPreference.objects.get_or_create(user=request.user)
            
            # Update fields if provided
            for field in ['email_on_form_approved', 'email_on_form_disapproved', 
                         'email_on_document_ready', 'email_on_clearance_completed',
                         'email_daily_digest', 'notify_form_submissions',
                         'notify_status_changes', 'notify_document_updates',
                         'notify_system_alerts', 'digest_frequency']:
                if field in data:
                    setattr(prefs, field, data[field])
            
            if 'digest_time' in data:
                from datetime import time
                hour, minute = map(int, data['digest_time'].split(':'))
                prefs.digest_time = time(hour, minute)
            
            prefs.save()
            
            return JsonResponse({
                'success': True,
                'message': 'Preferences updated successfully'
            })
            
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)
    
    return JsonResponse({'error': 'Invalid method'}, status=405)


@login_required
def get_notification_stats_api(request):
    """Get notification statistics for the user"""
    try:
        from landing.models import Notification
        
        stats = {
            'total': Notification.objects.filter(user=request.user).count(),
            'unread': Notification.objects.filter(user=request.user, is_read=False).count(),
            'high_priority': Notification.objects.filter(
                user=request.user, 
                priority__in=['high', 'urgent'], 
                is_read=False
            ).count(),
            'action_required': Notification.objects.filter(
                user=request.user, 
                action_required=True, 
                is_read=False
            ).count(),
        }
        
        # Get counts by type
        type_counts = {}
        from django.db.models import Count
        type_data = Notification.objects.filter(
            user=request.user, is_read=False
        ).values('notification_type').annotate(count=Count('id'))
        
        for item in type_data:
            type_counts[item['notification_type']] = item['count']
        
        stats['by_type'] = type_counts
        
        return JsonResponse({
            'success': True,
            'stats': stats
        })
        
    except Exception as e:
        return JsonResponse({
            'success': False,
            'error': str(e)
        }, status=500)


def create_enhanced_notification(user, notification_type, title, message, **kwargs):
    """Enhanced notification creation function"""
    try:
        from landing.notification_service import NotificationService
        
        notification = NotificationService.create_notification(
            user=user,
            notification_type=notification_type,
            title=title,
            message=message,
            **kwargs
        )
        
        return notification
        
    except Exception as e:
        logger.error(f"Error creating notification: {str(e)}")
        return None


def send_notification_email(user, subject, message, template_data=None):
    """Send standalone notification email"""
    try:
        from django.core.mail import EmailMultiAlternatives
        from django.template.loader import render_to_string
        from landing.models import EmailNotificationLog
        
        # Create email log
        email_log = EmailNotificationLog.objects.create(
            user=user,
            email_type='standalone',
            recipient_email=user.email,
            subject=subject,
            content=message
        )
        
        # Send email
        email = EmailMultiAlternatives(
            subject=subject,
            body=message,
            from_email=settings.DEFAULT_FROM_EMAIL,
            to=[user.email]
        )
        email.attach_alternative(message, "text/html")
        email.send()
        
        # Update log
        email_log.status = 'sent'
        email_log.sent_at = timezone.now()
        email_log.save()
        
        return True
        
    except Exception as e:
        logger.error(f"Error sending notification email: {str(e)}")
        return False

# ==============================================================================
# BROWSER NOTIFICATION API ENDPOINTS
# ==============================================================================

@login_required
def api_browser_notifications(request):
    """API endpoint to get browser notifications for the current user"""
    try:
        from landing.models import Notification
        
        # Get unshown browser notifications
        notifications = Notification.objects.filter(
            user=request.user,
            notification_type__endswith='_browser',
            extra_data__browser_notification=True,
            is_read=False
        ).order_by('-created_at')[:10]
        
        notification_data = []
        for notification in notifications:
            notification_data.append({
                'id': str(notification.id),
                'title': notification.title,
                'message': notification.message,
                'form_type': notification.form_type,
                'form_id': notification.form_id,
                'created_at': notification.created_at.isoformat(),
                'extra_data': notification.extra_data or {}
            })
        
        return JsonResponse({
            'success': True,
            'notifications': notification_data
        })
        
    except Exception as e:
        logger.error(f"Error fetching browser notifications: {str(e)}")
        return JsonResponse({'success': False, 'error': str(e)})

@login_required
@require_POST
def api_mark_browser_notification_shown(request):
    """Mark a browser notification as shown"""
    try:
        import json
        data = json.loads(request.body)
        notification_id = data.get('notification_id')
        
        if notification_id and notification_id != 'test':
            from landing.models import Notification
            Notification.objects.filter(
                id=notification_id,
                user=request.user
            ).update(is_read=True)
        
        return JsonResponse({'success': True})
        
    except Exception as e:
        logger.error(f"Error marking browser notification as shown: {str(e)}")
        return JsonResponse({'success': False, 'error': str(e)})

# OTP Verification Views for Signup
def verify_otp(request):
    """Display OTP verification page"""
    if 'otp_email' not in request.session:
        messages.error(request, "❌ No verification session found. Please start the signup process.")
        return redirect('login')
    
    return render(request, 'otp.html', {
        'email': request.session.get('otp_email'),
        'user_type': request.session.get('user_type', 'student')
    })

def verify_otp_submit(request):
    """Handle OTP verification submission"""
    if request.method == 'POST':
        try:
            if 'otp_email' not in request.session:
                messages.error(request, "No OTP verification in progress.")
                return redirect('login')
            
            email = request.session['otp_email']
            user_type = request.session['user_type']
            submitted_otp = request.POST.get('otp', '').strip()
            
            if not submitted_otp:
                messages.error(request, "Please enter the OTP code.")
                return redirect('verify_otp')
            
            # Get OTP record
            from landing.models import OTPVerification
            try:
                otp_record = OTPVerification.objects.get(
                    email=email,
                    user_type=user_type,
                    is_verified=False
                )
            except OTPVerification.DoesNotExist:
                messages.error(request, "❌ Invalid verification session. Please start the signup process again.")
                request.session.pop('otp_email', None)
                request.session.pop('user_type', None)
                return redirect('login')
            
            # Check if OTP is expired
            if otp_record.is_expired():
                messages.error(request, "⏰ Your verification code has expired (10 minutes). For security purposes, please start the signup process again.")
                otp_record.delete()
                request.session.pop('otp_email', None)
                request.session.pop('user_type', None)
                return redirect('login')
            
            # Check attempts limit
            if otp_record.attempts >= 3:
                messages.error(request, "🔒 Too many incorrect attempts. For security purposes, please start the signup process again.")
                otp_record.delete()
                request.session.pop('otp_email', None)
                request.session.pop('user_type', None)
                return redirect('login')
            
            # Verify OTP
            if submitted_otp == otp_record.otp_code:
                # OTP is correct, create pending user for approval
                try:
                    from landing.models import PendingUser
                    signup_data = otp_record.signup_data
                    
                    # Create full name
                    full_name = f"{signup_data['first_name']} {signup_data['middle_name']} {signup_data['last_name']} {signup_data.get('suffix', '')}".strip()
                    
                    # Create pending user
                    PendingUser.objects.create(
                        email=email,
                        full_name=full_name,
                        user_type=user_type,
                        contact_number=signup_data['contact'],
                        signup_data=signup_data
                    )
                    
                    # Mark OTP as verified and clean up
                    otp_record.is_verified = True
                    otp_record.save()
                    
                    # Clean up session
                    request.session.pop('otp_email', None)
                    request.session.pop('user_type', None)
                    
                    user_type_display = "Student" if user_type == 'student' else "Alumni"
                    messages.success(request, f"✅ {user_type_display} account submitted successfully! Your account is now pending approval from the registrar. You will receive an email notification once approved.")
                    return redirect('waiting_approval')
                    
                except Exception as e:
                    print(f"❌ Error creating user: {e}")
                    messages.error(request, f"Error creating account: {str(e)}")
                    return redirect('verify_otp')
            else:
                # Wrong OTP
                otp_record.attempts += 1
                otp_record.save()
                remaining_attempts = 3 - otp_record.attempts
                
                if remaining_attempts > 0:
                    if remaining_attempts == 2:
                        messages.error(request, f"❌ Incorrect verification code. Please check your email and try again. You have {remaining_attempts} attempts remaining.")
                    elif remaining_attempts == 1:
                        messages.warning(request, f"⚠️ Incorrect verification code. This is your final attempt! Please double-check the 4-digit code in your email.")
                    else:
                        messages.error(request, f"❌ Incorrect verification code. {remaining_attempts} attempts remaining.")
                else:
                    messages.error(request, "❌ Maximum attempts exceeded. For security purposes, your verification session has been terminated. Please start the signup process again.")
                    otp_record.delete()
                    request.session.pop('otp_email', None)
                    request.session.pop('user_type', None)
                    return redirect('login')
                return redirect('verify_otp')
        
        except Exception as e:
            print(f"❌ Error in OTP verification: {e}")
            messages.error(request, f"Error verifying OTP: {str(e)}")
            return redirect('verify_otp')
    
    return redirect('verify_otp')

def waiting_approval(request):
    """Display waiting for approval page"""
    return render(request, 'waiting-approval.html')

# ========================================
# PENDING USER APPROVAL SYSTEM
# ========================================

from django.views.decorators.csrf import csrf_exempt
from django.views.decorators.http import require_http_methods

@login_required
@require_http_methods(["GET"])
def api_pending_users(request):
    """API to get list of pending users for registrar approval"""
    print(f"DEBUG: api_pending_users called by user: {request.user}")
    print(f"DEBUG: user type: {request.user.user_type}")
    
    if request.user.user_type != 'admin':
        print(f"DEBUG: Access denied for user type: {request.user.user_type}")
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from landing.models import PendingUser
        print(f"DEBUG: Querying PendingUser model...")
        pending_users = PendingUser.objects.filter(approval_status='pending').order_by('-submitted_at')
        print(f"DEBUG: Found {pending_users.count()} pending users")
        
        users_data = []
        for user in pending_users:
            print(f"DEBUG: Processing user: {user.full_name} ({user.email})")
            users_data.append({
                'id': str(user.id),
                'full_name': user.full_name,
                'email': user.email,
                'user_type': user.user_type,
                'contact_number': user.contact_number,
                'submitted_at': user.submitted_at.strftime('%Y-%m-%d %H:%M'),
                'signup_data': user.signup_data
            })
        
        print(f"DEBUG: Returning {len(users_data)} users")
        return JsonResponse({
            'success': True,
            'users': users_data,
            'count': len(users_data)
        })
        
    except Exception as e:
        print(f"DEBUG: Error in api_pending_users: {str(e)}")
        import traceback
        traceback.print_exc()
        return JsonResponse({'error': str(e)}, status=500)

@login_required
def api_pending_user_details(request, user_id):
    """API to get detailed information about a pending user"""
    if request.user.user_type != 'admin':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from landing.models import PendingUser
        pending_user = PendingUser.objects.get(id=user_id, approval_status='pending')
        
        user_data = {
            'id': str(pending_user.id),
            'full_name': pending_user.full_name,
            'email': pending_user.email,
            'user_type': pending_user.user_type,
            'contact_number': pending_user.contact_number,
            'submitted_at': pending_user.submitted_at.strftime('%Y-%m-%d %H:%M'),
            'signup_data': pending_user.signup_data
        }
        
        return JsonResponse({
            'success': True,
            'user': user_data
        })
        
    except PendingUser.DoesNotExist:
        return JsonResponse({'error': 'Pending user not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': str(e)}, status=500)

@login_required
@require_POST
def api_approve_pending_user(request, user_id):
    """API to approve a pending user and create their account"""
    if request.user.user_type != 'admin':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from landing.models import PendingUser
        from django.utils import timezone
        
        pending_user = PendingUser.objects.get(id=user_id, approval_status='pending')
        signup_data = pending_user.signup_data
        
        # Create the actual user account
        full_name = pending_user.full_name
        
        if pending_user.user_type == 'student':
            # Create student user
            user = User.objects.create_user(
                username=pending_user.email,
                full_name=full_name,
                email=pending_user.email,
                user_type='student',
                contact_number=pending_user.contact_number,
            )
            user.set_password(signup_data['password'])
            user.save()
            
            # Handle profile picture if exists
            profile_pic = None
            if 'profile_pic_path' in signup_data:
                profile_pic = move_temp_profile_picture(signup_data['profile_pic_path'])
            
            StudentProfile.objects.create(
                user=user,
                student_number=signup_data['student_id'],
                program=signup_data['course'],
                year_level=1,
                is_graduating=False,
                address=signup_data['address'],
                gender=signup_data['gender'],
                birthdate=signup_data['birthdate'],
                profile_picture=profile_pic
            )
            
        elif pending_user.user_type == 'alumni':
            # Create alumni user
            user = User.objects.create_user(
                username=pending_user.email,
                full_name=full_name,
                email=pending_user.email,
                user_type='alumni',
                contact_number=pending_user.contact_number,
            )
            user.set_password(signup_data['password'])
            user.save()
            
            # Handle profile picture if exists
            profile_pic = None
            if 'profile_pic_path' in signup_data:
                profile_pic = move_temp_profile_picture(signup_data['profile_pic_path'])
            
            AlumniProfile.objects.create(
                user=user,
                alumni_id=signup_data['alumni_id'],
                course_graduated=signup_data['course'],
                year_graduated=signup_data['year_graduated'],
                address=signup_data['address'],
                gender=signup_data['gender'],
                birthdate=signup_data['birthdate'],
                profile_picture=profile_pic
            )
        
        # Update pending user status
        pending_user.approval_status = 'approved'
        pending_user.approved_at = timezone.now()
        pending_user.approved_by = request.user
        pending_user.save()
        
        # Send approval email
        send_approval_email(pending_user)
        
        # Delete the pending user record
        pending_user.delete()
        
        return JsonResponse({
            'success': True,
            'message': f'{pending_user.user_type.title()} account approved successfully!'
        })
        
    except PendingUser.DoesNotExist:
        return JsonResponse({'error': 'Pending user not found'}, status=404)
    except Exception as e:
        import traceback
        traceback.print_exc()
        return JsonResponse({'error': f'Error approving user: {str(e)}'}, status=500)

@login_required
@require_POST
def api_decline_pending_user(request, user_id):
    """API to decline a pending user"""
    if request.user.user_type != 'admin':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from landing.models import PendingUser
        from django.utils import timezone
        import json
        
        data = json.loads(request.body)
        decline_reason = data.get('reason', '').strip()
        
        if not decline_reason:
            return JsonResponse({'error': 'Decline reason is required'}, status=400)
        
        pending_user = PendingUser.objects.get(id=user_id, approval_status='pending')
        
        # Update pending user status
        pending_user.approval_status = 'declined'
        pending_user.decline_reason = decline_reason
        pending_user.approved_at = timezone.now()
        pending_user.approved_by = request.user
        pending_user.save()
        
        # Send decline email
        send_decline_email(pending_user)
        
        return JsonResponse({
            'success': True,
            'message': 'Application declined successfully'
        })
        
    except PendingUser.DoesNotExist:
        return JsonResponse({'error': 'Pending user not found'}, status=404)
    except Exception as e:
        return JsonResponse({'error': f'Error declining user: {str(e)}'}, status=500)

def move_temp_profile_picture(temp_path):
    """Move profile picture from temporary to permanent location"""
    if not temp_path:
        return None
        
    try:
        from django.core.files.storage import default_storage
        from django.core.files.base import ContentFile
        import uuid
        
        if default_storage.exists(temp_path):
            with default_storage.open(temp_path, 'rb') as temp_file:
                final_name = f"profile_pics/{uuid.uuid4()}_{temp_path.split('/')[-1]}"
                profile_pic = ContentFile(temp_file.read(), name=final_name)
            default_storage.delete(temp_path)  # Clean up temp file
            return profile_pic
    except Exception as e:
        print(f"Error moving profile picture: {e}")
    
    return None

def send_approval_email(pending_user):
    """Send approval email to user"""
    try:
        from django.core.mail import EmailMultiAlternatives
        from django.template.loader import render_to_string
        from django.conf import settings
        from datetime import datetime
        
        # Prepare email context
        context = {
            'user': pending_user,
            'approval_date': datetime.now().strftime('%B %d, %Y'),
            'login_url': f"{settings.SITE_URL}/login/" if hasattr(settings, 'SITE_URL') else "http://localhost:8000/login/",
            'current_year': datetime.now().year
        }
        
        # Render HTML email
        html_content = render_to_string('emails/account_approved.html', context)
        
        # Create email subject
        subject = f"🎉 Your {pending_user.user_type.title()} Account Has Been Approved!"
        
        # Create plain text version
        text_content = f"""
Dear {pending_user.full_name},

Congratulations! Your {pending_user.user_type} account application has been approved.

You can now log in to your account at: {context['login_url']}

Account Details:
- Name: {pending_user.full_name}
- Email: {pending_user.email}
- Account Type: {pending_user.user_type.title()}
- Approved Date: {context['approval_date']}

If you need assistance, please contact our registrar office at registrar@pts.edu.ph

Best regards,
PTS Registrar Office
        """
        
        # Send email
        email = EmailMultiAlternatives(
            subject=subject,
            body=text_content,
            from_email=settings.DEFAULT_FROM_EMAIL,
            to=[pending_user.email]
        )
        email.attach_alternative(html_content, "text/html")
        email.send()
        
        print(f"✅ Approval email sent successfully to {pending_user.email}")
        
    except Exception as e:
        print(f"❌ Error sending approval email: {e}")
        import traceback
        traceback.print_exc()

def send_decline_email(pending_user):
    """Send decline email to user"""
    try:
        from django.core.mail import EmailMultiAlternatives
        from django.template.loader import render_to_string
        from django.conf import settings
        from datetime import datetime
        
        # Prepare email context
        context = {
            'user': pending_user,
            'application_date': pending_user.submitted_at.strftime('%B %d, %Y'),
            'review_date': datetime.now().strftime('%B %d, %Y'),
            'decline_reason': pending_user.decline_reason,
            'current_year': datetime.now().year
        }
        
        # Render HTML email
        html_content = render_to_string('emails/account_declined.html', context)
        
        # Create email subject
        subject = f"Application Status Update - {pending_user.user_type.title()} Account"
        
        # Create plain text version
        text_content = f"""
Dear {pending_user.full_name},

Thank you for your interest in the Philippine Technical School clearance system. 

After careful review, we are unable to approve your {pending_user.user_type} account application at this time.

Application Details:
- Name: {pending_user.full_name}
- Email: {pending_user.email}
- Account Type: {pending_user.user_type.title()}
- Application Date: {context['application_date']}
- Review Date: {context['review_date']}

Reason for non-approval:
{pending_user.decline_reason}

If you have questions or would like to discuss this decision, please contact our registrar office at registrar@pts.edu.ph or call (042) 123-4567.

Best regards,
PTS Registrar Office
        """
        
        # Send email
        email = EmailMultiAlternatives(
            subject=subject,
            body=text_content,
            from_email=settings.DEFAULT_FROM_EMAIL,
            to=[pending_user.email]
        )
        email.attach_alternative(html_content, "text/html")
        email.send()
        
        print(f"✅ Decline email sent successfully to {pending_user.email}")
        
    except Exception as e:
        print(f"❌ Error sending decline email: {e}")
        import traceback
        traceback.print_exc()

def resend_otp(request):
    """Resend OTP code"""
    if request.method == 'POST':
        try:
            if 'otp_email' not in request.session:
                return JsonResponse({'success': False, 'error': 'No OTP session found'})
            
            email = request.session['otp_email']
            user_type = request.session['user_type']
            
            # Get existing OTP record
            from landing.models import OTPVerification
            try:
                otp_record = OTPVerification.objects.get(
                    email=email,
                    user_type=user_type,
                    is_verified=False
                )
            except OTPVerification.DoesNotExist:
                return JsonResponse({'success': False, 'error': 'OTP session not found'})
            
            # Generate new OTP
            import random
            from datetime import timedelta
            new_otp = str(random.randint(1000, 9999))
            
            # Update OTP record
            otp_record.otp_code = new_otp
            otp_record.expires_at = timezone.now() + timedelta(minutes=10)
            otp_record.attempts = 0  # Reset attempts
            otp_record.save()
            
            # Send new OTP
            from django.core.mail import send_mail
            from django.conf import settings
            
            subject = "🔄 New Verification Code - PTS College and Advanced Studies"
            user_type_display = "Student" if user_type == 'student' else "Alumni"
            department = "IT Department" if user_type == 'student' else "Alumni Relations Office"
            contact_email = "admin@ptscollege.edu.ph" if user_type == 'student' else "alumni@ptscollege.edu.ph"
            
            message = f"""
Dear {user_type_display},

You requested a new verification code for your PTS College and Advanced Studies account.

Your new verification code is:

═══════════════════════════════════════
    VERIFICATION CODE: {new_otp}
═══════════════════════════════════════

⏰ This new code will expire in 10 minutes for security purposes.

SECURITY NOTICE:
• Your previous code has been deactivated
• Do not share this code with anyone
• Complete your registration promptly

If you did not request a new code, please contact us immediately.

Best regards,
{department}
PTS College and Advanced Studies
Clearance Management System

---
This is an automated message. Please do not reply to this email.
For support, contact: {contact_email}
            """
            
            send_mail(
                subject=subject,
                message=message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[email],
                fail_silently=False
            )
            
            print(f"✅ New OTP sent to {email}: {new_otp}")
            return JsonResponse({'success': True, 'message': 'New OTP sent successfully'})
            
        except Exception as e:
            print(f"❌ Error resending OTP: {e}")
            return JsonResponse({'success': False, 'error': str(e)})
    
    return JsonResponse({'success': False, 'error': 'Invalid request method'})

# Forgot Password Functionality
def forgot_password(request):
    """Display forgot password page"""
    return render(request, 'forgot-password.html')

def forgot_password_submit(request):
    """Handle forgot password form submission"""
    if request.method == 'POST':
        try:
            email = request.POST.get('email', '').strip().lower()
            is_ajax = request.headers.get('X-Requested-With') == 'XMLHttpRequest' or 'application/json' in request.headers.get('Accept', '')
            
            if not email:
                if is_ajax:
                    return JsonResponse({'success': False, 'message': 'Please enter your email address.'})
                messages.error(request, "❌ Please enter your email address.")
                return redirect('forgot_password')
            
            # Check if user exists
            try:
                user = User.objects.get(email=email)
            except User.DoesNotExist:
                # Don't reveal if email exists or not for security
                success_message = f"If an account with {email} exists, password reset instructions have been sent. Please check your inbox."
                if is_ajax:
                    return JsonResponse({'success': True, 'message': success_message})
                messages.success(request, f"📧 {success_message}")
                return redirect('login')
            
            # Generate reset token
            from landing.models import PasswordResetToken
            import secrets
            from datetime import timedelta
            from django.core.mail import send_mail
            from django.conf import settings
            
            # Delete any existing tokens for this email
            PasswordResetToken.objects.filter(email=email, is_used=False).delete()
            
            # Generate secure token
            token = secrets.token_urlsafe(32)
            expires_at = timezone.now() + timedelta(hours=1)  # 1 hour expiry
            
            # Create reset token record
            reset_token = PasswordResetToken.objects.create(
                email=email,
                token=token,
                user=user,
                expires_at=expires_at
            )
            
            # Send password reset email
            reset_url = request.build_absolute_uri(f"/reset-password/{token}/")
            subject = "🔐 Password Reset Request - PTS College and Advanced Studies"
            
            message = f"""
Dear {user.full_name},

We received a request to reset your password for your PTS College and Advanced Studies account.

To reset your password, please click the link below:

{reset_url}

This link will expire in 1 hour for security purposes.

SECURITY NOTICE:
• If you did not request this password reset, please ignore this email
• Do not share this link with anyone
• The link can only be used once

If you continue to have trouble accessing your account, please contact our IT support.

Best regards,
IT Department
PTS College and Advanced Studies
Clearance Management System

---
This is an automated message. Please do not reply to this email.
For support, contact: admin@ptscollege.edu.ph
            """
            
            send_mail(
                subject=subject,
                message=message,
                from_email=settings.DEFAULT_FROM_EMAIL,
                recipient_list=[email],
                fail_silently=False
            )
            
            print(f"✅ Password reset email sent to {email}")
            success_message = f"If an account with {email} exists, password reset instructions have been sent. Please check your inbox."
            
            if is_ajax:
                return JsonResponse({'success': True, 'message': success_message})
            
            messages.success(request, f"📧 {success_message}")
            return redirect('login')
            
        except Exception as e:
            print(f"❌ Error in forgot password: {e}")
            error_message = "An error occurred. Please try again later."
            
            if request.headers.get('X-Requested-With') == 'XMLHttpRequest' or 'application/json' in request.headers.get('Accept', ''):
                return JsonResponse({'success': False, 'message': error_message})
            
            messages.error(request, f"⚠️ {error_message}")
            return redirect('forgot_password')
    
    return redirect('forgot_password')

def reset_password(request, token):
    """Display password reset form"""
    try:
        from django.contrib import messages
        from landing.models import PasswordResetToken
        
        # Clear any existing messages to avoid showing stale messages from forgot password flow
        storage = messages.get_messages(request)
        for message in storage:
            pass  # This consumes and clears the messages
        
        # Validate token
        try:
            reset_token = PasswordResetToken.objects.get(
                token=token,
                is_used=False
            )
        except PasswordResetToken.DoesNotExist:
            messages.error(request, "❌ Invalid or expired reset link. Please request a new password reset.")
            return redirect('forgot_password')
        
        # Check if token is expired
        if reset_token.is_expired():
            messages.error(request, "⏰ This reset link has expired. Please request a new password reset.")
            reset_token.delete()
            return redirect('forgot_password')
        
        return render(request, 'reset-password.html', {
            'token': token,
            'email': reset_token.email,
            'user_name': reset_token.user.full_name if reset_token.user else 'User'
        })
        
    except Exception as e:
        print(f"❌ Error in reset password view: {e}")
        messages.error(request, "⚠️ An error occurred. Please try again.")
        return redirect('forgot_password')

def reset_password_submit(request):
    """Handle password reset form submission"""
    if request.method == 'POST':
        try:
            token = request.POST.get('token', '').strip()
            new_password = request.POST.get('new_password', '').strip()
            confirm_password = request.POST.get('confirm_password', '').strip()
            
            if not all([token, new_password, confirm_password]):
                messages.error(request, "❌ All fields are required.")
                return redirect('reset_password', token=token)
            
            if new_password != confirm_password:
                messages.error(request, "❌ Passwords do not match. Please try again.")
                return redirect('reset_password', token=token)
            
            if len(new_password) < 8:
                messages.error(request, "❌ Password must be at least 8 characters long.")
                return redirect('reset_password', token=token)
            
            # Validate token
            from landing.models import PasswordResetToken
            try:
                reset_token = PasswordResetToken.objects.get(
                    token=token,
                    is_used=False
                )
            except PasswordResetToken.DoesNotExist:
                messages.error(request, "❌ Invalid or expired reset link. Please request a new password reset.")
                return redirect('forgot_password')
            
            # Check if token is expired
            if reset_token.is_expired():
                messages.error(request, "⏰ This reset link has expired. Please request a new password reset.")
                reset_token.delete()
                return redirect('forgot_password')
            
            # Update user password
            user = reset_token.user
            if user:
                user.set_password(new_password)
                user.save()
                
                # Mark token as used
                reset_token.is_used = True
                reset_token.save()
                
                print(f"✅ Password reset successful for {user.email}")
                # Instead of redirect, render success page with context
                context = {
                    'success': True,
                    'user_name': user.full_name or user.email,
                    'email': user.email
                }
                return render(request, 'reset-password-success.html', context)
            else:
                messages.error(request, "❌ User account not found.")
                return redirect('forgot_password')
            
        except Exception as e:
            print(f"❌ Error in reset password submit: {e}")
            token = request.POST.get('token', '')
            if token:
                messages.error(request, "⚠️ An error occurred while resetting your password. Please try again.")
                return redirect('reset_password', token=token)
            else:
                messages.error(request, "⚠️ Invalid request. Please request a new password reset.")
                return redirect('forgot_password')
    
    return redirect('forgot_password')


# --------------------
# ACADEMIC CURRICULUM API
# --------------------
@login_required
def academic_programs_api(request):
    """API endpoint to get academic programs data for courses management"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    try:
        from landing.models import AcademicProgram
        
        programs_data = []
        programs = AcademicProgram.objects.all().order_by('program_type', 'code')
        
        for program in programs:
            program_data = {
                'id': str(program.id),
                'code': program.code,
                'name': program.name,
                'program_type': program.program_type,
                'program_type_display': program.get_program_type_display(),
                'duration_years': program.duration_years,
                'description': program.description,
                'is_active': program.is_active,
                'created_at': program.created_at.strftime('%Y-%m-%d %H:%M')
            }
            programs_data.append(program_data)
        
        return JsonResponse({
            'success': True,
            'programs': programs_data,
            'total_programs': len(programs_data)
        })
        
    except Exception as e:
        print(f"Error in academic_programs_api: {e}")
        return JsonResponse({'error': 'Failed to load programs data'}, status=500)

@login_required
@require_http_methods(["GET"])
def courses_api(request):
    """API endpoint to fetch courses data with filtering and search"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'success': False, 'error': 'Access denied'}, status=403)
    
    try:
        from landing.models import AcademicProgram, AcademicYearLevel, AcademicSemester
        from django.db.models import Q, Count
        from datetime import datetime
        
        # Get filter parameters
        search = request.GET.get('search', '').strip()
        program_filter = request.GET.get('program', '')
        year_filter = request.GET.get('year', '')
        
        # Base query - get all programs
        programs = AcademicProgram.objects.all().order_by('program_type', 'code')
        
        # Apply program filter
        if program_filter:
            if program_filter == 'undergraduate':
                programs = programs.filter(program_type='undergraduate')
            elif program_filter == 'graduate':
                programs = programs.filter(program_type='graduate')
        
        # Apply search filter
        if search:
            programs = programs.filter(
                Q(code__icontains=search) | 
                Q(name__icontains=search) |
                Q(description__icontains=search)
            )
        
        courses_data = []
        current_year = datetime.now().year
        
        for program in programs:
            # Generate academic year (current or default)
            if year_filter:
                academic_year = year_filter
            else:
                academic_year = f"{current_year}-{current_year + 1}"
            
            # Get display name for program type
            program_type_display = 'Graduate Program' if program.program_type == 'graduate' else 'Undergraduate Program'
            
            course_data = {
                'id': str(program.id),
                'program': program_type_display,
                'code': program.code,
                'name': program.name,
                'academic_year': academic_year,
                'created_at': program.created_at.strftime('%b %d, %Y'),
                'description': program.description,
                'duration_years': program.duration_years,
                'year_levels_count': program.year_levels.count(),
                'total_semesters': program.year_levels.count() * 2  # Simple calculation instead of complex query
            }
            courses_data.append(course_data)
        
        return JsonResponse({
            'success': True,
            'courses': courses_data,
            'total_courses': len(courses_data)
        })
        
    except Exception as e:
        print(f"Error in courses_api: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Failed to fetch courses data',
            'courses': [],
            'total_courses': 0
        })

@login_required
@require_http_methods(["GET"])
def course_detail_api(request, course_id):
    """API endpoint to fetch detailed course information"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'success': False, 'error': 'Access denied'}, status=403)
    
    try:
        from landing.models import AcademicProgram
        from datetime import datetime
        
        program = AcademicProgram.objects.get(id=course_id)
        current_year = datetime.now().year
        academic_year = f"{current_year}-{current_year + 1}"
        
        # Build year levels and semesters data
        year_levels_data = []
        for year_level in program.year_levels.all().order_by('year_number'):
            semesters_data = []
            for semester in year_level.semesters.all().order_by('semester_number'):
                subjects_data = []
                for subject in semester.subjects.all().order_by('order', 'code'):
                    subjects_data.append({
                        'id': str(subject.id),
                        'code': subject.code,
                        'name': subject.name,
                        'professor': subject.professor,
                        'units': subject.units,
                        'order': subject.order
                    })
                
                semesters_data.append({
                    'id': str(semester.id),
                    'semester_number': semester.semester_number,
                    'semester_name': semester.semester_name,
                    'subjects': subjects_data,
                    'total_subjects': len(subjects_data),
                    'total_units': sum(s['units'] for s in subjects_data)
                })
            
            year_levels_data.append({
                'id': str(year_level.id),
                'year_number': year_level.year_number,
                'year_name': year_level.year_name,
                'semesters': semesters_data
            })
        
        # Get display name for program type
        program_type_display = 'Graduate Program' if program.program_type == 'graduate' else 'Undergraduate Program'
        
        course_detail = {
            'id': str(program.id),
            'code': program.code,
            'name': program.name,
            'program_type': program_type_display,
            'description': program.description,
            'duration_years': program.duration_years,
            'academic_year': academic_year,
            'created_at': program.created_at.strftime('%b %d, %Y'),
            'year_levels': year_levels_data,
            'total_subjects': len([
                subject
                for yl in year_levels_data 
                for sem in yl['semesters']
                for subject in sem['subjects']
            ])
        }
        
        return JsonResponse({
            'success': True,
            'course': course_detail
        })
        
    except AcademicProgram.DoesNotExist:
        return JsonResponse({
            'success': False,
            'error': 'Course not found'
        }, status=404)
    except Exception as e:
        print(f"Error in course_detail_api: {e}")
        return JsonResponse({
            'success': False,
            'error': 'Failed to fetch course details'
        })

@login_required
@require_http_methods(["POST"])
def create_course_api(request):
    """API endpoint to create a new course with curriculum data"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'success': False, 'error': 'Access denied'}, status=403)
    
    try:
        import json
        from landing.models import AcademicProgram, AcademicYearLevel, AcademicSemester, AcademicSubject
        
        # Parse JSON data from request
        data = json.loads(request.body)
        
        # Validate required fields
        required_fields = ['program_type', 'course_code', 'course_name']
        for field in required_fields:
            if not data.get(field):
                return JsonResponse({'success': False, 'error': f'Missing required field: {field}'})
        
        # Create the program
        with transaction.atomic():
            program = AcademicProgram.objects.create(
                code=data['course_code'],
                name=data['course_name'],
                program_type=data['program_type'],
                duration_years=len(data.get('year_levels', [])),
                description=data.get('course_description', '')
            )
            
            # Create year levels and subjects
            year_levels_data = data.get('year_levels', [])
            for year_data in year_levels_data:
                year_level = AcademicYearLevel.objects.create(
                    program=program,
                    year_number=year_data['year_number'],
                    year_name=year_data['year_name']
                )
                
                # Create semesters
                for sem_data in year_data.get('semesters', []):
                    semester = AcademicSemester.objects.create(
                        year_level=year_level,
                        semester_number=sem_data['semester_number'],
                        semester_name=sem_data['semester_name']
                    )
                    
                    # Create subjects
                    for order, subject_data in enumerate(sem_data.get('subjects', [])):
                        AcademicSubject.objects.create(
                            semester=semester,
                            code=subject_data['code'],
                            name=subject_data['name'],
                            professor=subject_data.get('professor', 'TBA'),
                            units=int(subject_data['units']),
                            order=order
                        )
        
        return JsonResponse({
            'success': True,
            'message': 'Course created successfully',
            'program_id': str(program.id)
        })
        
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    except Exception as e:
        print(f"Error creating course: {e}")
        return JsonResponse({'success': False, 'error': str(e)})

@login_required
@require_http_methods(["PUT"])
def update_course_api(request, course_id):
    """API endpoint to update an existing course with curriculum data"""
    if request.user.user_type not in ['admin', 'registrar']:
        return JsonResponse({'success': False, 'error': 'Access denied'}, status=403)
    
    try:
        import json
        from landing.models import AcademicProgram, AcademicYearLevel, AcademicSemester, AcademicSubject
        
        # Get the program
        program = AcademicProgram.objects.get(id=course_id)
        
        # Parse JSON data from request
        data = json.loads(request.body)
        
        with transaction.atomic():
            # Update program details
            program.name = data.get('course_name', program.name)
            program.program_type = data.get('program_type', program.program_type)
            program.description = data.get('course_description', program.description)
            program.duration_years = len(data.get('year_levels', []))
            program.save()
            
            # Clear existing curriculum structure
            AcademicSubject.objects.filter(semester__year_level__program=program).delete()
            AcademicSemester.objects.filter(year_level__program=program).delete()
            AcademicYearLevel.objects.filter(program=program).delete()
            
            # Recreate curriculum structure
            year_levels_data = data.get('year_levels', [])
            for year_data in year_levels_data:
                year_level = AcademicYearLevel.objects.create(
                    program=program,
                    year_number=year_data['year_number'],
                    year_name=year_data['year_name']
                )
                
                # Create semesters
                for sem_data in year_data.get('semesters', []):
                    semester = AcademicSemester.objects.create(
                        year_level=year_level,
                        semester_number=sem_data['semester_number'],
                        semester_name=sem_data['semester_name']
                    )
                    
                    # Create subjects
                    for order, subject_data in enumerate(sem_data.get('subjects', [])):
                        AcademicSubject.objects.create(
                            semester=semester,
                            code=subject_data['code'],
                            name=subject_data['name'],
                            professor=subject_data.get('professor', 'TBA'),
                            units=int(subject_data['units']),
                            order=order
                        )
        
        return JsonResponse({
            'success': True,
            'message': 'Course updated successfully'
        })
        
    except AcademicProgram.DoesNotExist:
        return JsonResponse({'success': False, 'error': 'Course not found'}, status=404)
    except json.JSONDecodeError:
        return JsonResponse({'success': False, 'error': 'Invalid JSON data'})
    except Exception as e:
        print(f"Error updating course: {e}")
        return JsonResponse({'success': False, 'error': str(e)})

@csrf_exempt
def courses_for_signup_api(request):
    """API endpoint to fetch courses for signup form"""
    if request.method != 'GET':
        return JsonResponse({'success': False, 'error': 'Method not allowed'}, status=405)
    
    try:
        from landing.models import AcademicProgram
        
        # Get all courses with basic information
        courses = AcademicProgram.objects.all().order_by('name')
        
        courses_data = []
        for course in courses:
            courses_data.append({
                'code': course.code,
                'name': course.name,
                'program_type': course.program_type
            })
        
        return JsonResponse({
            'success': True,
            'courses': courses_data
        })
        
    except Exception as e:
        print(f"Error fetching courses for signup: {e}")
        return JsonResponse({'success': False, 'error': str(e)})

@csrf_exempt
def enrollment_subjects_api(request):
    """API endpoint to fetch subjects for enrollment form based on program/year/semester"""
    if request.method != 'GET':
        return JsonResponse({'success': False, 'error': 'Method not allowed'}, status=405)
    
    try:
        from landing.models import AcademicProgram, AcademicYearLevel, AcademicSemester, AcademicSubject
        
        program_code = request.GET.get('program')
        year_level = request.GET.get('year_level')
        semester = request.GET.get('semester')
        
        if not all([program_code, year_level, semester]):
            return JsonResponse({'success': False, 'error': 'Missing required parameters: program, year_level, semester'})
        
        # Get the program
        try:
            program = AcademicProgram.objects.get(code=program_code)
        except AcademicProgram.DoesNotExist:
            return JsonResponse({'success': False, 'error': 'Program not found'})
        
        # Get the year level
        try:
            year_obj = AcademicYearLevel.objects.get(program=program, year_number=int(year_level))
        except (AcademicYearLevel.DoesNotExist, ValueError):
            return JsonResponse({'success': False, 'error': 'Year level not found'})
        
        # Get the semester
        try:
            semester_obj = AcademicSemester.objects.get(year_level=year_obj, semester_number=int(semester))
        except (AcademicSemester.DoesNotExist, ValueError):
            return JsonResponse({'success': False, 'error': 'Semester not found'})
        
        # Get subjects for this semester
        subjects = AcademicSubject.objects.filter(semester=semester_obj).order_by('order', 'code')
        
        subjects_data = []
        for subject in subjects:
            subjects_data.append({
                'code': subject.code,
                'name': subject.name,
                'professor': subject.professor,
                'units': subject.units
            })
        
        return JsonResponse({
            'success': True,
            'subjects': subjects_data
        })
        
    except Exception as e:
        print(f"Error fetching subjects for enrollment: {e}")
        return JsonResponse({'success': False, 'error': str(e)})

@csrf_exempt 
def enrollment_programs_api(request):
    """API endpoint to fetch programs for enrollment form"""
    if request.method != 'GET':
        return JsonResponse({'success': False, 'error': 'Method not allowed'}, status=405)
    
    try:
        from landing.models import AcademicProgram
        
        # Get all programs with basic information
        programs = AcademicProgram.objects.all().order_by('program_type', 'name')
        
        programs_data = []
        for program in programs:
            programs_data.append({
                'code': program.code,
                'name': program.name,
                'program_type': program.program_type
            })
        
        return JsonResponse({
            'success': True,
            'programs': programs_data
        })
        
    except Exception as e:
        print(f"Error fetching programs for enrollment: {e}")
        return JsonResponse({'success': False, 'error': str(e)})

@csrf_exempt
def enrollment_year_levels_api(request):
    """API endpoint to fetch year levels for a specific program"""
    if request.method != 'GET':
        return JsonResponse({'success': False, 'error': 'Method not allowed'}, status=405)
    
    try:
        from landing.models import AcademicProgram, AcademicYearLevel
        
        program_code = request.GET.get('program')
        if not program_code:
            return JsonResponse({'success': False, 'error': 'Program code is required'})
        
        try:
            program = AcademicProgram.objects.get(code=program_code)
        except AcademicProgram.DoesNotExist:
            return JsonResponse({'success': False, 'error': 'Program not found'})
        
        # Get year levels for this program
        year_levels = AcademicYearLevel.objects.filter(program=program).order_by('year_number')
        
        year_levels_data = []
        for year in year_levels:
            year_levels_data.append({
                'year_number': year.year_number,
                'year_name': year.year_name
            })
        
        return JsonResponse({
            'success': True,
            'year_levels': year_levels_data
        })
        
    except Exception as e:
        print(f"Error fetching year levels: {e}")
        return JsonResponse({'success': False, 'error': str(e)})

@login_required
def student_graduation_pdf(request):
    """Student PDF download for graduation forms"""
    if request.user.user_type != 'student':
        return JsonResponse({'error': 'Access denied'}, status=403)
    
    graduation_ids = request.GET.get('ids', '').split(',')
    graduation_ids = [gid.strip() for gid in graduation_ids if gid.strip()]
    download_mode = request.GET.get('download', 'false').lower() == 'true'
    
    if not graduation_ids:
        return JsonResponse({'error': 'No graduation IDs provided'}, status=400)
    
    try:
        graduation_forms = []
        for graduation_id in graduation_ids:
            try:
                graduation = GraduationForm.objects.get(id=graduation_id, user=request.user)
                profile = getattr(graduation.user, 'profile', None)
                graduation_forms.append({
                    'graduation': graduation,
                    'student': graduation.user,
                    'profile': profile
                })
            except GraduationForm.DoesNotExist:
                continue
    
        if not graduation_forms:
            return JsonResponse({'error': 'No valid graduation forms found'}, status=400)
        
        context = {
            'graduation_forms': graduation_forms,
            'is_preview': True,
            'download_mode': download_mode,
        }
        
        # If download mode, return HTML with special headers for browser PDF
        if download_mode:
            # Set context for download mode
            context['download_mode'] = True
            
            # Return HTML response with PDF-friendly headers
            response = render(request, 'pdf/pdf-graduation.html', context)
            
            # Add headers to suggest PDF download
            student_name = graduation_forms[0]['student'].full_name.replace(' ', '_')
            filename = f"graduation_form_{student_name}.pdf"
            
            # These headers will make browsers offer to save as PDF when printing
            response['Content-Type'] = 'text/html'
            response['X-Suggested-Filename'] = filename
            
            return response
        else:
            # For print mode, return regular HTML
            return render(request, 'pdf/pdf-graduation.html', context)
        
    except Exception as e:
        print(f"Error in student_graduation_pdf: {e}")
        return JsonResponse({'error': str(e)}, status=500)

